
<!DOCTYPE html>

<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta content="Описание концепций, языковых и инструментальных средств функционально-потокового параллельного программирования." name="description" />
<meta content="парадигмы программирования, функционально-потоковое параллельное программирование" name="keywords" />

    <title>13. Об ядре языка как о праязыке &#8212; документация smile </title>
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/translations.js"></script>
    <link rel="shortcut icon" href="_static/smile48.png"/>
    <link rel="index" title="Алфавитный указатель" href="genindex.html" />
    <link rel="search" title="Поиск" href="search.html" />
    <link rel="next" title="14. Что еще стоит не забыть" href="More.html" />
    <link rel="prev" title="12. Транслятор языка программирования Smile" href="SmileTranslator.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Навигация</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Алфавитный указатель"
             accesskey="I">указатель</a></li>
        <li class="right" >
          <a href="More.html" title="14. Что еще стоит не забыть"
             accesskey="N">вперёд</a> |</li>
        <li class="right" >
          <a href="SmileTranslator.html" title="12. Транслятор языка программирования Smile"
             accesskey="P">назад</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">документация smile </a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">13. </span>Об ядре языка как о праязыке</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="id1">
<h1><span class="section-number">13. </span>Об ядре языка как о праязыке<a class="headerlink" href="#id1" title="Ссылка на этот заголовок">¶</a></h1>
<div class="section" id="id2">
<h2><span class="section-number">13.1. </span>Введение<a class="headerlink" href="#id2" title="Ссылка на этот заголовок">¶</a></h2>
<p>В данном документе представлены размышления по выделению в ЯФППП Smile некоторого ядра, которое бы являлось универсальной базовой составляющей для различных предметно-ориентированных ответвлений. Предполагается, что это ядро может описывать общие операторы и операции (базовые функции), обеспечивающие формирование основного каркаса программы. Для того, чтобы сориентироваться на конкретную предметную область, предполагается дописывать соответствующие операции и данные, которые бы реализовывали дополнительный функционал, связанный с обработкой данных в конкретной предметной области. Предполагается, что таким образом можно будет готовить различные версии в зависимости от того, что требуется в том или ином случае. В частности предполагается, что для универсальных применений требуется свой базовый набор типов данных и операций над ними. Для программирования на уровне ПЛИС необходимо сформировать набор соответствующих низкоуровневых данных (биты, байты) и операций над ними. Разделение по подъязыкам в данном случае позволяет не усложнять универсальностью единый язык и избежать коллизий, связанных с противоречивостью различных типов данных, которые в общем случае могут иметь различную семантику при одинаковом синтаксисе.</p>
</div>
<div class="section" id="id3">
<h2><span class="section-number">13.2. </span>Определения<a class="headerlink" href="#id3" title="Ссылка на этот заголовок">¶</a></h2>
<p>Предворительное определение рассматриваемого ядра как праязыка базируется на следующем определении из Википедии:</p>
<blockquote>
<div><p><em>Праязы́к (калька с нем. Ursprache) — предковый язык, из которого возникли языки, относящиеся к данной семье языков или группе языков.</em></p>
</div></blockquote>
<p>Вполне понятно, что речь в данном случае идет несколько о другом варианты возникновения семейства искусственных языков, но достаточно сложно подобрать другие варианты названия для того ядра, которое предполагается выделить. По аналогии с объектно-ориентированным программированием можно было бы говорить о <strong>суперязыке</strong> (там имеется понятие <strong>суперкласса</strong>). Однако в случае языка программирования это звучит как-то нескромно. Можно также говорить о базовом языке, от которого появляются дочерние языке. Но в целом получается тоже не вполне конкретно. Вариантом на эту же тему является понятие <strong>родительский язык</strong>, от которого формируются дочерние языке, что уже фактически является эквивалентом праязыка.</p>
<p>Другой ассоциацией на название является терминология из области операционных систем. В ОС выделяется ядро, к которому прикручиваются различные модули. Поэтому в принципе можно говорить об ядре языка функционально потокового параллельного программирования. Тогда различные версии подъязвков можно рассматривать в качестве расширений ядра.</p>
<p>Пока останавливаюсть на термине <strong>праязык функционально-потокового параллельного программирования (ПЯФППП)</strong>. При переходе на тексты более официального уровня можно еще подумать о названии. Помимо этого предполагается праязык рассматривать под названием <strong>Smile0</strong>.</p>
</div>
<div class="section" id="id4">
<h2><span class="section-number">13.3. </span>Состав праязыка<a class="headerlink" href="#id4" title="Ссылка на этот заголовок">¶</a></h2>
<p>Текущий состав Smile0 формируется на основе описания языков программирования Smile и Пифагор, путем выделения операторов и операций не связанных со спецификой обработки данных, но обеспечивающих формирование общей структуры программных артефактов. В данном документе пока проводится выделение включенных артефактов. Их описание будет сформировано в ходе формирования общего описания Smile0.</p>
<div class="section" id="id5">
<h3><span class="section-number">13.3.1. </span>Элементарные конструкции<a class="headerlink" href="#id5" title="Ссылка на этот заголовок">¶</a></h3>
<p>Практически все элементарные конструкции включаются в состоав праязыка. Это:</p>
<ul class="simple">
<li><p>разделители;</p></li>
<li><p>комментарии;</p></li>
<li><p>идентификаторы;</p></li>
<li><p>ключевые слова.</p></li>
</ul>
</div>
<div class="section" id="id6">
<h3><span class="section-number">13.3.2. </span>Обозначения<a class="headerlink" href="#id6" title="Ссылка на этот заголовок">¶</a></h3>
<p>Обозначения также включены в состав праязыка.</p>
</div>
<div class="section" id="id7">
<h3><span class="section-number">13.3.3. </span>Предопределенные типы данных<a class="headerlink" href="#id7" title="Ссылка на этот заголовок">¶</a></h3>
</div>
</div>
<div class="section" id="id8">
<h2><span class="section-number">13.4. </span>Значащие величины (константы)<a class="headerlink" href="#id8" title="Ссылка на этот заголовок">¶</a></h2>
<p>Включены предопределенные типы данных, встречающиеся в операторах и операциях праязыка. Остальные типы данных убраны и будут добавляться в подъязыках. Эти типы данных представленны в следующей таблице:</p>
<table class="docutils align-default" id="id23">
<caption><span class="caption-text">Предопределенные типы</span><a class="headerlink" href="#id23" title="Постоянная ссылка на таблицу">¶</a></caption>
<colgroup>
<col style="width: 44%" />
<col style="width: 33%" />
<col style="width: 23%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Название</p></th>
<th class="head"><p>Обозначение типа</p></th>
<th class="head"><p>Организация</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>сигнал</p></td>
<td><p>signal (nil)</p></td>
<td><p>атом</p></td>
</tr>
<tr class="row-odd"><td><p>целый</p></td>
<td><p>int</p></td>
<td><p>атом</p></td>
</tr>
<tr class="row-even"><td><p>логический</p></td>
<td><p>bool</p></td>
<td><p>атом</p></td>
</tr>
<tr class="row-odd"><td><p>спецзнаковый</p></td>
<td><p>spec (nil)</p></td>
<td><p>атом</p></td>
</tr>
<tr class="row-even"><td><p>ошибочный</p></td>
<td><p>error (nil)</p></td>
<td><p>атом</p></td>
</tr>
<tr class="row-odd"><td><p>список данных</p></td>
<td><p>datalist</p></td>
<td><p>составной</p></td>
</tr>
<tr class="row-even"><td><p>параллельный список</p></td>
<td><p>parlist</p></td>
<td><p>составной</p></td>
</tr>
<tr class="row-odd"><td><p>задержанный список</p></td>
<td><p>delaylist</p></td>
<td><p>составной</p></td>
</tr>
<tr class="row-even"><td><p>асинхронный список</p></td>
<td><p>asynlist</p></td>
<td><p>составной</p></td>
</tr>
<tr class="row-odd"><td><p>базовая функция</p></td>
<td><p>func</p></td>
<td><p>атом</p></td>
</tr>
<tr class="row-even"><td><p>функция</p></td>
<td><p>func (nil)</p></td>
<td><p>определяемый</p></td>
</tr>
<tr class="row-odd"><td><p>тип</p></td>
<td><p>type</p></td>
<td><p>определяемый</p></td>
</tr>
</tbody>
</table>
<p>Следует отметить отсутствие в данной таблицы символьных и действительных типов данных, так как они не используются в наборе базовых операторов и операций праязыка. То есть, они будут, при необходимости, добавляться в соответствующих подъязыках.</p>
<div class="section" id="id9">
<h3><span class="section-number">13.4.1. </span>Значащие величины (константы)<a class="headerlink" href="#id9" title="Ссылка на этот заголовок">¶</a></h3>
<p>Как и типы, в праязык включаются те константы, которые соответствуют используемым типам:</p>
<ul class="simple">
<li><p>сигнальная константа, задаваемая символом «.»;</p></li>
<li><p>целочисленная константа, записываемая в соответствии с принятым синтаксисом и ограниченная диапазоном используемого машинного слова;</p></li>
<li><p>логическая константа принимающая значения true или false;</p></li>
<li><p>константы ошибок, задаваемые соответствующими идентификаторами, образующими перечислимый тип (следует отметить, что включаются только те константы ошибок, которые соответствуют семантике праязыка);</p></li>
<li><p>константы типов, существующих на уровне праязыка;</p></li>
<li><p>константы спецзнаков, часть из которых определяют операции праязыка, а часть не имеют конкретной семантики и предназначены для использования на уровне подъязыков с семантикой, определяемой разработчиками подъязыков;</p></li>
<li><p>константные списки, состоящие из атомарных констант праязыка и его допустимых операций для всех видов списков.</p></li>
</ul>
<p>При этом допускается описание константных выражений посредство <code class="docutils literal notranslate"><span class="pre">const</span></code> с применением констант всех типов, допустимых в праязыке.</p>
</div>
<div class="section" id="id10">
<h3><span class="section-number">13.4.2. </span>Описания типов<a class="headerlink" href="#id10" title="Ссылка на этот заголовок">¶</a></h3>
<p>Описания типов, задаваемые посредством <code class="docutils literal notranslate"><span class="pre">typedef</span></code>, должны быть реализованы в праязыке. Это касается как статических описаний, так и динамически проверяемых описаний (описаний, содержащих тело с набором операций). При этом в теле динамического описания типов допускается использовать только операторы и операции, определенные в праязыке. Предполагается, что определение в подъязыках дополнительных операций приведет, в свою очередь, к расширению возможностей как динамического описания типов, так и функций.</p>
</div>
<div class="section" id="id11">
<h3><span class="section-number">13.4.3. </span>Описания функций<a class="headerlink" href="#id11" title="Ссылка на этот заголовок">¶</a></h3>
<p>Описания функций, задаваемые посредством <code class="docutils literal notranslate"><span class="pre">funcdef</span></code>, также реализуются в праязыке. На тело функции накладывается ограничение, связанное с использованием только тех операторов и операций, которые реализованы в праязыке.</p>
</div>
<div class="section" id="id12">
<h3><span class="section-number">13.4.4. </span>Описания импорта<a class="headerlink" href="#id12" title="Ссылка на этот заголовок">¶</a></h3>
<p>Допускается описание импорта из других репозиториев посредством <code class="docutils literal notranslate"><span class="pre">import</span></code>.</p>
</div>
<div class="section" id="id13">
<h3><span class="section-number">13.4.5. </span>Операторы и операции в теле функции или динамического описания типа<a class="headerlink" href="#id13" title="Ссылка на этот заголовок">¶</a></h3>
<p>Тело функции или динамического описания типа содержит операторы и операции. Ряд этих конструкций определены в праязыке.</p>
<div class="section" id="id14">
<h4><span class="section-number">13.4.5.1. </span>Блок<a class="headerlink" href="#id14" title="Ссылка на этот заголовок">¶</a></h4>
<p>Допускается использование блока. Учитывая то, что язык является статически типизированным, необходимо указывать типы аргумента и результата блока точно также как и при описании функции.</p>
</div>
<div class="section" id="id15">
<h4><span class="section-number">13.4.5.2. </span>Выражение<a class="headerlink" href="#id15" title="Ссылка на этот заголовок">¶</a></h4>
<p>Выражение состоит из отдельных подвыражений (рекурсивно определяемых выражений), соединенных между собой операторами интерпретации. Определены и допустимы на уровне праязыка.</p>
</div>
<div class="section" id="id16">
<h4><span class="section-number">13.4.5.3. </span>Предопределенные функции и данные<a class="headerlink" href="#id16" title="Ссылка на этот заголовок">¶</a></h4>
<p><strong>Предопределенные функции и данные</strong> формируются на основе атомов, каждый из
которых может быть в роли как аргумента, так и функции оператора интерпретации. При этом ряд
атомарных объектов могут выступать только в роли данных, другие - в роли функций, третьи - в той и другой.</p>
<p>Большинство специальных знаков используются как предопределенные функции. Обычно за ними закрепляются вычислительные операции, традиционные для этих значков в большинстве существующих языков программирования. Задаются допустимые аргументы и значения этих функций. При этом тип операции не связан только со знаком. Он также зависит от типа аргумента. Поэтому нельзя, например, говорить о знаке «+» как об арифметической операции, так как при булевских аргументах он используется для обозначения дизъюнкции. Исходя из специфики праязыка, следует отметить, что ряд спецзнаков, а также предопределенных функций, задаваемых именам, в нем не определе. Это, в частности, касается знака «+», семантику которого определяет разработчик подъязыка.</p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p>Необходимо подумать над тем, включать ли в праязык операции над предопределенными в нем типами данных. С одной стороны это расширяет семантику праязыка, которая может на деле отличаться в подъязыках. С другой стороны праязык без этой семантики будет скуден. Хотя он и не задумывается как полноценный языка. Надо думать…</p>
</div>
<div class="section" id="id17">
<h5><span class="section-number">13.4.5.3.1. </span>Использование знака «.»<a class="headerlink" href="#id17" title="Ссылка на этот заголовок">¶</a></h5>
<p>Данный знак используется в праязыке по своему основному назначению, интерпретируясь как сигнальная величина. В качестве функции возвращает обобщенный аргумент поступивший на его вход. Аргумент может быть любого типа, что определяется его обозначением <code class="docutils literal notranslate"><span class="pre">any</span></code>. То есть, любой тип праязыка может быть при необходимости интерпретирован как <code class="docutils literal notranslate"><span class="pre">any</span></code>.</p>
<p>В качестве аргумента функции интерпретации сигнальная величина служит пустым аргументов функций, не содержащих аргумент, определяя их запуск по моменту поступления сигнала. Следовательно, значение «.» сразу же обеспечивает запуск любой функции.</p>
</div>
<div class="section" id="id18">
<h5><span class="section-number">13.4.5.3.2. </span>Использование знака «|»<a class="headerlink" href="#id18" title="Ссылка на этот заголовок">¶</a></h5>
<p>Знак <strong>«|»</strong> задает функцию нахождения списка данных и определен в праязыке.
Аргумент – список данных любой размерности и любого типа элементов (any). Результат – целое число, задающее количество
элементов в списке первого уровня вложенности.</p>
<p>На уровне описаний определяется следующим образом:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">anyDataList</span> <span class="o">&lt;&lt;</span> <span class="n">typedef</span> <span class="o">@</span><span class="p">(</span><span class="nd">@any</span><span class="o">...</span><span class="p">)</span>
<span class="n">spec</span><span class="o">|</span> <span class="o">&lt;&lt;</span> <span class="n">funcdef</span> <span class="nd">@anyDataList</span><span class="o">-&gt;</span><span class="nd">@int</span>
</pre></div>
</div>
<p>Предполагается, что в дальнейшем семантика данной операции может быть расширена на параллельные и задержанные списки за счет использования оператора двойной интерпретации:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">anyParList</span> <span class="o">&lt;&lt;</span> <span class="n">typedef</span> <span class="o">@</span><span class="p">[</span><span class="nd">@any</span><span class="o">..</span><span class="p">]</span>
<span class="n">anyDelayList</span> <span class="o">&lt;&lt;</span> <span class="n">typedef</span> <span class="o">@</span><span class="p">{</span><span class="nd">@any</span><span class="o">..</span><span class="p">}</span>
<span class="n">spec</span><span class="o">|</span> <span class="o">&lt;&lt;</span> <span class="p">::</span><span class="n">funcdef</span> <span class="nd">@anyParList</span><span class="o">-&gt;</span><span class="nd">@int</span>
<span class="n">spec</span><span class="o">|</span> <span class="o">&lt;&lt;</span> <span class="p">::</span><span class="n">funcdef</span> <span class="nd">@anyDelayList</span><span class="o">-&gt;</span><span class="nd">@int</span>
</pre></div>
</div>
</div>
<div class="section" id="id19">
<h5><span class="section-number">13.4.5.3.3. </span>Использование знака «?»<a class="headerlink" href="#id19" title="Ссылка на этот заголовок">¶</a></h5>
<p>Используется как функция, осуществляющая вычисление номеров позиций истинных булевских констант в булевском
списке данных. В качестве результата формируется параллельный целочисленный список с
номерами тех элементов списка аргументов, чьи значения были равны true. Аргумент является булевским списком  данных:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>boolDataList &lt;&lt; typedef @(@bool..)
intParList &lt;&lt; typedef @[@int..]
spec? &lt;&lt; funcdef @boolDataList-&gt;@intParList
</pre></div>
</div>
<p>Пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(true, false, true, false, false, true):? ⇒ [1, 3, 6]
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p>Следует обратить внимание на то, что в общем случае аргумент может быть списком, длина которого может определяться только во время выполнения. Однако во многих случаях длина списка можеть быть известна на этапе компиляции, что позволит оптимизировать его представление и обеспечить выделение памяти до момента выполнения программы. Аналогичным образом можно заранее выделить память и для результата, так как его максимальный размер не может превышать длину аргумента. В этом случае выделяемая структура должна иметь еще один параметр, задающий количество истинных значений в формируемом результате. Задача может решаться на этапе оптимизации промежуточного представления. Может быть вообще стоит ограничить язык заданием фиксированной размерности списков в базовых операторах и операциях, разрабатывая для динамических вариантов соответствующие функции. Это сделает язык более строго типизированным.</p>
</div>
<p>В принципе вполне возможно расширение семантики данной операции на двойную интерпретацию, когда в качестве аргумента выступает булевский параллельный список:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>boolParList &lt;&lt; typedef @[@bool..]
intParList &lt;&lt; typedef @[@int..]
spec? &lt;&lt; ::funcdef @boolParList-&gt;@intParList
</pre></div>
</div>
<p>Тогда появление значений в выходном списке результатов может происходить асинхронно.</p>
<p>Вряд ли стоит расширять данную операцию на задержанный список, так как значения его элементов могут оказаться не вычисленными. Предполагается что оператор двойной интерпретации манипулирует только параметрами типа артефакта и не раскрывает задержанные списки.</p>
</div>
<div class="section" id="id20">
<h5><span class="section-number">13.4.5.3.4. </span>Использование знака «#»<a class="headerlink" href="#id20" title="Ссылка на этот заголовок">¶</a></h5>
<p>Знак <strong>«#»</strong> используется для задания функции транспонирования элементов списка подсписков. Транспонирование может происходить для любых списков вложенностью не менее 2. В общем случае тип аргумента и тип результата совпадают по размерности. Изменяется только значение:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">doubleDataList</span> <span class="o">&lt;&lt;</span> <span class="n">typedef</span> <span class="o">@</span><span class="p">(</span><span class="nd">@anyDataList</span><span class="o">..</span><span class="p">))</span>
<span class="n">spec</span><span class="c1"># &lt;&lt; @doubleDataList-&gt;@doubleDataList</span>
</pre></div>
</div>
</div>
<div class="section" id="id21">
<h5><span class="section-number">13.4.5.3.5. </span>Использование знака «()»<a class="headerlink" href="#id21" title="Ссылка на этот заголовок">¶</a></h5>
<p>Задает охват аргумента круглыми скобками. То есть, формирует из атома одноэлементный список данных. Для списков данных, асинхронных списков формируется список данных с увеличенным на единицу уровнем вложенности.</p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p>Нужно добавить описание типов и прототип функции.</p>
</div>
</div>
</div>
<div class="section" id="id22">
<h4><span class="section-number">13.4.5.4. </span>Не используются в праязыке<a class="headerlink" href="#id22" title="Ссылка на этот заголовок">¶</a></h4>
<p>Ниже представлены спецзнаки и идентифиакторы, зарезервированные, но не используемые в праязыке, которые разработчики подъязыков могут использовать в своих целях:</p>
<ul class="simple">
<li><p>знак «+»;</p></li>
<li><p>знак «-«;</p></li>
<li><p>знак «/»;</p></li>
<li><p>знак «%»;</p></li>
<li><p>знаки «=», «!=», «&lt;», «&lt;=», «&gt;», «&gt;=»;</p></li>
<li><p>…</p></li>
</ul>
</div>
</div>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Оглавление</a></h3>
  <ul>
<li><a class="reference internal" href="#">13. Об ядре языка как о праязыке</a><ul>
<li><a class="reference internal" href="#id2">13.1. Введение</a></li>
<li><a class="reference internal" href="#id3">13.2. Определения</a></li>
<li><a class="reference internal" href="#id4">13.3. Состав праязыка</a><ul>
<li><a class="reference internal" href="#id5">13.3.1. Элементарные конструкции</a></li>
<li><a class="reference internal" href="#id6">13.3.2. Обозначения</a></li>
<li><a class="reference internal" href="#id7">13.3.3. Предопределенные типы данных</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id8">13.4. Значащие величины (константы)</a><ul>
<li><a class="reference internal" href="#id9">13.4.1. Значащие величины (константы)</a></li>
<li><a class="reference internal" href="#id10">13.4.2. Описания типов</a></li>
<li><a class="reference internal" href="#id11">13.4.3. Описания функций</a></li>
<li><a class="reference internal" href="#id12">13.4.4. Описания импорта</a></li>
<li><a class="reference internal" href="#id13">13.4.5. Операторы и операции в теле функции или динамического описания типа</a><ul>
<li><a class="reference internal" href="#id14">13.4.5.1. Блок</a></li>
<li><a class="reference internal" href="#id15">13.4.5.2. Выражение</a></li>
<li><a class="reference internal" href="#id16">13.4.5.3. Предопределенные функции и данные</a><ul>
<li><a class="reference internal" href="#id17">13.4.5.3.1. Использование знака «.»</a></li>
<li><a class="reference internal" href="#id18">13.4.5.3.2. Использование знака «|»</a></li>
<li><a class="reference internal" href="#id19">13.4.5.3.3. Использование знака «?»</a></li>
<li><a class="reference internal" href="#id20">13.4.5.3.4. Использование знака «#»</a></li>
<li><a class="reference internal" href="#id21">13.4.5.3.5. Использование знака «()»</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id22">13.4.5.4. Не используются в праязыке</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Предыдущий раздел</h4>
  <p class="topless"><a href="SmileTranslator.html"
                        title="предыдущая глава"><span class="section-number">12. </span>Транслятор языка программирования Smile</a></p>
  <h4>Следующий раздел</h4>
  <p class="topless"><a href="More.html"
                        title="следующая глава"><span class="section-number">14. </span>Что еще стоит не забыть</a></p>
  <div role="note" aria-label="source link">
    <h3>Эта страница</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/Pralanguage.rst.txt"
            rel="nofollow">Исходный текст</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Быстрый поиск</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Искать" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Навигация</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Алфавитный указатель"
             >указатель</a></li>
        <li class="right" >
          <a href="More.html" title="14. Что еще стоит не забыть"
             >вперёд</a> |</li>
        <li class="right" >
          <a href="SmileTranslator.html" title="12. Транслятор языка программирования Smile"
             >назад</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">документация smile </a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">13. </span>Об ядре языка как о праязыке</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Alexander Legalov.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.5.2.
    </div>
  </body>
</html>
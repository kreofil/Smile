
<!DOCTYPE html>

<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta content="Описание концепций, языковых и инструментальных средств функционально-потокового параллельного программирования." name="description" />
<meta content="парадигмы программирования, функционально-потоковое параллельное программирование" name="keywords" />

    <title>3. Язык программирования Smile. Предварительное описание &#8212; документация smile </title>
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/translations.js"></script>
    <link rel="shortcut icon" href="_static/smile48.png"/>
    <link rel="index" title="Алфавитный указатель" href="genindex.html" />
    <link rel="search" title="Поиск" href="search.html" />
    <link rel="next" title="4. Семантика оператора интерпретации" href="InterpSemantic.html" />
    <link rel="prev" title="2. Статически типизированная модель модель функционально-потоковых параллельных вычислений" href="ModelReference.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Навигация</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Алфавитный указатель"
             accesskey="I">указатель</a></li>
        <li class="right" >
          <a href="InterpSemantic.html" title="4. Семантика оператора интерпретации"
             accesskey="N">вперёд</a> |</li>
        <li class="right" >
          <a href="ModelReference.html" title="2. Статически типизированная модель модель функционально-потоковых параллельных вычислений"
             accesskey="P">назад</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">документация smile </a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">3. </span>Язык программирования Smile. Предварительное описание</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="smile">
<h1><span class="section-number">3. </span>Язык программирования Smile. Предварительное описание<a class="headerlink" href="#smile" title="Ссылка на этот заголовок">¶</a></h1>
<div class="section" id="id1">
<h2><span class="section-number">3.1. </span>Общие соображения<a class="headerlink" href="#id1" title="Ссылка на этот заголовок">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>В рамках этого предварительного описания я хочу сформулировать свое видение языка функционально-потокового параллельного программирования Smile и инструментальных средств обеспечивающих его поддержку.</em></p>
<p><em>Проектируемый язык, как и язык программирования Пифагор, базируется на функционально-потоковой модели параллельных вычислений. Также от Пифагора заимствуются особенности синтаксиса. Однако смена названия говорит о том, что в данном случае не планируется обеспечить обратную совместимость. Предполагается активно использовать статическую типизацию. Но при этом оставить (возможно) динамическую типизацию определяемую пользователем. Скорее всего, динамическую типизацию, определяемую пользователем, реализованную в Пифагоре, будет сделана попытка заменить на ограниченную статическую типизацию, когда наряду с типом накладываются алгоритмические ограничения и проверки на значения, принимаемые данным типом (динамически ограниченный статический тип?).</em></p>
<p><em>Формируемый документ предназначен для всестороннего охвата как изменений, вносимых в первоначальную концепции языка функционально-потокового параллельного (ФПП) программирования, так и для объяснения причин, порождающих эти изменения. Поэтому  данный текст, наряду с конкретным описанием языка содержит множество дополнительных примечаний, поясняющих особенности как синтаксиса, так и семантики.</em></p>
<p><em>Эти пояснения предполагается вносить как по ходу формирования текста документа, так и в ходе разработки компилятора языка ФПП программирования Smile.</em></p>
</div>
</div>
<div class="section" id="id2">
<h2><span class="section-number">3.2. </span>Введение<a class="headerlink" href="#id2" title="Ссылка на этот заголовок">¶</a></h2>
<p>Статичестки типизированный язык функционально-потокового программирования Smile разрабатывается с учетом опыта, полученного при создания языка программирования Пифагор. Основным его отличием является использование статической системы типов, обеспечивающей более безопасное выполнение основных операций. Помимо этого предполагается, что должно улучшиться распределение памяти под данные, а также генерация кода в другие языки со статической типизацией, ориентированные на описание параллельных вычислений с использованием императивного или функционального программирования.</p>
<p>Опираясь на СТМФППВ разрабатываемый язык программирования включает дополнительные конструкции, расширяя функциональные возможности, описываемые моделью. Это обуславливается тем, что, в отличие от модели, язык программирования должен обеспечивать поддержку удобного и эффективного написания программ.</p>
</div>
<div class="section" id="id3">
<h2><span class="section-number">3.3. </span>Используемый метаязык<a class="headerlink" href="#id3" title="Ссылка на этот заголовок">¶</a></h2>
<p>Для описания синтаксиса используются расширенные формы Бэкуса-Наура (<strong>РБНФ</strong>).
Квадратные скобки <strong>«[«</strong> и <strong>«]»</strong> означают, что заключенная в них сентенциальная форма может отсутствовать, фигурные скобки <strong>«{«</strong> и <strong>«}»</strong> означают ее повторение (возможно, 0 раз), а круглые скобки <strong>«(«</strong> и <strong>«)»</strong> используются для ограничения альтернативных конструкций. Сочетание фигурных скобок и косой черты <strong>«{/»</strong> и <strong>«/}»</strong> используется для обозначения повторения один и более раз. Нетерминальные символы изображаются словами, выражающими их интуитивный смысл, написанными на русском языке и разделенными, при необходимости, знаком подчеркивания <strong>«_»</strong>. Каждое правило оканчивается точкой <strong>«.»</strong>. Терминальные символы изображаются словами, написанными строчными буквами латинского алфавита (зарезервированные слова) или цепочками знаков, заключенными в кавычки. Левая часть правила отделяется от правой знаком <strong>«=»</strong>.</p>
</div>
<div class="section" id="id4">
<h2><span class="section-number">3.4. </span>Элементарные конструкции<a class="headerlink" href="#id4" title="Ссылка на этот заголовок">¶</a></h2>
<p>Элементарные конструкции являются составнвми частями различных составных конструкций языка, образующих на верхнем уровне артефакты. К артефактам относятся сформированные программные объекты, обладающие определенной семантикой и используемые для описания как различных данных, так и функций.</p>
<div class="section" id="id5">
<h3><span class="section-number">3.4.1. </span>Разделители<a class="headerlink" href="#id5" title="Ссылка на этот заголовок">¶</a></h3>
<p>Пробелы, символы табуляции, перевода на новую строку и перевода страницы
используются как разделители. Вместо одного из таких символов может использоваться
любое их количество. Все другие управляющие символы употреблять в тексте программы
запрещено.</p>
</div>
<div class="section" id="id6">
<h3><span class="section-number">3.4.2. </span>Комментарии<a class="headerlink" href="#id6" title="Ссылка на этот заголовок">¶</a></h3>
<p>Многострочные комментарии начинаются парой символов «/<em>» и заканчиваются
парой символов «</em>/». Разрешены везде, где возможны разделители. Вложенность многострочных комментариев не допускается.</p>
<p>Примеры:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">Многострочный</span> <span class="n">комментарий</span> <span class="n">в</span> <span class="n">одной</span> <span class="n">строке</span> <span class="o">*/</span>
<span class="o">/*</span>
 <span class="o">*</span> <span class="n">Многострочный</span> <span class="n">комментарий</span><span class="p">,</span>
 <span class="o">*</span> <span class="n">размещенный</span> <span class="n">в</span> <span class="n">нескольких</span> <span class="n">строках</span>
 <span class="o">*/</span>
</pre></div>
</div>
<p>В языке также допускаются однострочные комментарии. Они начинаются парой
символов <strong>«//»</strong> и заканчиваются признаком конца строки. Однострочные комментарии могут начинаться с самого начала строки или стоять после операторов, написанных в этой строке.</p>
<p>Пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Однострочный</span> <span class="n">комментарий</span>
</pre></div>
</div>
<p><strong>комментарий = «/*» {знак} «*/» | «//» {знак}.</strong></p>
</div>
<div class="section" id="id7">
<h3><span class="section-number">3.4.3. </span>Идентификаторы<a class="headerlink" href="#id7" title="Ссылка на этот заголовок">¶</a></h3>
<p>Идентификаторы используются для обозначения имен констант, переменных,
функций и типов данных. Допустимые символы: цифры <strong>0-9</strong>, прописные и строчные буквы
латинского алфавита <strong>A-Z</strong>, <strong>a-z</strong>, символ подчеркивания <strong>«_»</strong>. Первый символ не является
цифрой. Идентификатор может быть произвольной длины. Прописные и строчные буквы
различаются.</p>
<p><strong>ид := (буква | «_»){буква|цифра|»_»}.</strong></p>
<p>Примеры:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">NAME1</span>
<span class="n">name1</span>
<span class="n">it_is_ID</span>
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h3><span class="section-number">3.4.4. </span>Зарезервированные слова<a class="headerlink" href="#id8" title="Ссылка на этот заголовок">¶</a></h3>
<p>Зарезервированные слова используются для ключевых слов встроенных типов данных,
предопределенных обозначений и функций. Ниже приведен общий их список:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">block</span>       <span class="k">break</span>       <span class="nb">bool</span>        <span class="n">char</span>        <span class="n">const</span>
<span class="n">group</span>       <span class="n">dup</span>         <span class="n">delay</span>       <span class="k">else</span>        <span class="n">error</span>
<span class="n">false</span>       <span class="nb">float</span>       <span class="n">func</span>        <span class="n">funcdef</span>     <span class="nb">int</span>
<span class="n">nil</span>         <span class="k">return</span>      <span class="n">signal</span>      <span class="n">transform</span>   <span class="n">true</span>
<span class="nb">type</span>
</pre></div>
</div>
<p>Зарезервированные слова записываются строчными буквами.
Использовать их в качестве идентификаторов запрещено.</p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>В данной ситуации также стоит отметить, что типы данных должны быть вынесены в отдельную категорию предопределенных артефактов. Это  означает, что они не будут определяться через ключевые слова. То есть предополагается формирование данных артефактов в соответствующем пространстве имен, запрещающих их повторное использовани в другом контексте. Но это будет описано позднее, когда устаканится их резервирование в данной роли.</em></p>
</div>
</div>
<div class="section" id="id9">
<h3><span class="section-number">3.4.5. </span>Специальные знаки<a class="headerlink" href="#id9" title="Ссылка на этот заголовок">¶</a></h3>
<p><strong>Специальные знаки</strong> используются для обозначения различных понятий. Они могут являться разделителям, элементами программоформирующих операторов, обозначением констант данных и предопределенных функций. Их смысл будет раскрыт при описании языка, а также структуры и семантики программоформирующих операторов.</p>
<p><strong>спецзнак =</strong></p>
<blockquote>
<div><p><strong>«+» | «-» | «/» | «*» | «%» | «/%» | «&lt;» | «&gt;» | «=» | «&gt;=» | «&lt;=» | «!=» |</strong></p>
<p><strong>«=&gt;» | «-&gt;» | «&lt;-» | «()» | «{}» | «[]» | «|» | «#» | «%» | «..» |</strong>
<strong>«?» | «??» | «!».</strong></p>
</div></blockquote>
<p>Следует отметить, что ряд специальных знаков в настоящее время не используется и
зарезервирован для дальнейшего расширения языка.</p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>Перечисленный набор спецзнаков в дальнейшем может корректироваться. Также будет уточняться и их принадлежность к конкретному типу, что пока не описано. В целом предполагается, что большинство спецзнаков в контексте вычисления будут отображаться в функции. Вместе с тем, дуализм аргументов операции интерпретации может привести к тому, что ряд знаков будет интерпретироваться различным способом в зависимости от того, являются они данными или функциями в операторе интрепретации.</em></p>
<p><em>Помимо этого, так как вводится две разновидности оператора интерпретации, для различных типов возможна разная трактовка в зависимости от этого</em></p>
</div>
</div>
</div>
<div class="section" id="id10">
<h2><span class="section-number">3.5. </span>Обозначения<a class="headerlink" href="#id10" title="Ссылка на этот заголовок">¶</a></h2>
<p>В языке, построенном на основе принципа единственного использования вычислительных ресурсов в сочетании с принципом единственного присваивания, отсутствует понятие переменной. Вместо него вводится понятие обозначения как идентификатора, поставленного в соответствие с каким-либо программным фрагментом. В пределах некоторой области видимости использование идентификатора в качестве обозначения должно быть уникальным. Обозначение получает тип и величину (значение) сопоставленного элемента и может использоваться для дальнейшей передачи этих параметров в любую точку программы, обеспечивая тем самым копирование артефакта, полученного в ходе вычислений. В языке определены два способа задания обозначений:</p>
<ul class="simple">
<li><p>префиксное, при котором знак идентификатор пишется слева от знака «&lt;&lt;», а определяемый артефакт справа;</p></li>
<li><p>постфиксное, когда слева от знака «&gt;&gt;» задается определяемый артефакт, а справа его идентификатор.</p></li>
</ul>
<dl class="simple">
<dt><strong>обозначение =</strong></dt><dd><dl class="simple">
<dt><strong>идентификатор «&lt;&lt;» элемент |</strong></dt><dd><p><strong>элемент «&gt;&gt;» идентификатор.</strong></p>
</dd>
</dl>
</dd>
</dl>
<p>Под элементом понимается любой из артефактов языка. Идентификатор элемента. Понятия
артефакта, выражения и блока будут даны ниже.</p>
<dl class="simple">
<dt><strong>элемент =</strong></dt><dd><dl class="simple">
<dt><strong>артефакт | выражение | блок |</strong></dt><dd><p><strong>обозначение | идентификатор.</strong></p>
</dd>
</dl>
</dd>
</dl>
<p>Примеры:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">&lt;&lt;</span> <span class="mi">100</span><span class="p">;</span>
<span class="n">Pi</span> <span class="o">&lt;&lt;</span> <span class="mf">3.1415</span><span class="p">;</span>
<span class="mi">10</span> <span class="o">&gt;&gt;</span> <span class="n">ten</span><span class="p">;</span>
<span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span><span class="o">+</span> <span class="o">&gt;&gt;</span> <span class="nb">sum</span><span class="p">;</span>
<span class="n">x0</span> <span class="o">&lt;&lt;</span> <span class="n">y0</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>Следует отметить, что в данном языке все-таки появится присваивание, которое будет функционировать по принципу единственного присваивания. Это обусловлено тем, что при введении статической типизации появляются контейнерные артефакты заданной размерности, в которые можно вводить данные, руководствуясь этими размерами. Также возможно появление аналогов структур (записей), имеющих поля с локальным именованием. В этих случаях тоже удобнее заносить данные внутрь этих конструкций путем единственного присваивания. Это же касается обобщений. Но обозначение все равно остается и будет для таких артефактов использоваться как начальное объявление.</em></p>
</div>
</div>
<div class="section" id="id11">
<h2><span class="section-number">3.6. </span>Артефакты<a class="headerlink" href="#id11" title="Ссылка на этот заголовок">¶</a></h2>
<p>К артефактам языка относятся программные объекты, определяемые в языке и несущие заданную семантическую нагрузку. Каждый артефакт характеризуется двойкой:</p>
<p><strong>&lt;тип, значение&gt;.</strong></p>
<p>В языке используется статическая типизация артефактов, что позволяет сформировать и идентифицировать тип любого из них во время компиляции. Значение определяет величину из множества допустимых значений, допустимых для данного типа.</p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>Наличие строгой статической типизации в целом не отменяет изменчивость типов. Любая маломальская программа требует в той или иной форме поддержки динамической типизации данных. Ее поздняя реализация в языке планируется через процедурно-параметрический полиморфизм. В первоначальной версии предполагается использование объединений в стиле языка программирования Ada.</em></p>
</div>
<p>Артефакты могут формироваться как до выполнения программы, так и во время ее выполнения. Артефакт, сформированный до вычислений, является константой заранее предопределенного типа. Существуют различные по структуре категории артефактов, которые можно описать следующим правилом:</p>
<p><strong>артефакт_по_структуре = атом | составной | функция.</strong></p>
<div class="section" id="id12">
<h3><span class="section-number">3.6.1. </span>Типы артефактов<a class="headerlink" href="#id12" title="Ссылка на этот заголовок">¶</a></h3>
<p>Можно выделить неупорядоченное множество предопределенных типов, задаваемых соответствующими именами. Типы делятся на атомарные и составные. Атомарные типы и области их допустимых значений определяются аксиоматически. Составные типы являются комбинацией атомарных и уже существующих составных артефактов. Они конструируются по заданным правилам.</p>
<p>Следует отметить определенную специфику языка, вытекающую из особенностей модели вычислений. Она заключается в том, что многие артефакты могут использоваться в качестве как данных, так и функций оператора интерпретации. Это проявляется в дуализме артефактов, что ведет к двойственной трактовке типов в зависимости от интерпретации. Поэтому артефакт по типу можно охарактеризовать следующим правилом:</p>
<blockquote>
<div><p><strong>артефакт_по_типу = данные | функция | дуальный.</strong></p>
</div></blockquote>
<p>Учитывая тип артефакта в зависимости от применения, его можно охарактеризовать следующей конструкцией:</p>
<p><strong>&lt;тип-данные : тип-функции, значение&gt;.</strong></p>
<p>Также следует отметить, что имеющаяся возможность перегрузки имени функции за счет использования идентификации по сигнатуре позволяет связывать с одним артефактов несколько функциональных типов.</p>
<table class="docutils align-default" id="id51">
<caption><span class="caption-text"><strong>Предопределенные артефакты</strong></span><a class="headerlink" href="#id51" title="Постоянная ссылка на таблицу">¶</a></caption>
<colgroup>
<col style="width: 33%" />
<col style="width: 24%" />
<col style="width: 17%" />
<col style="width: 26%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Название артефакта</p></th>
<th class="head"><p>Обозначение типа</p></th>
<th class="head"><p>Организация</p></th>
<th class="head"><p>Значение</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>сигнал</strong></p></td>
<td><p>signal:func</p></td>
<td><p>атом</p></td>
<td><p>!</p></td>
</tr>
<tr class="row-odd"><td><p><strong>логический</strong></p></td>
<td><p>bool:func</p></td>
<td><p>атом</p></td>
<td><p>false или true</p></td>
</tr>
<tr class="row-even"><td><p><strong>целый</strong></p></td>
<td><p>int:func</p></td>
<td><p>атом</p></td>
<td><p>MinInt..MaxInt</p></td>
</tr>
<tr class="row-odd"><td><p><strong>вектор</strong></p></td>
<td><p>vector:func</p></td>
<td><p>составной</p></td>
<td><p>Type(size)</p></td>
</tr>
<tr class="row-even"><td><p><strong>кортеж</strong></p></td>
<td><p>tuple:func</p></td>
<td><p>составной</p></td>
<td><p>(Type, …)</p></td>
</tr>
<tr class="row-odd"><td><p><strong>структура</strong></p></td>
<td><p>struct:none</p></td>
<td><p>составной</p></td>
<td><p>(<a class="reference external" href="mailto:Name&#37;&#52;&#48;Type">Name<span>&#64;</span>Type</a>, …)</p></td>
</tr>
<tr class="row-even"><td><p><strong>обобщение</strong></p></td>
<td><p>union:none</p></td>
<td><p>составной</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>рой</strong></p></td>
<td><p>swarm:func</p></td>
<td><p>составной</p></td>
<td><p>Type[size]</p></td>
</tr>
<tr class="row-even"><td><p><strong>задержка</strong></p></td>
<td><p>delay:delay</p></td>
<td><p>составной</p></td>
<td><p>{e&#64;T} =&gt; v&#64;T</p></td>
</tr>
<tr class="row-odd"><td><p><strong>функция</strong></p></td>
<td><p>none:func</p></td>
<td><p>составной</p></td>
<td><p>&#64;T1 -&gt; &#64;T2</p></td>
</tr>
<tr class="row-even"><td><p><strong>ошибка</strong></p></td>
<td><p>error:none</p></td>
<td><p>атом</p></td>
<td><p>enum of errors</p></td>
</tr>
<tr class="row-odd"><td><p><strong>поток</strong></p></td>
<td><p>stream:func</p></td>
<td><p>составной</p></td>
<td><p>Type{}</p></td>
</tr>
<tr class="row-even"><td><p><strong>типовой</strong></p></td>
<td><p>type:func</p></td>
<td><p>перечислимый</p></td>
<td><p>Имя типа</p></td>
</tr>
<tr class="row-odd"><td><p><em>действительный</em></p></td>
<td><p>float:none</p></td>
<td><p>атом</p></td>
<td><p>MinFloat..MaxFloat</p></td>
</tr>
<tr class="row-even"><td><p><em>символьный</em></p></td>
<td><p>char:none</p></td>
<td><p>атом</p></td>
<td><p>символ UTF-8</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>В текущей версии действительный и символьный тип реализовывать не планируется. Это связано с тем, что первоначально предполагается отработать ключевые конструкции языка, после чего можно переходить к его дальнейшему расширению.</em></p>
</div>
</div>
</div>
<div class="section" id="id13">
<h2><span class="section-number">3.7. </span>Константы<a class="headerlink" href="#id13" title="Ссылка на этот заголовок">¶</a></h2>
<p>Константы относятся к неделимым атомарным величинам, принимающим конкретные значения, соответствующего предопределенному для них типу данных. Значение константы принадлежит области ее допустимых значений, задаваемой в зависимости от типа одним из следующих способов: диапазоном, диапазоном и точностью, перечислением элементов упорядоченного множества, перечислением элементов неупорядоченного множества (если нет необходимости устанавливать между элементами отношение порядка), функцией. Каждая константа - это одно значение из диапазона, определяемого областью допустимых значений. В языке реализованы следующие виды констант:</p>
<blockquote>
<div><ul class="simple">
<li><p>сигнальная константа;</p></li>
<li><p>целочисленные константы</p></li>
<li><p>булевские константы;</p></li>
<li><p>константы ошибок;</p></li>
<li><p>специальные константы.</p></li>
</ul>
</div></blockquote>
<p>Тип константы в программе определяется ее внешним видом, задаваемым синтаксическими правилами:</p>
<p><strong>константа = сигнальная | целая | логическая.</strong></p>
<p>Семантика констант, связана с семантикой их величин, ролью в операторе интерпретации и приводится в описании оператора интерпретации.</p>
<div class="section" id="id14">
<h3><span class="section-number">3.7.1. </span>Сигнальная константа<a class="headerlink" href="#id14" title="Ссылка на этот заголовок">¶</a></h3>
<p><strong>Сигнальная константа</strong> или просто <strong>сигнал</strong> имеет предопределенный тип <strong>signal</strong> и может принимать только одно значение <strong>!</strong>, указывающее на произошедшее событие, не связанное с другими типами данных. Кроме фиксации факта возникновения некоторого события сигнал больше не содержит никакой дополнительной информации.</p>
</div>
<div class="section" id="id15">
<h3><span class="section-number">3.7.2. </span>Целая константа<a class="headerlink" href="#id15" title="Ссылка на этот заголовок">¶</a></h3>
<p><strong>Целая константа</strong> имеет предопределенный тип данных <strong>int</strong> и используется для представления данных в формате стандартного машинного слова, длина которого зависит от архитектуры ВС.</p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>В текущей версии языка реализовано представление целых чисел только в десятичной системе счисления. Это достаточно для проведения первоначальных экспериментов.</em></p>
</div>
<p><strong>целая = [ «+» | «-» ] {/цифра/}.</strong></p>
<p><strong>цифра = «0» | «1» | «2» | «3» | «4» | «5» | «6» | «7» | «8» | «9».</strong></p>
<p>Примеры:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">127</span>
<span class="mi">0127</span>
<span class="o">-</span><span class="mi">356</span>
<span class="o">+</span><span class="mi">10</span>
</pre></div>
</div>
<p>Предполагается, что в соответствии с внутренним машинным представлением целочисленные константы располагаются в диапазоне <strong>{MinInt, …, MaxInt}</strong>.</p>
<p>Например для 64-разрядной архитектуры в дополнительном коде это будет диапазон
от -2<sup>64</sup> до 2<sup>64</sup> - 1.</p>
</div>
<div class="section" id="id16">
<h3><span class="section-number">3.7.3. </span>Логическая константа<a class="headerlink" href="#id16" title="Ссылка на этот заголовок">¶</a></h3>
<p><strong>Логическая константа</strong> имеет предопределенный тип <strong>bool</strong> и может принимать значения «<strong>true</strong>» («истина») или  «<strong>false</strong>» («ложь»). Она задается соответствующими ключевыми словами.</p>
<p><strong>логическая = true | false.</strong></p>
<p>Для логических констант сохраняется отношение порядка:</p>
<p><strong>false &lt; true.</strong></p>
<p>Логическая константа имеет предопределенный тип данных <strong>bool</strong></p>
</div>
<div class="section" id="id17">
<h3><span class="section-number">3.7.4. </span>Константы ошибок<a class="headerlink" href="#id17" title="Ссылка на этот заголовок">¶</a></h3>
<p><strong>Константы ошибок</strong> имеют тип <strong>error</strong> ииспользуются для отображения некорректных ситуаций, возникающих в ходе вычислений. Величины этого типа могут обрабатываться наряду с другими данными или как исключительные ситуации.</p>
<p>Область допустимых значений для констант ошибки задается неупорядоченным множеством, которое в дальнейшем предполагается пополнять. В настоящий момент выделяются следующие ошибки:</p>
<ul class="simple">
<li><p><strong>ERROR</strong> - неидентифицируемая ошибка;</p></li>
<li><p><strong>REALERROR</strong> - некорректное преобразование действительного числа;</p></li>
<li><p><strong>INTERROR</strong> - некорректное преобразование целого числа;</p></li>
<li><p><strong>ZERODIVIDE</strong> - деление на ноль;</p></li>
<li><p><strong>INTERPRERROR</strong> - ошибка операции интерпретации;</p></li>
<li><p><strong>BOUNDERROR</strong> - ошибка выхода за границы диапазона;</p></li>
<li><p><strong>BASEFUNCERROR</strong> – неправильное использование предопределенной функции.</p></li>
<li><p><strong>NOERROR</strong> - отсутствие ошибки</p></li>
</ul>
<p>Эти имена запрещается использовать в программе в другом контексте.</p>
<dl class="simple">
<dt><strong>константа_ошибки = ERROR | REALERROR | INTERROR | ZERODIVIDE |</strong></dt><dd><p><strong>| INTERPRERROR | BOUNDERROR | BASEFUNCERROR | NOERROR.</strong></p>
</dd>
</dl>
<p>Значени <strong>NOERROR</strong> формируется в том случае, если при получении  результата вычислений необходимо вместо конкретного значения ошибки вернуть информацию о том, что ошибка отсутствует.</p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>Предполагается, что по сравнению с Пифагором использование ошибок будет значительно переработано в сторону упрощения. Планируется, что каждая из констант ошибки будет являться отдельной функцией - обработчиком ошибки, предоставляющей информацию о типе ошибке и обеспечивающей обращение к системе для корректного завершения программы. На данном этапе не планируется введение системы обработки исключений. Хотя в дальнейшем такое развитие просматривается.</em></p>
<p><em>Возможно, что реализация обработки ошибок будет сделана по аналогии с тем, как это реализовано в языке программирования GO. То есть, вместо выбрасывания исключений, будет формироваться значение, возвращаемое в качестве одного из результатов.</em></p>
</div>
</div>
<div class="section" id="id18">
<h3><span class="section-number">3.7.5. </span>Описание именованных констант<a class="headerlink" href="#id18" title="Ссылка на этот заголовок">¶</a></h3>
<p>Для любой из представленных выше констант можно ввести обозначение в виде имени. Это позволяет в разных местах программы ссылаться на одну и ту же константу. Описание именованных констант задается следующим синтаксическим правилом:</p>
<p><strong>описание_константы = имя_константы «&lt;&lt;» [«const»] константа |</strong></p>
<blockquote>
<div><p><strong>[«const»] константа «&gt;&gt;» имя_константы.</strong></p>
</div></blockquote>
<p>Ключевое слово <code class="docutils literal notranslate"><span class="pre">const</span></code> не является обязательным, так как и без его использование описание задается однозначно.</p>
<p>Примеры:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ten</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span>
<span class="n">const</span> <span class="mi">5</span> <span class="o">&gt;&gt;</span> <span class="n">five</span>
<span class="n">one</span> <span class="o">&lt;&lt;</span> <span class="n">const</span> <span class="mi">1</span>
<span class="mf">3.141592</span> <span class="o">&gt;&gt;</span> <span class="n">pi</span>
<span class="n">ok</span> <span class="o">&lt;&lt;</span> <span class="n">true</span>
<span class="n">fail</span> <span class="o">&gt;&gt;</span> <span class="n">false</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id19">
<h2><span class="section-number">3.8. </span>Описания типов<a class="headerlink" href="#id19" title="Ссылка на этот заголовок">¶</a></h2>
<p>Язык ориентирован на использование статической системы типов. Предполагается что каждый объявляемый тип должен иметь имя. Существуют предопределенные (базовые) типы и сконструированные типы (типы, определяемые пользователями). Среди предопределенных можно выделить атомарные и составные типы.</p>
<p>Описания позволяют создавать новые именованные типы, определяя их через предопределенные типы или используя уже сконструированные типы. Имя вновь создаваемого типа задается идентификатором, который используется в качестве обозначения. Далее следует само описание, которое начинается с ключевого слова <strong>type</strong> или специального обозначения типа <strong>&#64;</strong>.</p>
<p><strong>ОписаниеТипа = ИмяНовогоТипа «&lt;&lt;» («&#64;» | «type») Тип |</strong></p>
<blockquote>
<div><p><strong>(«&#64;» | «type») Тип «&gt;&gt;» ИмяНовогоТипа.</strong></p>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>Двоякое толкование начала описания в данный момент вызвано неопределенностью ответа на вопрос: какое обозначение лучше? С одной стороны собака «&#64;» везде трактуется как обозначение типа. И запись при этом получается компактной. С другой стороны в языках принято ставить ключевое слово type. Решил использовать оба, пока не принято окончательное решение</em></p>
</div>
<div class="section" id="id20">
<h3><span class="section-number">3.8.1. </span>Переименование типа<a class="headerlink" href="#id20" title="Ссылка на этот заголовок">¶</a></h3>
<p>Основная идея использования переименования типов заключается в создании новых типов на основе уже существующих. При этом новые типы напрямую не наследуют свойства уже созданных типов. В отличие от алиасов (псевдонимов, определяющих дополнительные имена для того же типа) все функции исходного типа над вновь созданным напрямую недоступны. Использовать функции, родительского типа их можно только после явного приведения созданного типа к типу предшественника. Например, допускается использование предопределенных атомарных типов, имеющих имя, для построения новых типов. Например:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">apple</span> <span class="o">&lt;&lt;</span> <span class="o">@</span> <span class="nb">int</span>
</pre></div>
</div>
<p>Ключевым здесь является следующий принцип: если хочется использовать новый именованный тип, то для обработки его нужно сформировать свой набор функций, а не использовать неявно функции родительского типа. Тогда незачем формировать новый тип. Использование общих функций для нескольких типов можно реализовать, используя обобщения.</p>
</div>
<div class="section" id="id21">
<h3><span class="section-number">3.8.2. </span>Конструирование типа<a class="headerlink" href="#id21" title="Ссылка на этот заголовок">¶</a></h3>
<p>Создание новых типов на основе составных предопределенных типов обеспечивает формирование именованных абстрактных типов данных с требуемыми полями и свойствами. Эти типы могут создаваться на основе любых составных типов и использоваться в различных манипуляциях, допускаемых над величинами, имеющими типовой тип (тип типа).</p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>В данной версии языка предполагается, что будет использоваться только (или в основном) именованая эквивалентность типов. То есть, два типа будут считаться эквивалентными, если они имеют одинаковые имена. Это, на мой взгляд, обеспечит более строгий контроль типов и позволит проводить формальную верификацию программ в более широком диапазоне. Поэтому, в большинстве случаев перед сравнением типов необходимо будет осуществлять явное преобразование к нужному типу, если такое возможно в соответствии с используемым механизмом преобразования (приведения) типов. Но без структурной эквивалентности в ряде случаев просто не обойтись. Поэтому данный вопрос требует детальной проработки…</em></p>
<p><em>Структурная эквивалентность будет использоваться при сопоставлении предопределенных составных типов. В этом случае возможна проверка на идентичность имен предопределенных типов, после чего следует проверка идентичности внутренней структуры. Но при этом предполагается, если возможно, явное приведение сопоставляемых типов к единому предопределенномму составному типу.</em></p>
</div>
</div>
<div class="section" id="id22">
<h3><span class="section-number">3.8.3. </span>Предопределенные атомарные типы<a class="headerlink" href="#id22" title="Ссылка на этот заголовок">¶</a></h3>
<p>К атомарным относятся следующие предопределенные типы:</p>
<blockquote>
<div><ul class="simple">
<li><p>сигнальный тип (<strong>signal</strong>);</p></li>
<li><p>булевский тип (<strong>bool</strong>);</p></li>
<li><p>целый тип (<strong>int</strong>);</p></li>
<li><p>ошибочный тип (<strong>error</strong>);</p></li>
<li><p>пустой (незаданный) тип (<strong>empty</strong>);</p></li>
</ul>
</div></blockquote>
<p><strong>атомарный_тип = сигнальный | булевский | целый | функциональный |</strong></p>
<blockquote>
<div><p><strong>ошибочный| пустой.</strong></p>
</div></blockquote>
<p><strong>сигнальный = «signal».</strong></p>
<p><strong>булевский = «bool».</strong></p>
<p><strong>целый = «int».</strong></p>
<p><strong>пустой = «empty».</strong></p>
<div class="section" id="id23">
<h4><span class="section-number">3.8.3.1. </span>Сигнальный тип<a class="headerlink" href="#id23" title="Ссылка на этот заголовок">¶</a></h4>
<p><strong>Сигнальный тип</strong> (или просто <strong>сигнал</strong>) обозначается ключевым словом «<strong>signal</strong>». Он отличается от других атомарных типов тем, что не имеет конкретного значения и в динамике определяется только фактом своего появления. Для того, чтобы показать наличие сигнала, используется константа <strong>«!»</strong>. То есть, можно говорить о том, что сигнальный тип определяется только одним значением. Готовность величины сигнального типа определяется самим фактом появления атома.</p>
<p>Появление  сигнала качестве результата непосредственно определяет факт срабатывания соответствующего оператора интерпретации. Использование сигналов позволяет, при необходимости, моделировать в функциональных программах явное управление вычислениями. Они также могут сигнализировать о завершении работы функции, не возвращающей значимый результат.</p>
<p>Любая функция, не имеющая аргументов, может быть запущена только при наличии сигнала в качестве аргумента операции интерпретации. Постоянно присутствие сигнала, определяющее
«моментальный» запуск, задается следующим выражением:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>!:F
</pre></div>
</div>
<p>Формат величины, определяющий внутреннее строение сигнала:</p>
<p><strong>&lt;signal:func, !&gt;.</strong></p>
<p>По сути данные любого типа содержат сигнал, информирующий об их появлении. Отличие заключается в том, что все прочие типы данных имеют множество допустимых значений мощность которого больше единицы.</p>
</div>
<div class="section" id="id24">
<h4><span class="section-number">3.8.3.2. </span>Булевский тип<a class="headerlink" href="#id24" title="Ссылка на этот заголовок">¶</a></h4>
<p><strong>Булевский тип</strong> обозначается ключевым словом «<strong>bool</strong>». Данные булевского типа принимают значения из множества булевских констант (<strong>true</strong>, <strong>false</strong>), мощность которого равна двум.</p>
<p>Формат величины, определяющий внутреннее строение булевской величины:</p>
<p><strong>&lt;bool:func, {true, false}&gt;.</strong></p>
</div>
<div class="section" id="id25">
<h4><span class="section-number">3.8.3.3. </span>Целый тип<a class="headerlink" href="#id25" title="Ссылка на этот заголовок">¶</a></h4>
<p><strong>Целый тип</strong> обозначается ключевым словом «<strong>int</strong>». Данные целого типа принимают значения из множества целочисленных констант, мощность которого определяется реализацией целых чисел в конкретной компьютерной архитектуре.</p>
<p>Формат величины, определяющий внутреннее строение целочисленной величины:</p>
<p><strong>&lt;int:func, {MinInt, …, MaxInt}&gt;.</strong></p>
</div>
<div class="section" id="id26">
<h4><span class="section-number">3.8.3.4. </span>Ошибочный тип<a class="headerlink" href="#id26" title="Ссылка на этот заголовок">¶</a></h4>
<p><strong>Ошибочный тип</strong> обозначается ключевым словом «<strong>error</strong>». Данные ошибочного типа принимают значения из множества констант ошибок, которое задается путем перечисления видов ошибок, возможных в ходе выполнения функционально-потоковых параллельных программ. Данное множество может изменяться в ходе разработки системы функционально-потокового параллельного программирования. Однако при этом не предполагается, что пользователи могу  самостоятельно расширять данное множество, что и позволяет отнести его к классу атомарных типов. Данный тип не может использоваться в качестве функции.</p>
<p>Формат величины, определяющий внутреннее строение величины, задающей ошибку:</p>
<p><strong>&lt;error:empty, {Множестов значений костант, описывающих ошибки}&gt;.</strong></p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>Следует отметить, что на текущий момент множество атомарных типов не включает ряд типов, которые традиционно присутствуют практически во всех других языках программирования. В частности, отсутствует тип, задающий числа с плавающей точкой. Предполагается, что ядро языка не будет ориентировано на типы данных, связанные с конкретными прикладными вычислениями. Также в нем будут отсутствовать функции, ориентированные на обработку этих типов. Добавление новых типов и функций планируется рассматривать как расширение ядра языка (Праязыка, Надязыка). При этом возможны различные варианты расширений, которые будут определять семейства проблемно-ориентировнных дочерних языков (языков - потомков), предназначенных для соответствующих предметных областей и параллельных вычислителей (в основном речь идет об ориентации на различные параллельные вычислительные архитектуры).</em></p>
</div>
</div>
<div class="section" id="id27">
<h4><span class="section-number">3.8.3.5. </span>Пустой тип<a class="headerlink" href="#id27" title="Ссылка на этот заголовок">¶</a></h4>
<p>Понятие пустого типа вводится для обозначения того, что некоторая величина в одном из своих контекстов (данных или функции) не имеет конкретно заданного типа. То есть, она не относится ни к одному из предопределенных типов. Этот тип назначается тогда, когда не имеет смысла придумывать какой-то иной тип для обозначения группы значений. Например, множество знаков, используемых для задания функций сравнения не имеет смысла использовать как некоторой специализированной группы данных в предопределенном контексте:</p>
<p><strong>&lt;empty:func, { &lt;, &lt;=, =, !=, &gt;, &gt;=}&gt;</strong></p>
<p>Также данный тип не допускается использовать для конструирования других типов, так как он не несет требуемого для этого семантического смысла.</p>
</div>
</div>
<div class="section" id="id28">
<h3><span class="section-number">3.8.4. </span>Составные типы<a class="headerlink" href="#id28" title="Ссылка на этот заголовок">¶</a></h3>
<p><strong>Составные типы</strong> могут расширяться за счет атомарных типов, составных типов и сконструированных типов. Они группируют используемые типы в контейнеры или другие конструкции, обладающие определенными свойствами, что, в свою очередь, определяет семантику их использования в операторе интерпретации. К составным типам языка относятся:</p>
<blockquote>
<div><ul class="simple">
<li><p>типовой тип (<strong>type</strong>);</p></li>
<li><p>вектор (<strong>vector</strong>);</p></li>
<li><p><em>массив (?) (array);</em></p></li>
<li><p>структура (<strong>struct</strong>);</p></li>
<li><p>кортеж (<strong>tuple</strong>);</p></li>
<li><p>обобщение (<strong>union</strong>);</p></li>
<li><p>любой (выводимый) тип (<strong>any</strong>);</p></li>
<li><p>рой (<strong>swarm</strong>);</p></li>
<li><p>поток (<strong>stream</strong>);</p></li>
<li><p>функциональный тип (<strong>func</strong>);</p></li>
<li><p>ссылка (<strong>ref</strong>).</p></li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>Использование статической типизации в целом значительно изменяет семантику языка. Затрагивает она и синтаксис. При формировании данного описания пока не делается разделение между моделью и языком. Это планируется сформировать позднее, осуществив необходимые переносы текста.</em></p>
</div>
<div class="section" id="id29">
<h4><span class="section-number">3.8.4.1. </span>Типовой тип<a class="headerlink" href="#id29" title="Ссылка на этот заголовок">¶</a></h4>
<p><strong>Типовой тип (тип типа)</strong> обозначается ключевым словом <strong>type</strong> или символом <strong>«&#64;»</strong>. Данные этого типа принимают значения из множества имен предопределенных типов и типов, созданных пользователем и используемых в текущей программе. По сути это некоторый перечислимый тип, значения которого расширяются по мере порождения пользователем новых именованных типов, определяемых через описания типов. Это расширение и позволяет относить данный тип к составным.</p>
<p><strong>типовой = «type» | «&#64;».</strong></p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>Предполагается, что на текущем этапе данный тип реализовываться не будет информация о нем оставлена, чтобы не забыть обдумать его в дальнейших исследованиях.</em></p>
<p><em>Скорее всего этот тип может стать интересным, если в язык добавить вывод типов.</em></p>
</div>
<p>Формат величины, определяющий внутреннее типового типа:</p>
<p><strong>&lt;data_type:func, {Множестов имен предопределенных и сконструированных типов}&gt;.</strong></p>
</div>
<div class="section" id="id30">
<h4><span class="section-number">3.8.4.2. </span>Тип Вектор<a class="headerlink" href="#id30" title="Ссылка на этот заголовок">¶</a></h4>
<p>Тип <strong>Вектор</strong> (векторный тип) обозначается ключевым словом <strong>vector</strong>. Он обеспечивает группировку данных одного типа в вектор, готовность которого к выполнению определяется при поступлении всех его элементов. Возможно формирование статических и динамических векторов. Длина статически определяемого вектора задается константным выражением, значение которого должно быть положительной целочисленной величиной вычисляемой во время компиляции. Длина динамически порождаемого вектора вычисляется во время выполнения программы, но до начала его использования. Ее значение тоже должно являться целым числом.</p>
<p>Элементы вектора задаются в виде списка значений, заключенных в круглые скобки:</p>
<blockquote>
<div><p>(элемент<sub>0</sub>, элемент<sub>2</sub>, … элемент<sub>N-1</sub>)</p>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>Принято решение начать нумерацию элементов не с 1, а с 0, как это сейчас принято во большинстве языков программирования. Оно обусловлено тем, что убраны отрицательные значения индексов, используемых в качестве функций, которые убирают соответствующий номеру элемент из вектора. Исчезновение этих функций связано с тем, что при их использовании возвращается резульат друго типа, отличающегося от типа элемента.</em></p>
</div>
<p>Нумерация элементов, размещенных внутри вектора, начинается с нуля. Число N в данном случае определят длину вектора. Описание векторного типа задает для типа имя, определяемое пользователем. Это описание всегда требует указание длины вектора целочисленным константным выражением и задается с использованием следующего синтаксиса:</p>
<p><strong>вектор = [«vector»] имя_типа «(» длина «)».</strong></p>
<p><strong>длина = ЦелочисленноеКонстантноеВыражение | ЦелочисленноеВыражение.</strong></p>
<p>Примеры описания векторных типов:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">&lt;&lt;</span> <span class="o">@</span> <span class="nb">int</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>             <span class="o">//</span> <span class="n">Целочисленный</span> <span class="n">вектор</span> <span class="n">типа</span> <span class="n">А</span>
<span class="n">B</span> <span class="o">&lt;&lt;</span> <span class="o">@</span> <span class="n">vector</span> <span class="nb">bool</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>      <span class="o">//</span> <span class="n">Булевский</span> <span class="n">вектор</span> <span class="n">типа</span> <span class="n">А</span>
</pre></div>
</div>
<p>Ключевое слово <strong>vector</strong> в описании типа является необязательным. Оно также может использоваться при проверке типа, а также в качестве имени функции при выполнении оператора интерпретации.</p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>Следует отметить, что одной из идей является использование многомерных массивов, задаваемых с использованием ключевого слова</em> <strong>array</strong>. <em>Это расширяет параллелизм на многомерные конструкции. Возможное их описание может быть представлено следующим синтаксисом:</em></p>
<p><strong>Массив = ИмяТипа «(» Размерность «)».</strong></p>
<dl class="simple">
<dt><strong>Размерность = (ЦелочисленноеКонстантноеВыражение | ЦелочисленноеВыражение)</strong></dt><dd><p><strong>{ «,» (ЦелочисленноеКонстантноеВыражение | ЦелочисленноеВыражение) }.</strong></p>
</dd>
</dl>
<p><em>Примеры массивов</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">AA</span> <span class="o">&lt;&lt;</span> <span class="o">@</span> <span class="nb">int</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">BB</span> <span class="o">&lt;&lt;</span> <span class="o">@</span> <span class="nb">bool</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">)</span>
</pre></div>
</div>
<p><em>Однако пока мне непонятно, каким образом лучше реализовать массивы. Прямое решение не выглядит достаточно эффективным из-за проблем с использованием многоразмерных индексных выражений. В дальнейшем, как вариант, предполагается рассмотреть реализацию массивов в виде расширения векторов. То есть в виде некторой оболочки, которая добавляет индексы к вектору. Тогда для выбора любого элемента массива планируется преобразование его индексов к индексу вектора путем специальной операции</em> <strong>index</strong>. <em>Например:</em> <cite>A:index^(i,j,k)</cite>. <em>Этот вариант видится мне более предпочтительным. Не смотря на то, что вектор уже не будет частным случаем массива, данный вариант позволяет рассматривать приведение массива к вектору и вектора к массиву…</em></p>
<p><em>На данном этапе реализацию многомерных массивов реализовывать не планируется.</em></p>
</div>
</div>
<div class="section" id="id31">
<h4><span class="section-number">3.8.4.3. </span>Тип Структура<a class="headerlink" href="#id31" title="Ссылка на этот заголовок">¶</a></h4>
<p>Тип <strong>Структура</strong> (структурный тип) обеспечивает группировку разнотипных данных по аналогии со структурными типами различных языков программирования. Структура состоит из полей, каждое из которых имеет имя и тип. Описание структуры имеет следующий синтаксис:</p>
<p><strong>Структура = [«struct»] «(» ПолеСтруктуры { «,» ПолеСтруктуры } «)».</strong></p>
<dl class="simple">
<dt><strong>ПолеСтруктуры = ИмяПоля «&#64;» ИмяТипа</strong></dt><dd><p><strong>| «[» ИмяПоля { «,» ИмяПоля } «]» «&#64;» ИмяТипа.</strong></p>
</dd>
</dl>
<p>Примеры структурных типов:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Triangle</span> <span class="o">&lt;&lt;</span> <span class="o">@</span> <span class="p">(</span><span class="n">a</span><span class="nd">@int</span><span class="p">,</span> <span class="n">b</span> <span class="o">@</span> <span class="nb">int</span><span class="p">,</span> <span class="n">c</span> <span class="nd">@int</span><span class="p">)</span>
<span class="n">Rectangle</span> <span class="o">&lt;&lt;</span> <span class="o">@</span> <span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span><span class="nd">@int</span><span class="p">)</span>
</pre></div>
</div>
<p>Ключевое слово <strong>struct</strong>  не является обязательным в описании структуры. Оно также может использоваться при проверке типа, а также в качестве имени функции при выполнении оператора интерпретации.</p>
</div>
<div class="section" id="id32">
<h4><span class="section-number">3.8.4.4. </span>Тип Кортеж<a class="headerlink" href="#id32" title="Ссылка на этот заголовок">¶</a></h4>
<p>Тип <strong>Кортеж</strong>, как и структура, предназначен для группирования неоднородных данных. Он отличается от структуры отсутствием именованных полей. По сути он похож на вектор, но может содержать разнотипные элементы. Обращение к элементам кортежа осуществляется по номеру поля (поля, как и в векторе, нумеруются, начиная с единицы). Для задания кортежей используется следующий синтаксис:</p>
<blockquote>
<div><p><strong>кортеж = [«tuple»] «(» ИмяТипа [«(» Множитель»)»]</strong></p>
<blockquote>
<div><p><strong>{ «,» ИмяТипа } [«(» Множитель»)»]»)».</strong></p>
</div></blockquote>
<p><strong>Множитель = Целое.</strong></p>
</div></blockquote>
<p>Множитель позволяет задать коэффициент повторения для типа, который повторяется несколько раз подряд. Это целое положительное число.</p>
<p>Примеры задания типов кортежей:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">С</span> <span class="o">&lt;&lt;</span> <span class="o">@</span> <span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="n">В</span> <span class="o">&lt;&lt;</span> <span class="o">@</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">signal</span><span class="p">)</span>
<span class="n">D</span> <span class="o">&lt;&lt;</span> <span class="o">@</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="nb">bool</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">signal</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>
</pre></div>
</div>
<p>Ключевое слово <strong>tuple</strong>  не является обязательным в описании кортежа. Оно также может использоваться при проверке типа, а также в качестве имени функции при выполнении оператора интерпретации. Возможно явное преобразование структур в кортеж, что обуславливается эквивалентностью представления типов данных внутри структур и кортежей. Помимо этого возможно явное приведение к типу кортеж векторов. Обратное приведение допустимо, если все элементы кортежа  имеют один тип. Допускается также явное приведение кортежей к именованным структурам, типы элементов которых попарно совпадают с типами элементов кортежа.</p>
</div>
<div class="section" id="id33">
<h4><span class="section-number">3.8.4.5. </span>Тип Обобщение<a class="headerlink" href="#id33" title="Ссылка на этот заголовок">¶</a></h4>
<p>Тип <strong>Обобщение</strong> (обобщающий тип) во многом аналогичен по организации и использованию обобщениям, используемым в других языках. Основной его задачей является объединение воедино взаимоисключающих артефактов. Существуют различные подходы к организации обобщений, включая методы, поддерживающие полиморфизм. В языке предполагается использование процедурно-параметрических обобщений, обеспечивающих более гибкую поддержку эволюционного расширения программ по сравнению с другими подходами. Правила, определяющие синтаксис обобщений имеют следующий вид:</p>
<p><strong>Обобщение = [«union»] «{» ПолеОбобщения { «,» ПолеОбобщения } «}»</strong></p>
<dl class="simple">
<dt><strong>ПолеОбобщения = ИмяТипа { «,» ИмяТипа }</strong></dt><dd><p><strong>| ИмяПризнака «&#64;» ИмяТипа</strong>
<strong>| «[» ИмяПризнака { «,» ИмяПризнака } «]» «&#64;» ИмяТипа</strong></p>
</dd>
</dl>
<p>Ключевое слово <strong>union</strong>  не является обязательным в описании обобщения. Оно также может использоваться при проверке типа, а также в качестве имени функции при выполнении оператора интерпретации.</p>
<p>Примеры описания обобщений:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Figure1</span> <span class="o">&lt;&lt;</span> <span class="o">@</span> <span class="p">{</span><span class="n">Triangle</span><span class="p">,</span> <span class="n">Rectangle</span><span class="p">}</span>
<span class="n">Figure2</span> <span class="o">&lt;&lt;</span> <span class="o">@</span> <span class="p">{</span><span class="n">trian</span><span class="nd">@Triangle</span><span class="p">,</span>
                <span class="n">rect</span><span class="nd">@Rectangle</span><span class="p">,</span>
                <span class="n">rhomb</span><span class="nd">@Rectangle</span><span class="p">}</span>
<span class="n">WeekDay</span> <span class="o">&lt;&lt;</span> <span class="o">@</span> <span class="p">{[</span><span class="n">Sun</span><span class="p">,</span><span class="n">Mon</span><span class="p">,</span><span class="n">Tue</span><span class="p">,</span><span class="n">Wen</span><span class="p">,</span><span class="n">Thu</span><span class="p">,</span><span class="n">Fri</span><span class="p">,</span><span class="n">Sat</span><span class="p">]</span><span class="nd">@signal</span><span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>Пока вопрос с обобщением и их использованием рассматривается на уровне мономорфизма. То есть, предполагается явный анализ признаков обобщения, аналогичный тому, как это делается с объединениями в Си и вариантными записями в Паскале. Применение процедурно-параметрического полиморфизма или других вариантов планируется только в следующих версиях.</em></p>
</div>
<p>Следует также отметить наличие в языке глобального обобщения, которое может объединять в единую конструкцию любые именованные типы данных. В этом случае обобщение  обеспечивает поддержку в языке динамической типизации и по сути является аналогом вариантных данных различных языков. Допускает приведение произвольных значений к данному типу с последующим возможным анализом имени типа полученного значения и соответствующим его выделением для выполнения необходимых операций.</p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>С другой стороны этот тип может рассматриваться как процедурно-параметрическое обобщение общего вида, формируемое автоматически сборкой имен типов в качестве признаков. То есть, можно будет создавать обработчики обобщений с использованием в качестве обобщающих аргументов тип</em> <strong>any</strong>.</p>
<p><em>Пока я обозначил этот тип. Более конкретный его анализ, включая полноту операций, планируется провести позднее. Также пока непонятно, стоит ли вообще вводить этот тип. Возможно, что он может оказаться полезным, когда будет рассматриваться добавление вывода типов с неопределенными атрибутами во время компиляции.</em></p>
</div>
<p>Глобальные обобщения относятся к типу <strong>union</strong>. Формируемые именованные параметрические обобщения имеют тип, соответствующий заданным именам типов.</p>
</div>
<div class="section" id="id34">
<h4><span class="section-number">3.8.4.6. </span>Любой тип<a class="headerlink" href="#id34" title="Ссылка на этот заголовок">¶</a></h4>
<p><strong>Любой тип</strong> обозначается ключевым словом <strong>any</strong>. По сути это не обозначение конкретно типа, а понятие, показывающее, что в данном месте программы может находиться любой именованный тип, описанный в программе. В ходе компиляции программы вместо <strong>any</strong> осуществляется подстановка конкретного типа, выводимого из контекста. То есть, данное понятие используется системой вывода типов. В основном <strong>any</strong> используется в прототипах функций для описания типов, которые могут принимать различные значения, включая и пустой тип. Основная задача данного понятия заключается в обеспечении системы вывода типов. Также используется при описания прототипов в документации для того, чтобы показать наличие на данном месте любого конкретного типа.</p>
</div>
<div class="section" id="id35">
<h4><span class="section-number">3.8.4.7. </span>Тип Рой<a class="headerlink" href="#id35" title="Ссылка на этот заголовок">¶</a></h4>
<p>Тип <strong>Рой</strong> (роевой тип) используется для описание независимых данных, над которыми возможно выполнение массовых параллельных операций. Обозначается ключевым словом <strong>swarm</strong>. Все элементы роя имеют один тип, а функция, осуществляющая их обработку, может одновременно выполняться над каждым элементом. Результатом является также рой, размерность которого равна размерности роя аргументов. Синтаксические правила, определяющие данный тип, имеют следующий вид:</p>
<p><strong>Рой = [«swarm»] ИмяТипа «[» Целое «]».</strong></p>
<p>Ключевое слово <strong>swarm</strong>  не является обязательным в описании роя. Оно также может использоваться при проверке типа, а также в качестве имени функции при выполнении оператора интерпретации.</p>
<p>Пример описания типа:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">R</span> <span class="o">&lt;&lt;</span> <span class="o">@</span> <span class="nb">int</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span>
</pre></div>
</div>
<p>Рой обеспечивает группировку данных одного типа в вектор, готовность которого к выполнению определяется при поступлении любого его элементов. В отличие от вектора оператор интерпретации начинает реагировать на поступление в рой каждого элемента вместо ожидания момента, когда данные полностью сформируются. Это может обеспечить запуск и частичное выполнение функции, обрабатывающий рой до того момента, когда будут готов все его данные.</p>
<p>Возможно формирование роев фиксированной и переменной размерности, каждый из которых обладает своими свойствами и может обрабатываться своим множеством функций. Множества функций для обработки разных видов роев пересекаются, но не перекрываются. Элементы роя задаются в виде списка значений, заключенных в квадратные скобки:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>[элемент\ :sub:`1`, элемент\ :sub:`2`, ... элемент\ :sub:`N`]
</pre></div>
</div>
<p>Нумерация элементов, размещенных внутри роя, начинается с единицы. Число N в данном случае определят размер роя. Размер роя может быть задан константным выражением при описании его типа в том случае, если объявляется рой с фиксированной размерностью.</p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>Как и для вектора пока предлагается только одномерное решение. Хотя есть соблазн разобраться и с реализацией многомерных роев. Но пока данный вопрос остается нерешенным.</em></p>
</div>
</div>
<div class="section" id="id36">
<h4><span class="section-number">3.8.4.8. </span>Тип Поток<a class="headerlink" href="#id36" title="Ссылка на этот заголовок">¶</a></h4>
<p>Тип <strong>Поток</strong> является альтернативой асинхронному списку языка программирования Пифагор. Он используется для обработки данных поступающих последовательно и асинхронно в произвольные промежутки времени. Размерность поступающих данных при этом неизвестна, поэтому завершение обработки возможно только по признаку конца потока. Поток готов к обработке при наличии в нем хотя бы одного элемента. Тип всех элементов потока одинаков. Синтаксические правила, определяющие поток:</p>
<p><strong>Поток = [«stream»] ИмяТипа «{» «}».</strong></p>
<p>Ключевое слово <strong>stream</strong>  не является обязательным в описании потока. Оно также может использоваться при проверке типа, а также в качестве имени функции при выполнении оператора интерпретации.</p>
<p>Пример описания потокового типа:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">&lt;&lt;</span> <span class="o">@</span> <span class="nb">int</span><span class="p">{}</span>
<span class="n">B</span> <span class="o">&lt;&lt;</span> <span class="o">@</span> <span class="n">swarm</span> <span class="nb">bool</span><span class="p">{}</span>
</pre></div>
</div>
</div>
<div class="section" id="id37">
<h4><span class="section-number">3.8.4.9. </span>Функциональный тип<a class="headerlink" href="#id37" title="Ссылка на этот заголовок">¶</a></h4>
<p>Тип <strong>Функция</strong> (или <strong>функциональный тип</strong>) обозначается ключевым словом <strong>func</strong>. Позволяет задать прототип функции, определяя имя типа, тип аргумента, а также тип результата. В целом определение функционального типа отличается от общепринятых в других языках программирования только тем, что любая функция имеет только один аргумент и возвращает только один результат. Синтаксические правила, определяющие описание функционального типа:</p>
<p><strong>ФункциональныйТип = («func» | «&quot;) Аргумент «-&gt;» Результат</strong></p>
<p><strong>Аргумент = ИмяТипа | КортежТипов</strong></p>
<p><strong>Результат = ИмяТипа | КортежТипов</strong></p>
<p><strong>КортежТипов = «(» ИмяТипа «,» { ИмяТипа } «)»</strong></p>
<p>Примеры описаний:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">F</span> <span class="o">&lt;&lt;</span> <span class="o">@</span> <span class="n">func</span> <span class="nb">int</span> <span class="o">-&gt;</span> <span class="nb">int</span>
<span class="n">F2</span> <span class="o">&lt;&lt;</span> <span class="o">@</span> <span class="n">func</span> <span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
<span class="n">F3</span> <span class="o">&lt;&lt;</span> <span class="o">@</span>\<span class="nb">int</span> <span class="o">-&gt;</span> <span class="nb">int</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>Принято решение о возможном использовании знака ```` в качестве альтернативы ключевому слову ``func``. Это достаточно субъективное решение. Оно навеяно описанием лямбда фукнций в Хаскеле. Но ничто не мешает его использованию и здесь. Тем более, что представленный тип описания, как и описание самих функций с этим знаком синтаксически ничему не противоречат. Эти же альтернативные обозначения можно будет использовать и при задании лямда функций, если они появятся в языке (когда-то появятся…).</em></p>
</div>
<p>С каждым функциональным типом связываются тип аргумента, обрабатываемого функцией, и тип формируемого результата, образуя прототип функции. Прототип определяет принадлежность всех функций к одному типу. При этом любая функция, соответствующая данному прототипу, может восприниматься как некоторая величина, областью допустимых значений (ОДЗ) которой является совокупность ОДЗ ее аргумента и результата, что как раз и задается функциональным типом.</p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>Возможны в перспективе варианты, когда функция возвращает вектор, массив, рой или поток. Но пока так глубоко копать не буду…</em></p>
<p><em>Интерес также представляет задание структуры в качестве типа. Но в данной ситуации предполагается, что использование кортежа обеспечивает структурную эквивалентность и позволяет в дальнейшем подставлять любые структурно эквивалентные типы…</em></p>
<p><strong>Нужно по тексту четко отделить прототип от сигнатуры. Пока это не сделано.</strong></p>
</div>
</div>
<div class="section" id="id38">
<h4><span class="section-number">3.8.4.10. </span>Тип Ссылка<a class="headerlink" href="#id38" title="Ссылка на этот заголовок">¶</a></h4>
<p>Тип <strong>Ссылка</strong> (или ссылочный тип) обеспечивает поддержку указателей на различные хранилища определенного типа, что позволяет передавать значения между функциями без их копирования. Основное назначение заключается в дополнительном контроле типов в ходе передач. Синтаксические правила, определяющие описание ссылочного типа:</p>
<p><strong>Ссылка = ИменованнаяСсылка | СсылкаНаВектор | СсылкаНаРой | СсылкаНаПоток.</strong></p>
<p><strong>ИменованнаяСсылка = «&amp;» ИмяТипа.</strong></p>
<p>Данная ссылка обеспечивает обеспечивает доступ к данным, имеющим соответствующий именованный тип. В зависимости от того, каким образом сформированы эти данные, через ссылку может осуществляться как их чтение, так и запись. В последнем случае должен соблюдаться принцип единственного присваивания, если установлена неизменяемость данных.</p>
<p>При взаимодействии с контейнерными данным зачастую вместо именованных типов удобнее использовать данные, имеющие отличающуюся размерность, это затрагивает векторы, массивы, рои. Для описания в этих случаях предлагаются ссылки, в которых размерность не устанавливается:</p>
<p><strong>СсылкаНаВектор = «&amp;» ИмяТипа «(» «)».</strong></p>
<p><strong>СсылкаНаРой = «&amp;» ИмяТипа «[» «]».</strong></p>
<p><strong>СсылкаНаПоток = «&amp;» ИмяТипа «{» «}».</strong></p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><strong>Тоже пока вызывает много вопросов. Требует проработки… Возникла мысль, что данный тип может и не нужен. Вместо него достаточно использовать соответствующие  ссылки как обозначения, присоединяемые к величинам и хранилищам. Нужно думать…</strong></p>
<p><em>В частности следует отметить, что со ссылками можно связать дополнительный артефакт, обеспечивающий независимое сопровождение при обработке ряда составных типов. Например, потоков и роев. В этом случае формируются дополнительные конструкции, обеспечивающие для каждой из ссылок независимый обход данных. Поэтому нужно думать…</em></p>
<p><em>В перспективе возможно добавление ссылки на массив:</em></p>
<p><strong>СсылкаНаМассив = «&amp;» ИмяТипа «(» РазмерностьМассива «)».</strong> (???)</p>
</div>
</div>
</div>
<div class="section" id="id39">
<h3><span class="section-number">3.8.5. </span>Преобразование (приведение) величин разных типов<a class="headerlink" href="#id39" title="Ссылка на этот заголовок">¶</a></h3>
<p>Преобразование типов обеспечивает определенную гибкость в манипуляции абстракциями. Можно выделить статическое и динамическое преобразование типов. При статическом пробразовании типов этим процессом занимается компилятор. То есть, все возможные ошибки определяются на этапе компиляции. Динамическое приведение типов осуществляется во время выполнения программы и связано в основном с преобразованиями обобщений посредством функций преобразования типов, которые вводятся в язык для повышения гибкости. Описание этих функций будет сделано при рассмотрении оператора интерпретации. Следует также отметить, что преобразования осуществляются не с самими типами а над величинами, имеющими некоторый тип, которые преобразуются к величинам другого типа.</p>
<div class="section" id="id40">
<h4><span class="section-number">3.8.5.1. </span>Статические преобразования типов во время компиляции<a class="headerlink" href="#id40" title="Ссылка на этот заголовок">¶</a></h4>
<p>Возможны следующие статические преобразования типов величин:</p>
<ol class="arabic simple">
<li><p>Тип любой величины может быть преобразован к сигнальному типу. При этом значение исходной величины теряется. По сути сигнальный тип является своеобразным обобщением всех других типов, так как он несет только информацию (сигнал) о готовности данных. Следует также отметить, что получение любого другого типа из сигнального невозможно.</p></li>
<li><p>Именованный тип любой величины может быть преобразован к типу <strong>union</strong>. В этом случае формируется структура, определяющая любой тип, которая хранит имя преобразуемого типа, а также сохраняет его значения. Дальнейшие манипуляции с полученной величиной, включая преобразование ее типа, при отсутствии системы вывода типов, могут проводиться только во выполнения программы.</p></li>
<li><p>Именованный тип, сформированный определением типа в описании <strong>type</strong> на основе другого именованного типа, может быть явно преобразован к своему родительскому типу на этапе компиляции. При этом значение программного артефакта не меняется. Данное приведение позволяет выполнять над имеющимся значением все операции над родительским типом. В принципе, используя механизм трансформации, можно изменить поведение преобразования по умолчанию. При этом может измениться значение величины во время выполнения. Однако тип преобразованного значения все равно определяется во время компиляции.</p></li>
<li><p>Именованный родительский тип, используемый при определении нового типа в описании <strong>type</strong>, может быть явно преобразован к этому новому типу на этапе компиляции. При этом значение существующей величины не изменяется. Над преобразованной величиной возможны только функции, определенные над этим новым типом. Здесь ситуация обратная предыдущему случаю. То есть, наличию сформированного инкапсулированного набора можно использовать только после явных приведений типа. Также возможно создание функции трансформации, изменяющей поведение функции используемой по умолчанию.</p></li>
<li><p>Формируемые в программе величины, имеющие структурный тип, могут быть явно преобразованы к кортежам на этапе компиляции. Это преобразование полезно при использовании различных структур в качестве аргументов функций без дополнительный явных приведений.</p></li>
</ol>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>Неявные преобразования структур, векторов и т.д. к кортежам и обратно решил запретить</em></p>
</div>
<p>Представленные преобразования могут осуществляться только явно. Явные преобразования предполагают непосредственное использование функций приведения типов, обеспечивающих получение соответствующих новых типов. Например:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>6: apple                      @int     ⇒ @apple
(3,4):intPair                 @(int, int)  ⇒ @intPair
(1,2,3,4,5):vector:signal     @(int, int, int, int, int)  ⇒ @int(5)  ⇒ @signal
</pre></div>
</div>
<p>Неявные преобразования запрещены, так как могут привести к коллизиям и неопределенному поведению. Например:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>:+ &lt;&lt; func x@intPair-&gt;@int {x:tuple:-:return}
// непонятно, какую функцию сложения использовать
(3,4):+     ⇒ 7
// Поэтому:
(3,4):intPair:+ ⇒ -1
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>Обозначение «:+» задает перегрузку знака «+» в качестве функции.</em></p>
</div>
<p>Возможно ситуация, когда имя функции перегружено, а ее уникальность определяется сигнатурой. В этой ситуации возможны функции с разной сигнатурой, аргументы которых имеют типы, созданные от одного родителя. Тогда невозможно определить, какую из функций подставить. В этой ситуации требуется явное приведение типа. Например:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">apple</span> <span class="o">&lt;&lt;</span> <span class="o">@</span> <span class="nb">int</span><span class="p">;</span>
<span class="n">pear</span>  <span class="o">&lt;&lt;</span> <span class="o">@</span> <span class="nb">int</span><span class="p">;</span>
<span class="n">f1</span> <span class="o">&lt;&lt;</span> <span class="n">func</span> <span class="n">x</span><span class="nd">@apple</span><span class="o">-&gt;</span><span class="n">signal</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
<span class="n">f1</span> <span class="o">&lt;&lt;</span> <span class="n">func</span> <span class="n">x</span><span class="nd">@pear</span><span class="o">-&gt;</span><span class="n">signal</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
<span class="mi">5</span><span class="p">:</span><span class="n">pear</span><span class="p">:</span><span class="n">f1</span>       <span class="o">--</span> <span class="n">явное</span> <span class="n">приведение</span> <span class="n">для</span> <span class="n">выбора</span> <span class="n">нужной</span> <span class="n">функции</span>
</pre></div>
</div>
</div>
<div class="section" id="id41">
<h4><span class="section-number">3.8.5.2. </span>Преобразование между атомарными константами<a class="headerlink" href="#id41" title="Ссылка на этот заголовок">¶</a></h4>
<p>Зачастую при использовании констант удобнее использовать неявные преобразования для восприятия написанного кода. В частности во многих языках программирования целочисленный ноль (0) в зависимости от контекста может восприниматься как действительное число (0.0).
Аналогичные неявные преобразования значений констант предполагается использовать и в разрабатываемом языке в тех случаях, когда контекст константы очевиден. В частности на данный момент просматриваются следующие неявные преобразования:</p>
<p>Для булевских величин вместо <strong>true</strong> и <strong>false</strong> допускается неявно использовать целочисленные константы <strong>0</strong> и <strong>1</strong> соответственно. Эту возможность предполагается использовать для разработки функций, реализующих булевские функции, которые впоследствии планируется транслировать в топологию ПЛИС. Удобнее в этом случае манипулировать числами, отображающими булевские значения. Преобразование осуществляется на этапе компиляции.</p>
</div>
</div>
</div>
<div class="section" id="id42">
<h2><span class="section-number">3.9. </span>Данные (величины)<a class="headerlink" href="#id42" title="Ссылка на этот заголовок">¶</a></h2>
<p>Данные формируются в ходе вычислений. Они отображаются на память компьютера. Если в языке Пифагор для их представления достаточно было использовать результаты выполнения функций, увязанные с обозначениями, то применение статической типизации наряду с этим подходом позволяет, используя принцип единственного присваивания, создавать незаполненные хранилища требуемого типа, которые в ходе вычислений могут наполняться. Это, с одной стороны, усложняет семантику языка, но с другой позволяет повысить эффективность разрабатываемого кода за счет прямого доступа к заранее сформированным контейнерам вместо их сборки во время выполнения программы с использованием программоформирующих операторов. При этом ранне используемый подход с обозначением результатов вычислений остается, что позволяет писать программы в чисто функциональном стиле.</p>
<p>Использование типов при этом обеспечивает описание хранилищ данных:</p>
<p><strong>Хранилище = ИмяХранилища «&#64;» ( ИмяТипа | СоставнойТип | Ссылка ).</strong></p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>Следует уточнить и описать подробнее.</em></p>
<p><em>Есть подозрение, что ссылку как тип можно убрать, сделав ее явным обозначением путем соответствующего именования</em></p>
</div>
<p>Примеры:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>x@int
y@intPair
point@(int, int)
intRef@&amp;int ???
vectorRef @&amp;bool() ???
rectangle@([a,b]@int)
</pre></div>
</div>
</div>
<div class="section" id="id43">
<h2><span class="section-number">3.10. </span>Операторы<a class="headerlink" href="#id43" title="Ссылка на этот заголовок">¶</a></h2>
<p>Операторы языка определяются в соответствии со статически типизированной функционально-потоковой моделью параллельных вычислений. Они обеспечивают формирование каркаса функции. Выделяются операторы группировки и операторы интерпретации.</p>
<p><strong>Операторы группировки</strong> обеспечивают формирование значений составных типов. К ним относятся:</p>
<blockquote>
<div><ul class="simple">
<li><p>оператор, обеспечивающий создание кортежей (<strong>tuple</strong>);</p></li>
<li><p>оператор формирования роя (<strong>swarm</strong>);</p></li>
<li><p>оператор загрузки в поток (<strong>stream</strong>);</p></li>
<li><p>оператор задержки (<strong>delay</strong>).</p></li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>Наряду с этими основными операторами нужно обратить внимание, что статическая типизация позволяет создавать составные типы с фиксированной структурой, доступ к элементам которых может обеспечиваться записью в отдельные поля с соблюдением принципа единственного присваивания.</em></p>
<p><em>Необходимо не забыть и описать соответствующие группы операторов для выше определенных типов данных с фиксированной структурой. Это описание необходимо добавить в раздел, посвященный описанию семантики.</em></p>
</div>
<p><strong>Оператор интрепретации</strong> обеспечиваеь формирование функциональных преобразований. Один из его входных параметров является функцией, а другой определяет аргумент, обрабатываемый этой функцией. Используются префиксная и постфиксаная формы оператора интрепретации. В префиксной форме оператор обозначается знаком <strong>^</strong>. В этом случае функция <strong>F(x)</strong> будет записана ка <strong>F^x</strong>. Оператор интрепретации в постфиксной форме задется двоеточием (<strong>:</strong>), что позволяет записать приведенную функцию в виде <strong>x:F</strong>.</p>
<p>Данный оператор по сути обеспечивает поддержку семантики всех функциональных преобразований, которая представлена в следующем разделе. По сути это единсвенная явно задаваемая функция языка. Все функциональные преобразования определяются через этот оператор.</p>
<p>Существуют также групповой оператор интерпретации, который предназначен для описания параллельных вычислений. Его синтаксическое отличие заключается в написании каждого из знаков интерпретации дважды: <strong>^^</strong> или <strong>::</strong>. Семантика данного оператора также представлена в следующем разделе.</p>
</div>
<div class="section" id="id44">
<h2><span class="section-number">3.11. </span>Функция<a class="headerlink" href="#id44" title="Ссылка на этот заголовок">¶</a></h2>
<p><strong>Функция</strong> – составной артефакт, конструируемый специальным образом. Она задается
определением, начинающимся с ключевого слова <strong>func</strong> или знака <strong>**. Функция состоит из заголовка и тела. В заголовке указывается идентификатор аргумента, обеспечивающего передачу в тело функции необходимых данных и его тип, а также тип результата, возвращаемого из функции. В теле описывается алгоритм обработки аргумента с применением соответствующих элементов языка. Доступ к исходным данным осуществляется только через аргумент. Тело функции состоит из элементов, заключенных в фигурные скобки и разделяемых между собой символом **»;»</strong>.</p>
<p>В ходе выполнения функции обычно формируется результат, который возвращается
после применения к нем функции возврата, обозначаемой зарезервированным идентификатором <strong>return</strong>:</p>
<p><code class="docutils literal notranslate"><span class="pre">результат:return</span></code> или <code class="docutils literal notranslate"><span class="pre">return^результат</span></code></p>
<p>Помимо этого ключевое слово <strong>return</strong> может использоваться в качестве альтернативного варианта точки возрата, когда оно задает не функцию, а обозначение возвращаемого значения:</p>
<p><code class="docutils literal notranslate"><span class="pre">результат</span> <span class="pre">&gt;&gt;</span> <span class="pre">return</span></code> или <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">&lt;&lt;</span> <span class="pre">результат</span></code></p>
<p>Этот вариант предназначен для случаев, когда из функции необходимо возвратить задержку.</p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>Наличие подобного свойства еще нужно обдумать… Пока же о реализации говорить рано.</em></p>
</div>
<p>Возвращаемый результат может быть любым допустимым значением, полученным в
ходе вычислений. Возврат результата может осуществляться до завершения выполнения всех
операций в теле функции, которая продолжает существования до завершения всех
внутренних операций. В этом случае в теле функции будет наблюдаться побочный эффект, который может быть связан либо с какими-то дополнительными фоновыми действиями, либо с ошибкой в ее реализации. Однако повторного возврата, в соответствии с принципом единственного присваивания, произойти не может.
Избавление от побочных эффектов, если они являются лишними, осуществляется путем анализа и оптимизации тела функции соостветствующими методами анализа.</p>
<p>Если в качестве результата задается рой, то возможен асинхронный (не одновременный) возврат его независимых элементов. Также в качестве возвращаемого значения может выступать сигнал.</p>
<p><strong>Функция = («func» | «&quot;) [ Аргумент ]</strong></p>
<blockquote>
<div><p><strong>[«-&gt;» ТипРезультата] [ТелоФункции].</strong></p>
</div></blockquote>
<p><strong>Аргумент = ИмяАргумента «&#64;» ИмяТипа</strong></p>
<blockquote>
<div><p><strong>| ИмяАргумента «&#64;» «(» ИмяТипа { «,» ИмяТипа } «)»</strong></p>
<p><strong>| «(» ИмяПоля «&#64;» ИмяТипа { «,» ИмяПоля «&#64;» ИмяТипа } «)».</strong></p>
</div></blockquote>
<p><strong>ТелоФункции = [ «{» [ Элемент {«;» Элемент }] «}» ].</strong></p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>Пока не проработаны и не включены варианты, связанные с использованием в качестве прямого аргумента потоков и других артефактов. Но скорее всего из добавление пойдет как именованных типов</em></p>
</div>
<p>При отсутствии в определении функции аргумента предполагается, что он имеет сигнальный тип, использование которого в теле фунции не имеет смысла. Однако такой аргумент всегда присутствуе при вызове функции, определяя момент ее запуска. В этом случае сигнал может задаваться константой, указывая на немедленный запуск функции. Или же он может являться вычисляемым значением, что позволяет отложить запуск функции без параметров на некоторое время.</p>
<p>Тип возвращаемого значения также может не указываться. В этом случае предполагается что функция возращает сигнал. Также возврат сигнального значения может быть задан явно.</p>
<p>Отсутствие у функции тела интерпретируется как ее <strong>предварительное объявление</strong>. Оно
полезно, когда функция еще окончательно не реализована, но знание ее сигнатуры необходимо в других функциях, например, при наличии рекурсивных вызовов. Следует отметить, что окончательное определение функции, включающее ее тело должно быть сформировано до момента сборки программы.</p>
<p>Под программой понимается функция, которая связана с совокупность полностью определенных и взаимосвязанных функций, обеспечивающих решение поставленной задачи.</p>
<div class="section" id="id45">
<h3><span class="section-number">3.11.1. </span>Перегрузка имен функций<a class="headerlink" href="#id45" title="Ссылка на этот заголовок">¶</a></h3>
<p>В языке поддерживается статический полиморфизм, реализуемый за счет перегрузки имен функций. Это предполагает идентификацию функций по уникальности сигнатуры, состоящей из имени функции, типа аргумента и типа результата. В целом для идентификации функции используются только ее имя и тип аргумента, так как запрещается использовать функции у которых эти два параметра совпадают.</p>
</div>
<div class="section" id="id46">
<h3><span class="section-number">3.11.2. </span>Определение спецзнаков в качестве имен функций<a class="headerlink" href="#id46" title="Ссылка на этот заголовок">¶</a></h3>
<p>Специальные знаки могут использоваться в качестве имен функций за счет их специального обозначения, имеющего следующий формат:</p>
<p><strong>СпециальноеИмя = «:» Спецзнак.</strong></p>
<p>Допускается также перегрузка функций, обозначенных специальными именами.</p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>То есть в языке предполагается допускать пользовательскую перегрузку спецсимволов, не противоречащую их начальному определению на уровне языка. Использование двоеточия в качестве префикса возможно, так как оператор интерпретации перегружать запрещено по определению.</em></p>
<p><em>Данную возможность предполагается ввести позднее.</em></p>
</div>
</div>
<div class="section" id="id47">
<h3><span class="section-number">3.11.3. </span>Базовые (предопределенные) функции<a class="headerlink" href="#id47" title="Ссылка на этот заголовок">¶</a></h3>
<p>Базовые функции задаются их именами, являющимися зарезервированными словами и спецсимволами. Большинство этих функций могут выполняться во время компиляции константных выражений. Данные функции определяют основные операции, обеспечивающие, наряду с программо-формирующими операторами формирование структуры программы и выполнение предопределенных вычислений.</p>
</div>
</div>
<div class="section" id="id48">
<h2><span class="section-number">3.12. </span>Блок<a class="headerlink" href="#id48" title="Ссылка на этот заголовок">¶</a></h2>
<p><strong>Блок</strong> - это объединение элементов внутри тела функции, служит для логического соединения группы операторов выполняющих законченное действие, а также для локализации обозначений. Он начинается с ключевого слова <strong>block</strong>, за которым следует тело блока, аналогичное телу функции. Отличие тела блока заключается в том, что выход из него осуществляется по обозначению результата зарезервированным идентификатором <strong>break</strong>, с которым связывается значение, возвращаемое из блока. Данное ключевое слова (как и <strong>return</strong>) может выступать в качестве функции или обозначения.</p>
<p>Использование <strong>break</strong> в качестве функции:</p>
<p><code class="docutils literal notranslate"><span class="pre">результат:break</span></code> или <code class="docutils literal notranslate"><span class="pre">break^результат</span></code></p>
<p>Использование <strong>break</strong> в качестве обозначения:</p>
<p><code class="docutils literal notranslate"><span class="pre">результат</span> <span class="pre">&gt;&gt;</span> <span class="pre">break</span></code> или <code class="docutils literal notranslate"><span class="pre">break</span> <span class="pre">&lt;&lt;</span> <span class="pre">результат</span></code></p>
<p>Тип значения, возвращаемого из блока, должен быть известен компилятору и определяется из анализа элементов, входящих в блок или явно задается программистом.</p>
<p><strong>Блок = «block» «{» [ Элемент {«;» Элемент }] «}».</strong></p>
</div>
<div class="section" id="id49">
<h2><span class="section-number">3.13. </span>Выражение<a class="headerlink" href="#id49" title="Ссылка на этот заголовок">¶</a></h2>
<p><strong>Выражение</strong> - это терм или цепочка термов, связанных между собой операторами интерпретации. Под термом понимается артефакт, блок или имя ранее обозначенного элемента. Наличие операции интерпретации позволяет трактовать два ее операнда как функцию и аргумент. Существуют префиксная и постфиксная формы записи оператора интерпретации, отличающиеся друг от друга только порядком следования аргумента и функции. Префиксный оператор интерпретации задается стрелкой вверх <strong>«^»</strong> или двойной стрелкой <strong>^^</strong>,
слева от которой стоит терм, выступающий в роли функции, а справа - аргумент:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">F</span><span class="o">^</span><span class="n">X</span>
<span class="n">Q</span><span class="o">^^</span><span class="n">Y</span>
</pre></div>
</div>
<p>При постфиксной записи эти же выражения будут выглядеть следующим образом:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span><span class="p">:</span><span class="n">F</span>
<span class="n">Y</span><span class="p">::</span><span class="n">Q</span>
</pre></div>
</div>
<p>В том случае, если оператор интерпретации возвращает ошибку, выполнение текущей функции прекращается. Ошибка порождает соответствующие системные сообщения и инициирует прерывание выполнения программы.</p>
<p><strong>выражение = терм {( «^» выражение | «:» терм )}.</strong></p>
<p><strong>терм = артефакт | блок | идентификатор.</strong></p>
<p>Приведенный синтаксис выражения показывает, что префиксный оператор интерпретации выполняется справа налево, а постфиксный слева направо. Изменение приоритетов можно осуществить использованием блоков, а также фигурных, квадратных или круглых скобок, являющихся операторами группировки в составные конструкции, и, следовательно, формирователями новых промежуточных артефактов.</p>
</div>
<div class="section" id="id50">
<h2><span class="section-number">3.14. </span>Структура программы<a class="headerlink" href="#id50" title="Ссылка на этот заголовок">¶</a></h2>
<p>Программа состоит из множества программных артефактов, взаимосвязанных между собой по контексту, наполнение которого определяется стартовой функцией. Эта функция запускается в начале выполнения программы и содержит вызовы других функций, использует различные типы данных и константы. Исходя из этого совокупность всех артефактов, доступных из стартовой функции и определяет общую структуру программы.</p>
<p>Следует отметить, что все артефакты являются независимыми программными объектами. Они описываются и формируются независимо друг от друга и хранятся в виде отдельных сущностей в общей таблице исходных текстов артефактов. При компиляции для каждого из артефактов формируется его промежуточное представление, которое заносится в общую таблицу этих представлений, называемой таблицей реверсивных информационных графов (РИГ). Также в ходе компиляции создается описание артефакта, определяющее его интерфейс, необходимый для взаимодействия с другими артефактами. Это описание добавляется в таблицу экспорта общей базы данных артефактов, образующей пакет (репозиторий) артефактов.</p>
<p>Разработка программного обеспечения заключается в создании одного или нескольких пакетов, образующих приложение и (или) библиотеки функций. Пакеты могут размещаться на различных системах, включая удаленные. Доступ к внешним пакетам осуществляется через директивы импорта.</p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>Пока удовлетворюсь этим описанием, которого явно мало.</em></p>
</div>
<p>Программа содержит множество описаний, каждое из которых обозначено некоторым именем.</p>
<dl class="simple">
<dt><strong>обозначенное_описание = {/ идентификатор «&lt;&lt;» /}</strong></dt><dd><dl class="simple">
<dt><strong>описание {«&gt;&gt;»идентификатор}</strong></dt><dd><p><strong>| [описание»&gt;&gt;»] идентификатор {/ «&gt;&gt;» идентификатор /}.</strong></p>
</dd>
</dl>
</dd>
</dl>
<p><strong>$ описание = функция | константное_выражение | описание_типа.</strong></p>
<p><strong>Константное выражение</strong> - это любой артефакт языка, вычисляемый на этапе
компиляции, и используемый в последующих выражениях как атомарная константа, вектор или группа, атомами которых на самом нижнем уровне вложенности являются константы:</p>
<p><strong>константное_выражение = [«const»] значение_константы.</strong></p>
<p><strong>значение_константы = целое | булевское | «!».</strong></p>
<p>Пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pi</span> <span class="o">&lt;&lt;</span> <span class="n">const</span> <span class="mf">3.14</span>
</pre></div>
</div>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Оглавление</a></h3>
  <ul>
<li><a class="reference internal" href="#">3. Язык программирования Smile. Предварительное описание</a><ul>
<li><a class="reference internal" href="#id1">3.1. Общие соображения</a></li>
<li><a class="reference internal" href="#id2">3.2. Введение</a></li>
<li><a class="reference internal" href="#id3">3.3. Используемый метаязык</a></li>
<li><a class="reference internal" href="#id4">3.4. Элементарные конструкции</a><ul>
<li><a class="reference internal" href="#id5">3.4.1. Разделители</a></li>
<li><a class="reference internal" href="#id6">3.4.2. Комментарии</a></li>
<li><a class="reference internal" href="#id7">3.4.3. Идентификаторы</a></li>
<li><a class="reference internal" href="#id8">3.4.4. Зарезервированные слова</a></li>
<li><a class="reference internal" href="#id9">3.4.5. Специальные знаки</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id10">3.5. Обозначения</a></li>
<li><a class="reference internal" href="#id11">3.6. Артефакты</a><ul>
<li><a class="reference internal" href="#id12">3.6.1. Типы артефактов</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id13">3.7. Константы</a><ul>
<li><a class="reference internal" href="#id14">3.7.1. Сигнальная константа</a></li>
<li><a class="reference internal" href="#id15">3.7.2. Целая константа</a></li>
<li><a class="reference internal" href="#id16">3.7.3. Логическая константа</a></li>
<li><a class="reference internal" href="#id17">3.7.4. Константы ошибок</a></li>
<li><a class="reference internal" href="#id18">3.7.5. Описание именованных констант</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id19">3.8. Описания типов</a><ul>
<li><a class="reference internal" href="#id20">3.8.1. Переименование типа</a></li>
<li><a class="reference internal" href="#id21">3.8.2. Конструирование типа</a></li>
<li><a class="reference internal" href="#id22">3.8.3. Предопределенные атомарные типы</a><ul>
<li><a class="reference internal" href="#id23">3.8.3.1. Сигнальный тип</a></li>
<li><a class="reference internal" href="#id24">3.8.3.2. Булевский тип</a></li>
<li><a class="reference internal" href="#id25">3.8.3.3. Целый тип</a></li>
<li><a class="reference internal" href="#id26">3.8.3.4. Ошибочный тип</a></li>
<li><a class="reference internal" href="#id27">3.8.3.5. Пустой тип</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id28">3.8.4. Составные типы</a><ul>
<li><a class="reference internal" href="#id29">3.8.4.1. Типовой тип</a></li>
<li><a class="reference internal" href="#id30">3.8.4.2. Тип Вектор</a></li>
<li><a class="reference internal" href="#id31">3.8.4.3. Тип Структура</a></li>
<li><a class="reference internal" href="#id32">3.8.4.4. Тип Кортеж</a></li>
<li><a class="reference internal" href="#id33">3.8.4.5. Тип Обобщение</a></li>
<li><a class="reference internal" href="#id34">3.8.4.6. Любой тип</a></li>
<li><a class="reference internal" href="#id35">3.8.4.7. Тип Рой</a></li>
<li><a class="reference internal" href="#id36">3.8.4.8. Тип Поток</a></li>
<li><a class="reference internal" href="#id37">3.8.4.9. Функциональный тип</a></li>
<li><a class="reference internal" href="#id38">3.8.4.10. Тип Ссылка</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id39">3.8.5. Преобразование (приведение) величин разных типов</a><ul>
<li><a class="reference internal" href="#id40">3.8.5.1. Статические преобразования типов во время компиляции</a></li>
<li><a class="reference internal" href="#id41">3.8.5.2. Преобразование между атомарными константами</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#id42">3.9. Данные (величины)</a></li>
<li><a class="reference internal" href="#id43">3.10. Операторы</a></li>
<li><a class="reference internal" href="#id44">3.11. Функция</a><ul>
<li><a class="reference internal" href="#id45">3.11.1. Перегрузка имен функций</a></li>
<li><a class="reference internal" href="#id46">3.11.2. Определение спецзнаков в качестве имен функций</a></li>
<li><a class="reference internal" href="#id47">3.11.3. Базовые (предопределенные) функции</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id48">3.12. Блок</a></li>
<li><a class="reference internal" href="#id49">3.13. Выражение</a></li>
<li><a class="reference internal" href="#id50">3.14. Структура программы</a></li>
</ul>
</li>
</ul>

  <h4>Предыдущий раздел</h4>
  <p class="topless"><a href="ModelReference.html"
                        title="предыдущая глава"><span class="section-number">2. </span>Статически типизированная модель модель функционально-потоковых параллельных вычислений</a></p>
  <h4>Следующий раздел</h4>
  <p class="topless"><a href="InterpSemantic.html"
                        title="следующая глава"><span class="section-number">4. </span>Семантика оператора интерпретации</a></p>
  <div role="note" aria-label="source link">
    <h3>Эта страница</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/SmileReference.rst.txt"
            rel="nofollow">Исходный текст</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Быстрый поиск</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Искать" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Навигация</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Алфавитный указатель"
             >указатель</a></li>
        <li class="right" >
          <a href="InterpSemantic.html" title="4. Семантика оператора интерпретации"
             >вперёд</a> |</li>
        <li class="right" >
          <a href="ModelReference.html" title="2. Статически типизированная модель модель функционально-потоковых параллельных вычислений"
             >назад</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">документация smile </a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">3. </span>Язык программирования Smile. Предварительное описание</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Alexander Legalov.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.5.2.
    </div>
  </body>
</html>
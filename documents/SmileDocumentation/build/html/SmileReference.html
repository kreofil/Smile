
<!DOCTYPE html>

<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"><meta content="Описание концепций, языковых и инструментальных средств функционально-потокового параллельного программирования." name="description" />
<meta content="парадигмы программирования, функционально-потоковое параллельное программирование" name="keywords" />

    <title>3. Язык программирования Smile. Предварительное описание &#8212; документация smile </title>
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script src="_static/translations.js"></script>
    <link rel="shortcut icon" href="_static/smile48.png"/>
    <link rel="index" title="Алфавитный указатель" href="genindex.html" />
    <link rel="search" title="Поиск" href="search.html" />
    <link rel="next" title="4. Синтаксис языка программирования Smile" href="SmileSyntaxRu.html" />
    <link rel="prev" title="2. Статически типизированная модель модель функционально-потоковых параллельных вычислений" href="ModelReference.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Навигация</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Алфавитный указатель"
             accesskey="I">указатель</a></li>
        <li class="right" >
          <a href="SmileSyntaxRu.html" title="4. Синтаксис языка программирования Smile"
             accesskey="N">вперёд</a> |</li>
        <li class="right" >
          <a href="ModelReference.html" title="2. Статически типизированная модель модель функционально-потоковых параллельных вычислений"
             accesskey="P">назад</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">документация smile </a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">3. </span>Язык программирования Smile. Предварительное описание</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="smile">
<h1><span class="section-number">3. </span>Язык программирования Smile. Предварительное описание<a class="headerlink" href="#smile" title="Ссылка на этот заголовок">¶</a></h1>
<div class="section" id="id1">
<h2><span class="section-number">3.1. </span>Общие соображения<a class="headerlink" href="#id1" title="Ссылка на этот заголовок">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>Предполагается, что данный текст, определяющий текущую концепцию документа, носит временный характер. В дальнейшем он будет убран при формировании окончательных версий выходных документов.</em></p>
<p>В рамках этого предварительного описания я хочу сформулировать свое видение языка функционально-потокового параллельного программирования Smile и инструментальных средств обеспечивающих его поддержку.</p>
<p>Проектируемый язык, как и язык программирования Пифагор, базируется на функционально-потоковой модели параллельных вычислений. Также от Пифагора заимствуются особенности синтаксиса. Однако смена названия говорит о том, что в данном случае не планируется обеспечить обратную совместимость. Предполагается активно использовать статическую типизацию. Но при этом оставить (возможно) динамическую типизацию определяемую пользователем. Скорее всего, динамическую типизацию, определяемую пользователем, реализованную в Пифагоре, будет сделана попытка заменить на ограниченную статическую типизацию, когда наряду с типом накладываются алгоритмические ограничения и проверки на значения, принимаемые данным типом (<em>динамически ограниченный статический тип?</em>).</p>
<p>Формируемый документ предназначен для всестороннего охвата как изменений, вносимых в первоначальную концепции языка функционально-потокового параллельного (ФПП) программирования, так и для объяснения причин, порождающих эти изменения. Поэтому  данный текст, наряду с конкретным описанием языка содержит множество дополнительных примечаний, поясняющих особенности как синтаксиса, так и семантики.</p>
<p>Эти пояснения предполагается вносить как по ходу формирования текста документа, так и в ходе разработки компилятора языка ФПП программирования Smile.</p>
</div>
</div>
<div class="section" id="id2">
<h2><span class="section-number">3.2. </span>Введение<a class="headerlink" href="#id2" title="Ссылка на этот заголовок">¶</a></h2>
<p>Язык функционально-потокового программирования Smile разрабатывается с учетом опыта, полученного при создания языка программирования Пифагор. Основным его отличием является использование статической системы типов, обеспечивающей более безопасное выполнение основных операций. Помимо этого предполагается, что должно улучшиться распределение памяти под данные, а также генерация кода в другие языки, ориентированные на описание параллельных вычислений с использованием традиционного императивного программирования.</p>
</div>
<div class="section" id="id3">
<h2><span class="section-number">3.3. </span>Используемый метаязык<a class="headerlink" href="#id3" title="Ссылка на этот заголовок">¶</a></h2>
<p>Для описания синтаксиса используются расширенные формы Бэкуса-Наура (<strong>РБНФ</strong>).
Квадратные скобки <strong>«[«</strong> и <strong>«]»</strong> означают, что заключенная в них сентенциальная форма
может отсутствовать, фигурные скобки <strong>«{«</strong> и <strong>«}»</strong> означают ее повторение (возможно, 0 раз),
а круглые скобки <strong>«(«</strong> и <strong>«)»</strong> используются для ограничения альтернативных конструкций.
Сочетание фигурных скобок и косой черты <strong>«{/»</strong> и <strong>«/}»</strong> используется для обозначения
повторения один и более раз. Нетерминальные символы изображаются словами,
выражающими их интуитивный смысл, написанными на русском языке и разделенными,
при необходимости, знаком подчеркивания <strong>«_»</strong>. Каждое правило оканчивается точкой <strong>«.»</strong>.
Терминальные символы изображаются словами, написанными строчными буквами
латинского алфавита (зарезервированные слова) или цепочками знаков, заключенными в
кавычки. Синтаксическим правилам предшествует знак <strong>«$»</strong> в начале строки. Левая часть
правила отделяется от правой знаком <strong>«:=»</strong>.</p>
</div>
<div class="section" id="id4">
<h2><span class="section-number">3.4. </span>Элементарные конструкции<a class="headerlink" href="#id4" title="Ссылка на этот заголовок">¶</a></h2>
<div class="section" id="id5">
<h3><span class="section-number">3.4.1. </span>Разделители<a class="headerlink" href="#id5" title="Ссылка на этот заголовок">¶</a></h3>
<p>Пробелы, символы табуляции, перевода на новую строку и перевода страницы
используются как разделители. Вместо одного из таких символов может использоваться
любое их количество. Все другие управляющие символы употреблять в тексте программы
запрещено.</p>
</div>
<div class="section" id="id6">
<h3><span class="section-number">3.4.2. </span>Комментарии<a class="headerlink" href="#id6" title="Ссылка на этот заголовок">¶</a></h3>
<p>Многострочные комментарии начинаются парой символов «/<em>» и заканчиваются
парой символов «</em>/». Разрешены везде, где возможны разделители. Вложенность
многострочных комментариев не допускается.</p>
<p>Примеры:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">Многострочный</span> <span class="n">комментарий</span> <span class="n">в</span> <span class="n">одной</span> <span class="n">строке</span> <span class="o">*/</span>
<span class="o">/*</span>
 <span class="o">*</span> <span class="n">Многострочный</span> <span class="n">комментарий</span><span class="p">,</span>
 <span class="o">*</span> <span class="n">размещенный</span> <span class="n">в</span> <span class="n">нескольких</span> <span class="n">строках</span>
 <span class="o">*/</span>
</pre></div>
</div>
<p>В языке также допускаются однострочные комментарии. Они начинаются парой
символов <strong>«//»</strong> и заканчиваются признаком конца строки. Однострочные комментарии могут начинаться с самого начала строки или стоять после операторов, написанных в этой строке.</p>
<p>Пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Однострочный</span> <span class="n">комментарий</span>
</pre></div>
</div>
<p><strong>$ комментарий := «/*» {знак} «*/» | «//» {знак}.</strong></p>
</div>
<div class="section" id="id7">
<h3><span class="section-number">3.4.3. </span>Идентификаторы<a class="headerlink" href="#id7" title="Ссылка на этот заголовок">¶</a></h3>
<p>Идентификаторы используются для обозначения имен констант, переменных,
функций и типов данных. Допустимые символы: цифры <strong>0-9</strong>, прописные и строчные буквы
латинского алфавита <strong>A-Z</strong>, <strong>a-z</strong>, символ подчеркивания <strong>«_»</strong>. Первый символ не является
цифрой. Идентификатор может быть произвольной длины. Прописные и строчные буквы
различаются.</p>
<p><strong>$ ид := (буква | «_»){буква|цифра|»_»}.</strong></p>
<p>Примеры:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">NAME1</span>
<span class="n">name1</span>
<span class="n">it_is_ID</span>
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h3><span class="section-number">3.4.4. </span>Зарезервированные слова<a class="headerlink" href="#id8" title="Ссылка на этот заголовок">¶</a></h3>
<p>Зарезервированные слова используются для ключевых слов встроенных типов данных,
предопределенных обозначений и функций. Ниже приведен общий их список:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">block</span>       <span class="k">break</span>       <span class="nb">bool</span>        <span class="n">char</span>        <span class="n">const</span>
<span class="n">group</span>       <span class="n">dup</span>         <span class="n">delay</span>       <span class="k">else</span>        <span class="n">error</span>
<span class="n">false</span>       <span class="nb">float</span>       <span class="n">func</span>        <span class="n">funcdef</span>     <span class="nb">int</span>
<span class="n">nil</span>         <span class="k">return</span>      <span class="n">signal</span>      <span class="n">true</span>
<span class="nb">type</span>        <span class="n">typedef</span>     <span class="n">vector</span>
</pre></div>
</div>
<p>Зарезервированные слова записываются строчными буквами.
Использовать их в качестве идентификаторов запрещено.</p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>Следует отметить, что в текущей версии языка отсутствует деление
зарезервированных слов по группам, что обычно связывается с природой их создания и
использования. Это объясняется простотой языка и нацеленностью текущей реализации на
сценарный вариант. Предполагается, что в последующих версиях произойдет более четкое
дробление, явно увязанное с особенностями реализации и использования.</em></p>
</div>
</div>
</div>
<div class="section" id="id9">
<h2><span class="section-number">3.5. </span>Обозначения<a class="headerlink" href="#id9" title="Ссылка на этот заголовок">¶</a></h2>
<p>В языке, построенном на основе принципа единственного использования вычислительных ресурсов в сочетании с принципом единственного присваивания, отсутствует
понятие переменной. Вместо него вводится понятие обозначения как идентификатора,
поставленного в соответствие с каким-либо программным фрагментом. В пределах
некоторой области видимости использование идентификатора в качестве обозначения
должно быть уникальным. Обозначение получает тип и величину (значение) сопоставленного элемента и может использоваться для дальнейшей передачи этих параметров в любую точку
программы, обеспечивая тем самым копирование объекта, полученного в ходе вычислений.
В языке определены два способа задания обозначений:</p>
<ul class="simple">
<li><p>префиксное, при котором знак идентификатор пишется слева от знака «&lt;&lt;», а определяемый объект справа;</p></li>
<li><p>постфиксное, когда слева от знака «&gt;&gt;» задается определяемый объект, а справа его идентификатор.</p></li>
</ul>
<dl class="simple">
<dt><strong>$ обозначение :=</strong></dt><dd><dl class="simple">
<dt><strong>идентификатор «&lt;&lt;» элемент |</strong></dt><dd><p><strong>элемент «&gt;&gt;» идентификатор.</strong></p>
</dd>
</dl>
</dd>
</dl>
<p>Под элементом понимается любой из объектов языка. Идентификатор элемента. Понятия
объекта, выражения и блока будут даны ниже.</p>
<dl class="simple">
<dt><strong>$ элемент :=</strong></dt><dd><dl class="simple">
<dt><strong>объект | выражение | блок |</strong></dt><dd><p><strong>обозначение | идентификатор.</strong></p>
</dd>
</dl>
</dd>
</dl>
<p>Примеры:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">&lt;&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">Pi</span> <span class="o">&lt;&lt;</span> <span class="mf">3.1415</span><span class="p">;</span> <span class="mi">10</span> <span class="o">&gt;&gt;</span> <span class="n">ten</span><span class="p">;</span>
<span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span><span class="o">+</span> <span class="o">&gt;&gt;</span> <span class="nb">sum</span><span class="p">;</span> <span class="n">x0</span> <span class="o">&lt;&lt;</span> <span class="n">y0</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>Следует отметить, что в данном языке все-таки появится присваивание, которое будет функционировать по принципу единственного присваивания. Это обусловлено тем, что при введении статической типизации появляются контейнерные объекты заданной размерности, в которые можно вводить данные, руководствуясь этими размерами. Также возможно появление аналогов структур (записей), имеющих поля с локальным именованием. В этих случаях тоже удобнее заносить данные внутрь этих конструкций путем единственного присваивания. Это же касается обобщений. Но обозначение все равно остается</em></p>
</div>
</div>
<div class="section" id="id10">
<h2><span class="section-number">3.6. </span>Объекты<a class="headerlink" href="#id10" title="Ссылка на этот заголовок">¶</a></h2>
<p>К объектам языка относятся конструкции, рассматриваемые при выполнении операций интерпретации как единое целое. Каждый объект характеризуется двойкой:</p>
<p><strong>&lt;тип, значение&gt;.</strong></p>
<p>При этом тип объекта задается с использованием статической типизации и определяется на этапе компиляции. Формат значения должен соответствовать установленному для него типу.</p>
<p>Объекты могут формироваться как до вычислений, так и в ходе их. Объект, сформированный до вычислений, является константой заранее предопределенного типа.</p>
<p><strong>$ объект := атом | список | функция.</strong></p>
<p>Существует неупорядоченное множество предопределенных типов, задаваемых соответствующими именами. Типы делятся на атомарные и составные. Атомарные типы и области их допустимых значений определяются аксиоматически. Составные типы являются комбинацией атомарных и уже существующих составных объектов. Они конструируются по заданным правилам. К составным объектам относятся описания функций и списки. Обозначения предопределенных
типов языка, используемые в данной версии, приведены в таблице.</p>
<table class="docutils align-default" id="id61">
<caption><span class="caption-text">Предопределенные типы</span><a class="headerlink" href="#id61" title="Постоянная ссылка на таблицу">¶</a></caption>
<colgroup>
<col style="width: 33%" />
<col style="width: 24%" />
<col style="width: 17%" />
<col style="width: 26%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Название типа</p></th>
<th class="head"><p>Обозначение типа</p></th>
<th class="head"><p>Организация</p></th>
<th class="head"><p>Значение</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>сигнал</strong></p></td>
<td><p>signal</p></td>
<td><p>атом</p></td>
<td><p>!</p></td>
</tr>
<tr class="row-odd"><td><p><strong>логический</strong></p></td>
<td><p>bool</p></td>
<td><p>атом</p></td>
<td><p>false или true</p></td>
</tr>
<tr class="row-even"><td><p><strong>целый</strong></p></td>
<td><p>int</p></td>
<td><p>атом</p></td>
<td><p>MinInt..MaxInt</p></td>
</tr>
<tr class="row-odd"><td><p><strong>вектор</strong></p></td>
<td><p>vector</p></td>
<td><p>составной</p></td>
<td><p>(&#64;T).size</p></td>
</tr>
<tr class="row-even"><td><p><strong>рой</strong></p></td>
<td><p>swarm</p></td>
<td><p>составной</p></td>
<td><p>[&#64;T].size</p></td>
</tr>
<tr class="row-odd"><td><p><strong>задержка</strong></p></td>
<td><p>delay</p></td>
<td><p>составной</p></td>
<td><p>{e&#64;T} =&gt; v&#64;T</p></td>
</tr>
<tr class="row-even"><td><p><strong>функция</strong></p></td>
<td><p>func</p></td>
<td><p>составной</p></td>
<td><p>&#64;T1 -&gt; &#64;T2</p></td>
</tr>
<tr class="row-odd"><td><p><strong>ошибка</strong></p></td>
<td><p>error</p></td>
<td><p>атом</p></td>
<td><p>enum of errors</p></td>
</tr>
<tr class="row-even"><td><p>действительный</p></td>
<td><p>float</p></td>
<td><p>атом</p></td>
<td><p>MinFloat..MaxFloat</p></td>
</tr>
<tr class="row-odd"><td><p>символьный</p></td>
<td><p>char</p></td>
<td><p>атом</p></td>
<td><p>символ UTF-8</p></td>
</tr>
<tr class="row-even"><td><p><em>список данных</em></p></td>
<td><p>datalist</p></td>
<td><p>составной</p></td>
<td><p>()</p></td>
</tr>
<tr class="row-odd"><td><p><em>параллельный список</em></p></td>
<td><p>parlist</p></td>
<td><p>составной</p></td>
<td><p>[]</p></td>
</tr>
<tr class="row-even"><td><p><em>задержанный список</em></p></td>
<td><p>delaylist</p></td>
<td><p>составной</p></td>
<td><p>{}</p></td>
</tr>
<tr class="row-odd"><td><p><em>спецзнаковый</em></p></td>
<td><p>spec (nil)</p></td>
<td><p>атом</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><em>базовая функция</em></p></td>
<td><p>func</p></td>
<td><p>атом</p></td>
<td><p>&#64;T1 -&gt; &#64;T2</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>В настоящее время реализован небольшой набор типов, позволяющий использовать язык для запланированных экспериментов. Расширение номенклатуры базовых типов планируется в дальнейших реализациях языка после отработки методов параллельной интерпретации и методов преобразования в параллельные программы для других архитектур.</em></p>
<p><em>На текущем этапе в качестве базовых типов предполагается использовать только сигналы, логические и целые, позволяющие сформировать общую структуру всех основных операторов и операций, обеспечивающих формирование основного каркаса функционально-потоковой параллельной программы.</em></p>
</div>
</div>
<div class="section" id="id11">
<h2><span class="section-number">3.7. </span>Сигнал<a class="headerlink" href="#id11" title="Ссылка на этот заголовок">¶</a></h2>
<p><strong>Сигнальный тип</strong> (или просто сигнал) отличается от других атомарных
типов тем, что не имеет конкретного значения и в динамике определяется только фактом своего появления. Для того, чтобы показать изначальное наличие сигнала, используется константа <strong>«!»</strong>. То есть, можно говорить о том, что сигнальный тип определяет только одну величину. Готовность величины сигнального типа определяется самим фактом появления атома.</p>
<p>Появление  сигнала качестве результата определяет сам факт срабатывания соответствующего оператора интерпретации. Использование сигналов позволяет, при необходимости, моделировать в функциональных программах явное управление вычислениями. Они также могут сигнализировать о завершении работы функции, не возвращающей параметры.</p>
<p>Любая функция, не имеющая аргументов, может быть запущена только при наличии сигнала в качестве аргумента операции интерпретации. Постоянно присутствие сигнала, определяющее
«моментальный» запуск, задается следующим выражением:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>!:F
</pre></div>
</div>
<p>Формат сигнала, определяющий его внутреннее строение:</p>
<p><strong>&lt;signal, !&gt;.</strong></p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>В Пифагоре значение сигнального типа обозначалось через точку («.»). В данном случае появилось желание выделить это значение более четко из основного текста, так как точка перегружена и другими контекстами, которы предполагается еще больше расширить. В частности за счет использования принципа единственного присваивания.</em></p>
</div>
</div>
<div class="section" id="id12">
<h2><span class="section-number">3.8. </span>Значащие величины (константы)<a class="headerlink" href="#id12" title="Ссылка на этот заголовок">¶</a></h2>
<p>Атомы данного вида обеспечивают задание различных величин. Величина принадлежит области ее допустимых значений, которая, в зависимости от типа, может задаваться одним из следующих способов: диапазоном, диапазоном и точностью, перечислением элементов упорядоченного множества, перечислением элементов неупорядоченного множества (если нет необходимости устанавливать между элементами отношение порядка), функцией. В настоящее время в языке реализованы следующие виды
констант: целые, действительные, булевские, символы, константы ошибок, специальные
знаки. Тип константы в программе определяется ее внешним видом, задаваемым
синтаксическими правилами.</p>
<p><strong>$ константа := целая | логическая | сигнальная | спецзнак .</strong></p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>В Пифагоре присутствует большее число констант. Вполне возможно, что в дальнейшем их состав тоже будет расширен. Однако пока не принято решение, каким образом это расширение будет происходить. Предполагается, что в основе системы будет лежать Праязык, порождающий дочерние языки, ориентированные на различные предметные области за счет введения новых типов данных и операций над ними. Задачей Праязыка является обеспечение программоформирующего каркаса для всех потомков.</em>
<em>Поэтому правило:</em></p>
<dl class="simple">
<dt><strong>$ константа := целая | действительная | символ |</strong></dt><dd><p><strong>логическая | строка | спецзнак .</strong></p>
</dd>
</dl>
<p><em>Пока законсервировано.</em></p>
<p><em>Помимо этого на данном этапе я предполаю создать версию языка, котора будет в основном поддерживать только формирование каркаса программы, описываемого моделью вычислений. То есть, речь идет о попытке выделить и создать Праязык, в котором будут присутствовать только минимально необходимые базовые функции. Далее будет интересно посмотреть, каким образом можно этот Праязык развивать в различных направлениях.</em></p>
</div>
<div class="section" id="id13">
<h3><span class="section-number">3.8.1. </span>Целая константа<a class="headerlink" href="#id13" title="Ссылка на этот заголовок">¶</a></h3>
<p><strong>Целая константа</strong> имеет предопределенный тип <strong>int</strong> и используется для представления данных в формате стандартного машинного слова, длина которого зависит от архитектуры ВС. В текущей версии языка
реализовано представление целых чисел только в десятичной системе счисления.</p>
<p><strong>$ целая := [ «+» | «-» ] {/цифра/}.</strong></p>
<p><strong>$ цифра := «0» | «1» | «2» | «3» | «4» | «5» | «6» | «7» | «8» | «9».</strong></p>
<p>Примеры:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">127</span>
<span class="mi">0127</span>
<span class="o">-</span><span class="mi">356</span>
<span class="o">+</span><span class="mi">10</span>
</pre></div>
</div>
<p>Предполагается, что в соответствии с внутренним машинным представлением целочисленные константы располагаются в диапазоне <strong>{MinInt, …, MaxInt}</strong>.</p>
<p>Например для 64-разрядной архитектуры в дополнительном коде это будет диапазон
от -2<sup>64</sup> до 2<sup>64</sup> - 1.</p>
</div>
<div class="section" id="id14">
<h3><span class="section-number">3.8.2. </span>Логическая константа<a class="headerlink" href="#id14" title="Ссылка на этот заголовок">¶</a></h3>
<p><strong>Логическая константа</strong> имеет предопределенный тип <strong>bool</strong> и может принимать значения «<strong>true</strong>» («истина») или  «<strong>false</strong>» («ложь»). Она задается соответствующими ключевыми словами.</p>
<p><strong>$ логическая := true | false.</strong></p>
<p>Для логических констант сохраняется отношение порядка:</p>
<p><strong>false &lt; true.</strong></p>
<p>Логическая константа имеет тип <strong>bool</strong></p>
</div>
<div class="section" id="id15">
<h3><span class="section-number">3.8.3. </span>Сигнальная константа<a class="headerlink" href="#id15" title="Ссылка на этот заголовок">¶</a></h3>
<p><strong>Сигнальная константа</strong> имеет предопределенный тип <strong>signal</strong> и может принимать только одно значение <strong>!</strong>, указывающее на произошедшее событие, не связанное с другими типами данных.</p>
</div>
<div class="section" id="id16">
<h3><span class="section-number">3.8.4. </span>Специальные знаки<a class="headerlink" href="#id16" title="Ссылка на этот заголовок">¶</a></h3>
<p><strong>Специальные знаки</strong> используются для задания предопределенных данных и
операций языка в зависимости от их местоположения относительно операции
интерпретации. Их смысл будет раскрыт при описании правил интерпретации. Эти
константы образуют неупорядоченное множество и используются в тексте программы как
разделители других конструкций.</p>
<p><strong>$ спецзнак :=</strong></p>
<blockquote>
<div><p><strong>«+» | «-» | «/» | «*» | «&lt;» | «&gt;» | «=» | «&gt;=» | «&lt;=» | «~=» | «=&gt;» | «-&gt;» |</strong></p>
<p><strong>«-&gt;» | «&lt;-» | «()» | «{}» | «[]» | «|» | «#» | «%» | «..» | «?» | «!».</strong></p>
</div></blockquote>
<p>Следует отметить, что ряд специальных знаков в настоящее время не используется и
зарезервирован для дальнейшего расширения языка.</p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>Перечисленный набор спецзнаков в дальнейшем может корректироваться. Также будет уточняться и их принадлежность к конкретному типу, что пока не описано. В целом предполагается, что большинство спецзнаков в контексте вычисления будут иметь функциональный тип (func). Вместе с тем, дуализм аргументов операции интерпретации может привести к тому, что ряд знаков будет интерпретироваться различным способом в зависимости от того, являются они данными или функциями в операторе интрепретации.</em></p>
</div>
</div>
<div class="section" id="id17">
<h3><span class="section-number">3.8.5. </span>Константы ошибок<a class="headerlink" href="#id17" title="Ссылка на этот заголовок">¶</a></h3>
<p><strong>Константы ошибок</strong> имеют тип <strong>error</strong> ииспользуются для отображения некорректных ситуаций,
возникающих в ходе вычислений. Величины этого типа могут обрабатываться наряду с
другими данными или как исключительные ситуации.</p>
<p>Область допустимых значений для констант ошибки задается неупорядоченным
множеством, которое в дальнейшем предполагается пополнять. В настоящий момент
выделяются следующие ошибки:</p>
<ul class="simple">
<li><p><strong>ERROR</strong> - неидентифицируемая ошибка;</p></li>
<li><p><strong>REALERROR</strong> - некорректное преобразование действительного числа;</p></li>
<li><p><strong>INTERROR</strong> - некорректное преобразование целого числа;</p></li>
<li><p><strong>ZERODIVIDE</strong> - деление на ноль;</p></li>
<li><p><strong>INTERPRERROR</strong> - ошибка операции интерпретации;</p></li>
<li><p><strong>BOUNDERROR</strong> - ошибка выхода за границы диапазона;</p></li>
<li><p><strong>BASEFUNCERROR</strong> – неправильное использование предопределенной функции.</p></li>
<li><p><strong>NOERROR</strong> - отсутствие ошибки</p></li>
</ul>
<p>Эти имена запрещается использовать в программе в другом контексте.</p>
<dl class="simple">
<dt><strong>$ константа_ошибки := ERROR | REALERROR | INTERROR | ZERODIVIDE |</strong></dt><dd><p><strong>| INTERPRERROR | BOUNDERROR | BASEFUNCERROR | NOERROR.</strong></p>
</dd>
</dl>
<p>Значени <strong>NOERROR</strong> формируется в том случае, если при получении  результата вычислений необходимо вместо конкретного значения ошибки вернуть информацию о том, что ошибка отсутствует.</p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>Предполагается, что по сравнению с Пифагором использование ошибок будет значительно переработано в сторону упрощения. Планируется, что каждая из констант ошибки будет являться отдельной функцией - обработчиком ошибки, предоставляющей информацию о типе ошибке и обеспечивающей обращение к системе для корректного завершения программы. На данном этапе не планируется введение системы обработки исключений. Хотя в дальнейшем такое развитие просматривается.</em>
<em>Возможно, что реализация обработки ошибок будет сделана по аналогии с тем, как это реализовано в языке программирования GO. То есть, вместо выбрасывания исключений, будет формироваться значение, возвращаемое в качестве одного из результатов.</em></p>
</div>
</div>
</div>
<div class="section" id="id18">
<h2><span class="section-number">3.9. </span>Типы<a class="headerlink" href="#id18" title="Ссылка на этот заголовок">¶</a></h2>
<p>Язык ориентирован на использование статической системы типов. Предполагается что каждый тип, используемый в программе (функции) должен иметь имя. Существуют предопределенные (базовые) типы и сконструированные типы (типы, определяемые пользователями). Среди предопределенных можно выделить атомарные и составные типы. Все сконструированные типы являются составными (по определению).</p>
<p><strong>тип := атомарный_тип | составной_тип | производный_тип.</strong></p>
<div class="section" id="id19">
<h3><span class="section-number">3.9.1. </span>Предопределенные атомарные типы<a class="headerlink" href="#id19" title="Ссылка на этот заголовок">¶</a></h3>
<p>К атомарным относятся следующие предопределенные типы:</p>
<blockquote>
<div><ul class="simple">
<li><p>сигнальный тип (<strong>signal</strong>);</p></li>
<li><p>булевский тип (<strong>bool</strong>);</p></li>
<li><p>целый тип (<strong>int</strong>);</p></li>
<li><p>типовой тип (<strong>type</strong>);</p></li>
<li><p>любой тип (<strong>any</strong>);</p></li>
<li><p>ошибочный тип (<strong>error</strong>).</p></li>
</ul>
</div></blockquote>
<p><strong>$ атомарный_тип := сигнальный | булевский | целый | функциональный | ошибочный.</strong></p>
<p><strong>$ сигнальный := signal.</strong></p>
<p><strong>$ булевский := bool.</strong></p>
<p><strong>$ целый := int.</strong></p>
<p><strong>$ функциональный := func.</strong></p>
<p><strong>$ типовой := type.</strong></p>
<p><strong>$ любой := any.</strong></p>
<p><strong>$ ошибочный := error.</strong></p>
<p><strong>Сигнальный тип</strong> обозначается ключевым словом «<strong>signal</strong>». Данные сигнального типа не имеют конкретных значений и определяют моменты появления управляющих воздействий, сигнализирующих о тех или иных ситуациях, возникающих в выполняемой функции. В принципе этом можно интерпретировать как то, что сигнальный тип может принимать только одно значение. Это значение связывается с константой «<strong>!</strong>».
По сути данные любого типа содержат сигнал, информирующий об их появлении. Отличие заключается в том, что все прочие данные имеют множество допустимых значений мощность которого больше единицы.</p>
<p><strong>Булевский тип</strong> обозначается ключевым словом «<strong>bool</strong>». Данные булевского типа принимают значения из множества булевских констант (<strong>true</strong>, <strong>false</strong>), мощность которого равна двум.</p>
<p><strong>Целый тип</strong> обозначается ключевым словом «<strong>int</strong>». Данные целого типа принимают значения из множества целочисленных констант, мощность которого определяется реализацией целых чисел в конкретной компьютерной архитектуре.</p>
<p><strong>Функциональный тип</strong> обозначается ключевым словом <strong>func</strong>. К этом типу относятся предопределенные функции, также называемые операциями языка и обозначаемые в основном спецсимволами. Для обозначения предопределенных функций также используются зарезервированные идентификаторы. Помимо этого к функциональному типу также относятся все функции, разрабатываемые программистом.</p>
<p><strong>Типовой тип (тип типа)</strong> обозначается ключевым словом <strong>type</strong>. Данные этого типа принимают значения из множества имен предопределенных типов и типов, созданных пользователем и используемым в текущей программе. По сути это некоторый перечислимый тип, значения которого расширяются по мере порождения пользователем новых именованных типов, определяемых через описания типов.</p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>Предполагается, что на текущем этапе данный тип реализовываться не будет информация о нем оставлена, чтобы не забыть обдумать его в дальнейших исследованиях.</em></p>
</div>
<p><strong>Любой тип</strong> обозначается ключевым словом <strong>any</strong>. Данные этого типа по сути являются вариантным обобщением для всех типов создаваемой программы от предопределенных до производных. По сути любой тип это двойка <strong>&lt;тип, значение&gt;</strong>, в которой хранимое значение определяется именем типа. Допускает приведение произвольных значений к данному типу с последующим возможным анализом имени типа полученного значения и соответствующим его выделением для выполнения необходимых операций.</p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>С другой стороны этот тип может рассматриваться как процедурно-параметрическое обобщение общего вида, формируемое автоматически сборкой имен типов в качестве признаков. То есть, можно будет создавать обработчики обобщений с использованием в качестве обобщающих аргументов тип</em> <strong>any</strong>.</p>
<p><em>Пока я обозначил этот тип. Более конкретный его анализ, включая полноту операций, планируется провести позднее. Также пока непонятно, стоит ли вообще вводить этот тип.</em></p>
</div>
<p><strong>Ошибочный тип</strong> обозначается ключевым словом «<strong>error</strong>». Данные ошибочного типа принимают значения из множества констант ошибок, которое задается путем перечисления видов ошибок, возможных в ходе выполнения функционально-потоковых параллельных программ. Данное множество может изменяться в ходе разработки системы функционально-потокового параллельного программирования.</p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>Следует отметить, что на текущий момент множество атомарных типов не включает ряд типов, которые традиционно присутствуют практически во всех других языках программирования. В частности, отсутствует тип, задающий числа с плавающей точкой. Предполагается, что ядро языка не будет ориентировано на типы данных, связанные с конкретными прикладными вычислениями. Также в нем будут отсутствовать функции, ориентированные на обработку этих типов. Добавление новых типов и функций планируется рассматривать как расширение ядра языка (Праязыка, Надязыка). При этом возможны различные варианты расширений, которые будут определять семейства проблемно-ориентировнных дочерних языков (языков - потомков), предназначенных для соответствующих предметных областей и параллельных вычислителей (в основном речь идет об ориентации на различные параллельные вычислительные архитектуры).</em></p>
</div>
</div>
<div class="section" id="id20">
<h3><span class="section-number">3.9.2. </span>Составные типы<a class="headerlink" href="#id20" title="Ссылка на этот заголовок">¶</a></h3>
<p><strong>Составные типы</strong> строятся на основе атомарных типов, а также уже сформированных составных типах. Они группируют используемые типы в контейнеры или выражения, обладающие определенными свойствами, что, в свою очередь, определяет семантику их использования в операторе интерпретации. К составным типам языка относятся:</p>
<blockquote>
<div><ul class="simple">
<li><p>вектор (<strong>vector</strong>);</p></li>
<li><p>массив (?) (<strong>array</strong>);</p></li>
<li><p>структура (<strong>struct</strong>);</p></li>
<li><p>кортеж (<strong>tuple</strong>);</p></li>
<li><p>обобщение (<strong>union</strong>);</p></li>
<li><p>рой (<strong>swarm</strong>);</p></li>
<li><p>поток (<strong>stream</strong>);</p></li>
<li><p>функция (<strong>func</strong>);</p></li>
<li><p>ссылка (<strong>ref</strong>).</p></li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>Использование статической типизации в целом значительно изменяет семантику языка. Затрагивает она и синтаксис. При формировании данного описания пока не делается разделение между моделью и языком. Это планируется сформировать позднее, осуществив необходимые переносы текста.</em></p>
</div>
<p>Тип <strong>Вектор</strong> (векторный тип) обозначается ключевым словом <strong>vector</strong>. Он обеспечивает группировку данных одного типа, готовность которого к выполнению определяется при поступлении всех его элементов.
Возможно формирование статических и динамических векторов. Длина статически определяемого вектора задается константным выражением, значение которого должно быть положительной целочисленной величиной используемой во время компиляции. Длина динамически порождаемого вектора вычисляется во время выполнения программы, но до начала его использования. Ее значение тоже должно являться положительным числом.</p>
<p>Элементы вектора задаются в виде списка значений, заключенных в круглые скобки:</p>
<blockquote>
<div><p>(элемент<sub>1</sub>, элемент<sub>2</sub>, … элемент<sub>N</sub>)</p>
</div></blockquote>
<p>Нумерация элементов, размещенных внутри вектора, начинается с единицы. Число N в данном случае определят длину вектора.  , так и круглые скобки.
Описание векторного типа всегда требует указание длины вектора константным выражением и задается с использованием следующего синтаксиса:</p>
<p><strong>Вектор = ИмяТипа «(» Длина «)»</strong></p>
<p><strong>Длина = ЦелочисленноеКонстантноеВыражение</strong></p>
<p>Примеры описания векторных типов:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">&lt;&lt;</span> <span class="nb">type</span> <span class="nb">int</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="n">B</span> <span class="o">&lt;&lt;</span> <span class="nb">type</span> <span class="nb">bool</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
</pre></div>
</div>
<p>Ключевое слово <strong>vector</strong> используется при проверки типа и приведении других типов данных к векторному типу (при наличии такой возможности).</p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p>Следует отметить, что одной из идей является использование многомерных массивов, задаваемых с использованием ключевого слова <strong>array</strong>. Это расширяет параллелизм на многомерные конструкции. Возможное их описание может быть представлено следующим синтаксисом:
Массив ::= ИмяТипа «(» Размерность «)»
Размерность ::= ЦелочисленноеКонстантноеВыражение
{ «,» ЦелочисленноеКонстантноеВыражение }</p>
<p>Примеры массивов:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">AA</span> <span class="o">&lt;&lt;</span> <span class="nb">type</span> <span class="nb">int</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">BB</span> <span class="o">&lt;&lt;</span> <span class="nb">type</span> <span class="nb">bool</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">)</span>
</pre></div>
</div>
<p>Однако пока мне непонятно, каким образом лучше реализовать массивы. Прямое решение не выглядит достаточно эффективным из-за проблем с использованием многоразмерных индексных выражений. В дальнейшем, как вариант, предполагается рассмотреть реализацию массивов в виде расширения векторов. То есть в виде некторой оболочки, которая добавляет индексы к вектору. Тогда для выбора любого элемента массива планируется преобразование его индексов к индексу вектора путем специальной операции <strong>index</strong>. Например: <cite>A:{index“(i,j,k)</cite>. Этот вариант видится мне более предпочтительным. Не смотря на то, что вектор уже не будет частным случаем массива, данный вариант позволяет рассматривать приведение массива к вектору и вектора к массиву…
На данном этапе реализацию многомерных массивов реализовывать не планируется.</p>
</div>
<p>Тип <strong>Структура</strong> (структурный тип) обеспечивает группировку разнотипных данных по аналогии со структурными типами различных языков программирования. Структура состоит из полей, каждое из которых имеет имя и тип. Описание структуры имеет следующий синтаксис:</p>
<p><strong>Структура = «(» ПолеСтруктуры { «,» ПолеСтруктуры } «)»</strong></p>
<dl class="simple">
<dt><strong>ПолеСтруктуры = ИмяПоля «&#64;» ИмяТипа</strong></dt><dd><p><strong>| «[» ИмяПоля { «,» ИмяПоля } «]» «&#64;» ИмяТипа</strong></p>
</dd>
</dl>
<p>Примеры структурных типов:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Triangle</span> <span class="o">&lt;&lt;</span> <span class="nb">type</span> <span class="p">(</span><span class="n">a</span><span class="nd">@int</span><span class="p">,</span> <span class="n">b</span> <span class="o">@</span> <span class="nb">int</span><span class="p">,</span> <span class="n">c</span> <span class="nd">@int</span><span class="p">)</span>
<span class="n">Rectangle</span> <span class="o">&lt;&lt;</span> <span class="nb">type</span> <span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">]</span><span class="nd">@int</span><span class="p">)</span>
</pre></div>
</div>
<p>Тип <strong>Кортеж</strong>, как и структура, предназначен для группирования неоднородных данных. Он отличается от структуры отсутствием именованных полей. По сути он похож на вектор, но может содержать разнотипные элементы. Обращение к элементам кортежа осуществляется по номеру поля (поля, как и в векторе, нумеруются, начиная с единицы). Для задания кортежей используется следующий синтаксис:</p>
<blockquote>
<div><p><strong>Кортеж = «(» ИмяТипа { «,» ИмяТипа } «)»</strong></p>
</div></blockquote>
<p>Примеры задания типов кортежей:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">С</span> <span class="o">&lt;&lt;</span> <span class="nb">type</span> <span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="n">В</span> <span class="o">&lt;&lt;</span> <span class="nb">type</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">signal</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p>По всей видимости допустимо преобразование вектора в кортеж, а также кортежа в вектор при условии, что все элементы кортежа имеют один тип. Также стоит обдумать допустимость преобразования в кортеж структуры с идентичными полями, а также соответствующее преобразование кортежа в структуру.</p>
</div>
<p>Тип <strong>Обобщение</strong> (обобщающий тип) во многом аналогичен по организации и использованию обобщениям, используемым в других языках. Основной его задачей является объединение воедино взаимоисключающих структур. Существуют различные подходы к организации обобщений, включая методы, поддерживающие полиморфизм. В языке предполагается использование процедурно-параметрических обобщений, обеспечивающих более гибкую поддержку эволюционного расширения программ по сравнению с другими подходами. Правила, определяющие синтаксис обобщений имеют следующий вид:</p>
<p><strong>Обобщение = «{» ПолеОбобщения { «,» ПолеОбобщения } «}»</strong></p>
<dl class="simple">
<dt><strong>ПолеОбобщения = ИмяТипа { «,» ИмяТипа }</strong></dt><dd><p><strong>| ИмяПризнака «&#64;» ИмяТипа</strong>
<strong>| «[» ИмяПризнака { «,» ИмяПризнака } «]» «&#64;» ИмяТипа</strong></p>
</dd>
</dl>
<p>Примеры описания обобщений:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Figure1</span> <span class="o">&lt;&lt;</span> <span class="nb">type</span> <span class="p">{</span><span class="n">Triangle</span><span class="p">,</span> <span class="n">Rectangle</span><span class="p">}</span>
<span class="n">Figure2</span> <span class="o">&lt;&lt;</span> <span class="nb">type</span> <span class="p">{</span><span class="n">trian</span><span class="nd">@Triangle</span><span class="p">,</span>
                <span class="n">rect</span><span class="nd">@Rectangle</span><span class="p">,</span>
                <span class="n">rhomb</span><span class="nd">@Rectangle</span><span class="p">}</span>
<span class="n">WeekDay</span> <span class="o">&lt;&lt;</span> <span class="nb">type</span><span class="p">{[</span><span class="n">Sun</span><span class="p">,</span><span class="n">Mon</span><span class="p">,</span><span class="n">Tue</span><span class="p">,</span><span class="n">Wen</span><span class="p">,</span><span class="n">Thu</span><span class="p">,</span><span class="n">Fri</span><span class="p">,</span><span class="n">Sat</span><span class="p">]</span><span class="nd">@signal</span><span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p>Пока вопрос с обобщением и их использованием рассматривается на уровне мономорфизма. То есть, предполагается явный анализ признаков обобщения, аналогичный тому, как это делается с объединениями в Си и вариантными записями в Паскале. Применение процедурно-параметрического полиморфизма или других вариантов планируется только в следующих версиях.</p>
</div>
<p>Тип <strong>Рой</strong> (роевой тип) используется для описание независимых данных, над которыми возможно выполнение массовых параллельных операций. Обозначается ключевым словом <strong>swarm</strong>. Все элементы роя имеют один тип, а функция, осуществляющая их обработку, может одновременно выполняться над каждым элементом. Результатом является также рой, размерность которого равна размерности роя аргументов. Синтаксические правила, определяющие данный тип, имеют следующий вид:</p>
<p><strong>Рой = ИмяТипа «[» Целое «]»</strong></p>
<p>Пример описания типа:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">R</span> <span class="o">&lt;&lt;</span> <span class="nb">type</span> <span class="nb">int</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span>
</pre></div>
</div>
<p>Рой обеспечивает группировку данных одного типа в вектор, готовность которого к выполнению определяется при поступлении любого его элементов. В отличие от вектора функция, определяемая в операторе интерпретации, выполняется над каждым элементом роя, что обеспечивает неявное задание массового параллелизма. Запуск функции осуществляется асинхронно при появлении в группе очердного элемента. Полученный в ходе выполнения функции результат также асинхронно поступает дальше, если функция имеет возвращаемый тип, который является роем.</p>
<p>Возможно формирование роев фиксированной и переменной размерности, каждый из которых обладает своими свойствами и может обрабатываться своим множеством функций. Множества функций для обработки разных видов роев пересекаются, но не перекрываются. Элементы роя задаются в виде списка значений, заключенных в квадратные скобки:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>[элемент\ :sub:`1`, элемент\ :sub:`2`, ... элемент\ :sub:`N`]
</pre></div>
</div>
<p>Нумерация элементов, размещенных внутри роя, начинается с единицы. Число N в данном случае определят размер роя. Размер роя может быть задан константным выражением при описании его типа в том случае, если объявляется рой с фиксированной размерностью.</p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p>Как и для вектора пока предлагается только одномерное решение. Хотя есть соблазн разобраться и с реализацией многомерных роев. Но пока данный вопрос остается нерешенным.
Следует также отметить, что существует соблазн изменить правила использования роя в сторону упрощения по сравнению с параллельными списками Пифагора. В частности просматривается самый простой вариант, когда использование роя допускается только на самом верхнем уровне вложенности. Или, как более сложный вариант, не допускается непосредственное вложение роев друг в друга, а также функции, которые ведут к организации такого вложение.
Пример последнего: <cite>([…],[…]):[]</cite>. Пока предпочтительным смотрится более простой вариант.</p>
</div>
<p>Тип <strong>Поток</strong> является альтернативой асинхронному списку [10]. Он используется для обработки данных поступающих последовательно и асинхронно в произвольные промежутки времени. Размерность поступающих данных при этом неизвестна, поэтому завершение обработки возможно только по признаку конца потока. Поток готов к обработке при наличии в нем хотя бы одного элемента. Тип всех элементов потока одинаков. Синтаксические правила, определяющие поток:</p>
<p><strong>Поток = ИмяТипа «{» «}»</strong></p>
<p>Пример описания потокового типа:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">&lt;&lt;</span> <span class="nb">type</span> <span class="nb">int</span><span class="p">{}</span>
</pre></div>
</div>
<p>Тип <strong>Функция</strong> (или функциональный тип) позволяет задать сигнатуру функции, определяя имя типа, тип аргумента, а также тип результата. В целом определение функционального типа отличается от общепринятых в других языках программирования только тем, что любая функция имеет только один аргумент и возвращает только один результат. Синтаксические правила, определяющие описание функционального типа:</p>
<p><strong>ФункциональныйТип = func Аргумент «-&gt;» Результат</strong>
<strong>Аргумент = ИмяТипа | Кортеж</strong>
<strong>Результат = ИмяТипа | Кортеж</strong></p>
<p>Примеры описаний:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">F</span> <span class="o">&lt;&lt;</span> <span class="nb">type</span> <span class="n">func</span> <span class="nb">int</span> <span class="o">-&gt;</span> <span class="nb">int</span>
<span class="n">F2</span> <span class="o">&lt;&lt;</span> <span class="nb">type</span> <span class="n">func</span> <span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p>Возможны в перспективе варианты, когда функция возвращает вектор, массив, рой или поток. Но пока так глубоко копать не буду…
Интерес также представляет задание структуры в качестве типа. Но в данной ситуации предполагается, что использование кортежа обеспечивает структурную эквивалентность ипозволяет в дальнейшем подставлять любые структурно эквивалентные типы…</p>
</div>
<p>Тип <strong>Ссылка</strong> (или ссылочный тип) обеспечивает поддержку указателей на различные хранилища определенного типа, что позволяет передавать значения между функциями без их копирования. Основное назначение заключается в дополнительном контроле типов в ходе передач. Синтаксические правила, определяющие описание ссылочного типа:</p>
<p><strong>Ссылка = «&amp;» ИмяТипа</strong></p>
<p><strong>ОткрытыйВектор = ИмяТипа «(» «*» «)»</strong></p>
<p><strong>ОткрытыйМассив = ИмяТипа «(» «*» { «,» «*» } «)»</strong> (???)</p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p>Тоже пока вызывает много вопросов. Требует проработки…</p>
</div>
</div>
</div>
<div class="section" id="id21">
<h2><span class="section-number">3.10. </span>Описания типов<a class="headerlink" href="#id21" title="Ссылка на этот заголовок">¶</a></h2>
<p>Описания позволяют создавать новые именованные типы, определяя их через предопределенные типы или используя уже сформированные описания типов. Имя создаваемого типа задается идентификатором, который используется в качестве обозначения. Далее следует само описание, которое начинается с ключевого слова <strong>typedef</strong>.</p>
<p><strong>$ описание_типа = имя_нового_типа «&lt;&lt;» type тип.</strong></p>
<p>Основная идея заключается в создании новых типов, которые напрямую не наследуют свойства уже созданных типов, что позволяет применять в качестве конструирования переименование. В отличие от алиасов все операции исходного типа напрямую недоступны. Ипользовать их можно только после явного приведения созданного типа к типу предшественника. В связи с этим допускается использование предопределенных атомарных типов, имеющих имя, для построения новых типов. Например:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">apple</span> <span class="o">&lt;&lt;</span> <span class="nb">type</span> <span class="nb">int</span>
</pre></div>
</div>
<p>Создание новых типов на основе составных обеспечивает формирование именованных абстрактных типов данных с требуемыми полями и свойствами. Эти типы могут создаваться на основе любых составных типов и использоваться в различных манипуляциях, допускаемых над величинами, имеющими типовой тип. Например:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">intPair</span> <span class="o">&lt;&lt;</span> <span class="nb">type</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p>В данной версии языка предполагается, что будет использоваться только (или в основном) именованая эквивалентность типов. То есть, два типа будут считаться эквивалентными, если они имеют одинаковые имена. Это, на мой взгляд, обеспечит более строгий контроль типов и позволит проводить формальную верификацию программ в более широком диапазоне. Поэтому, в большинстве случаев перед сравнением типов необходимо будет осуществлять явное преобразование к нужному типу, если такое возможно в соответствии с используемым механизмоа преобразования (приведения) типов. Но без структурной эквивалентности в ряде случаев просто не обойтись. Поэтому данный вопрос требует детальной проработки…</p>
</div>
</div>
<div class="section" id="id22">
<h2><span class="section-number">3.11. </span>Преобразование (приведение) типов<a class="headerlink" href="#id22" title="Ссылка на этот заголовок">¶</a></h2>
<p>Механизм преобразования типов обеспечивает определенную гибкость в манипуляции абстракциями. Можно выделить статическое и динамическое преобразование типов. При статическом пробразовании типов этим процессом занимается компилятор. То есть, все возможные ошибки определяются на этапе компиляции. Динамическое приведение типов осуществляется во время выполнения программы и связано в основном с преобразованиями обобщений посредством функций преобразования типов, которые вводятся в язык для повышения гибкости. Описание этих функций будет сделано при рассмотрении оператора интерпретации.
Следует также отметить, что преобразования осуществляются не с самими типами а над величинами, имеющими некоторый тип, которые преобразуются к величинам другого типа.</p>
<div class="section" id="id23">
<h3><span class="section-number">3.11.1. </span>Статические преобразования типов во время компиляции<a class="headerlink" href="#id23" title="Ссылка на этот заголовок">¶</a></h3>
<p>Возможны следующие статические преобразования типов величин:</p>
<ol class="arabic simple">
<li><p>Тип любой величины может быть преобразован к сигнальному типу. При этом значение исходной величины теряется. По сути сигнальный тип является обобщением всех других типов, так как он несет только информацию (сигнал) о готовности данных.</p></li>
<li><p>Именованный тип любой величины может быть преобразован к типу <strong>any</strong>. В этом случае формируется структура, определяющая любой тип, которая хранит имя преобразуемого типа, а также сохраняет его значения. Дальнейшие манипуляции с полученной величиной, включая преобразование ее типа, могут проводиться только во время выполнения программы.</p></li>
<li><p>Именованный тип, сформированный определением типа в описании <strong>typedef</strong> на основе другого именованного типа, может быть преобразован к своему родительскому типу на этапе компиляции. При этом значение программного объекта не меняется. Данное приведение позволяет выполнять над имеющимся значением все операции над родительским типом.</p></li>
<li><p>Именованный родительский тип, используемый при определении нового типа в описании <strong>typedef</strong>, может быть преобразован к этому новому типу на этапе компиляции. При этом значение существующей величины не изменяется. Над преобразованной величиной возможны только функции, определенные над этим новым типом.</p></li>
<li><p>Формируемые в программе величины, имеющие структуру, эквивалентную некоторым именованным типам, могут быть преобразованы к этим типам на этапе компиляции.</p></li>
</ol>
<p>Представленные преобразования могут осуществляться как явно, так и неявно. Явные преобразования предполагают непосредственное использование функций приведения типов, обеспечивающих получение соответствующих новых типов. Например:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>6: apple                      int       ⇒ @apple
(3,4):intPair                 (@int).2  ⇒ @intPair
(1,2,3,4,5):signal            (@int).5  ⇒ @signal
</pre></div>
</div>
<p>Неявные преобразования связаны с использованием формируемых в программе величин в качестве аргументов функций, тип которых задается при их определении. Так как тип компилятору заранее известен, то в этом случае его преобразование будет однозначным. Например:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>func&#39;+&#39; &lt;&lt; funcdef x@intPair-&gt;@int {...}
(3,4):+     ⇒ (3,4):intPair:+
</pre></div>
</div>
<p>Последнее преобразование возможно только в том случае, если имеется однозначное определение функции. Возможно ситуация, когда имя функции перегружено, а ее уникальность определяется сигнатурой. В этой ситуации возможны функции с разной сигнатурой, аргументы которых имеют типы, созданные от одного родителя. Тогда невозможно определить, какую из функций подставить. В этой ситуации требуется явное приведение типа. Например:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">apple</span> <span class="o">&lt;&lt;</span> <span class="n">typedef</span> <span class="nb">int</span><span class="p">;</span>
<span class="n">pear</span>  <span class="o">&lt;&lt;</span> <span class="n">typedef</span> <span class="nb">int</span><span class="p">;</span>
<span class="n">f1</span> <span class="o">&lt;&lt;</span> <span class="n">funcdef</span> <span class="n">x</span><span class="nd">@apple</span><span class="o">-&gt;</span><span class="nd">@signal</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
<span class="n">f1</span> <span class="o">&lt;&lt;</span> <span class="n">funcdef</span> <span class="n">xpear</span><span class="o">-&gt;</span><span class="nd">@signal</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
<span class="mi">5</span><span class="p">:</span><span class="n">pear</span><span class="p">:</span><span class="n">f1</span>       <span class="o">--</span> <span class="n">явное</span> <span class="n">приведение</span> <span class="n">для</span> <span class="n">выбора</span> <span class="n">нужной</span> <span class="n">функции</span>
</pre></div>
</div>
</div>
<div class="section" id="id24">
<h3><span class="section-number">3.11.2. </span>Преобразование между атомарными константами<a class="headerlink" href="#id24" title="Ссылка на этот заголовок">¶</a></h3>
<p>Зачастую при использовании констант удобнее использовать неявные преобразования для восприятия написанного кода. В частности во многих языках программирования целочисленный ноль (0) в зависимости от контекста может восприниматься как действительное число (0.0).
Аналогичные неявные преобразования значений констант предполагается использовать и в разрабатываемом языке в тех случаях, когда контекст константы очевиден. В частности на данный момент просматриваются следующие неявные преобразования:</p>
<ol class="arabic simple">
<li><p>Для булевских величин вместо <strong>true</strong> и <strong>false</strong> допускается неявно использовать целочисленные константы <strong>0</strong> и <strong>1</strong> соответственно. Эту возможность предполагается использовать для разработки функций, реализующих булевские функции, которые впоследствии планируется транслировать в топологию ПЛИС. Удобнее в этом случае манипулировать числами, отображающими булевские значения. Преобразование осуществляется на этапе компиляции.</p></li>
</ol>
</div>
</div>
<div class="section" id="id25">
<h2><span class="section-number">3.12. </span>Функция<a class="headerlink" href="#id25" title="Ссылка на этот заголовок">¶</a></h2>
<p><strong>Функция</strong> – составной объект, конструируемый специальным образом. Она задается
определением, начинающимся с ключевого слова <strong>funcdef</strong>. Функция состоит из заголовка и тела.
В заголовке указывается идентификатор аргумента, обеспечивающего передачу в тело
функции необходимых данных и его тип, а также тип результата, возвращаемого из функции.
В теле описывается алгоритм обработки аргумента с применением соответствующих элементов языка. Доступ к исходным данным осуществляется только через аргумент. Тело функции состоит из элементов,
заключенных в фигурные скобки и разделяемых между собой символом <strong>«;»</strong>.</p>
<p>В ходе выполнения функции обычно формируется результат, который возвращается
после применения к нем функции возврата, обозначаемой зарезервированным идентификатором <strong>return</strong>:</p>
<p><code class="docutils literal notranslate"><span class="pre">результат:return</span></code> или <code class="docutils literal notranslate"><span class="pre">return^результат</span></code></p>
<p>Помимо этого ключевое слово <strong>return</strong> может использоваться в качестве альтернативного варианта точки возрата, когда оно задает не функию, а обозначение возвращаемого значения:</p>
<p><code class="docutils literal notranslate"><span class="pre">результат</span> <span class="pre">&gt;&gt;</span> <span class="pre">return</span></code> или <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">&lt;&lt;</span> <span class="pre">результат</span></code></p>
<p>Этот вариант предназначен для случаев, когда из функции необходимо возвратить величину задержанного типа.</p>
<p>Возвращаемый результат может быть любым допустимым значением, полученным в
ходе вычислений. Возврат результата может осуществляться до завершения выполнения всех
операций в теле функции, которая продолжает существования до завершения всех
внутренних операций. В этом случае в теле функции будет наблюдаться побочный эффект, который может быть связан либо с какими-то дополнительными фоновыми действиями, либо с ошибкой в ее реализации. Однако повторного возврата, в соответствии с принципом единственного присваивания, произойти не может.
Избавление от побочных эффектов, если они являются лишними, осуществляется путем анализа и оптимизации тела функции соостветствующими методами анализа.</p>
<p>В случае параллельного списка возможен асинхронный (не одновременный) возврат его независимых элементов. Также в качестве возвращаемого значения может выступать сигнал.</p>
<dl class="simple">
<dt><strong>$ функция := «funcdef» [ имя_аргумента «&#64;» имя_типа_аргумента ]</strong></dt><dd><p><strong>[«-&gt;» «&#64;» тип_результата] [тело_функции].</strong></p>
</dd>
</dl>
<p><strong>$ тело_функции := [ «{» [ элемент {«;» элемент }] «}» ].</strong></p>
<p>При отсутствии в определении функции аргумента предполагается, что он имеет сигнальный тип, использование которого в теле фунции не имеет смысла. Однако такой аргумент всегда присутствуе при вызове функции, определяя момент ее запуска. В этом случае сигнал может задаваться константой, указывая на немедленный запуск функции. Или же он может являться вычисляемым значением, что позволяет отложить запуск функции без параметров на некоторое время.</p>
<p>Тип возвращаемого значения также может не указываться. В этом случае предполагается что функция возращает сигнал. Также возврат сигнального значения может быть задан явно.</p>
<p>Отсутствие у функции тела интерпретируется как ее <strong>предварительное объявление</strong>. Оно
полезно, когда функция еще окончательно не реализована, но знание ее сигнатуры необходимо в других функциях, например, при наличии рекурсивных вызовов. Следует отметить, что окончательное определение функции, включающее ее тело должно быть сформировано до момента сборки программы.</p>
<p>Под программой понимается совокупность полностью определенных и взаимосвязанных функций, обеспечивающих решение поставленной задачи.</p>
<div class="section" id="id26">
<h3><span class="section-number">3.12.1. </span>Перегрузка имен функций<a class="headerlink" href="#id26" title="Ссылка на этот заголовок">¶</a></h3>
<p>В языке поддерживается статический полиморфизм, реализуемый за счет перегрузки имен функций. Это предполагает идентификацию функций по уникальности сигнатуры, состоящей из имени функции и типа аргумента.</p>
</div>
<div class="section" id="id27">
<h3><span class="section-number">3.12.2. </span>Определение спецзнаков в качестве имен функций<a class="headerlink" href="#id27" title="Ссылка на этот заголовок">¶</a></h3>
<p>Специальные знаки могут использоваться в качестве имен функций за счет их специального обозначения, имеющего следующий формат:</p>
<p><strong>$специальное_имя := funcdef «»» спецзнак «»».</strong></p>
<p>Допускается также перегрузка функций, обозначенных специальными именами.</p>
</div>
<div class="section" id="id28">
<h3><span class="section-number">3.12.3. </span>Базовые функции<a class="headerlink" href="#id28" title="Ссылка на этот заголовок">¶</a></h3>
<p>Базовые функции задаются их именами, являющимися зарезервированными словами и спецсимволами. Большинство этих функций могут выполняться во время компиляции константных выражений. Данные функции определяют основные программо-формирующие операции, обеспечивающие, наряду с программо-формирующими операторами формирование структуры программы.</p>
</div>
</div>
<div class="section" id="id29">
<h2><span class="section-number">3.13. </span>Блок<a class="headerlink" href="#id29" title="Ссылка на этот заголовок">¶</a></h2>
<p><strong>Блок</strong> - это объединение элементов внутри тела функции, служит для логического
соединения группы операторов выполняющих законченное действие, а также для
локализации обозначений. Он начинается с ключевого слова <strong>block</strong>, за которым следует тело
блока, аналогичное телу функции. Отличие тела блока заключается в том, что выход из
него осуществляется по обозначению результата зарезервированным идентификатором
<strong>break</strong>, с которым связывается значение, возвращаемое из блока. Данное ключевое слова (как и <strong>return</strong>) может выступать в качестве функции или обозначения.</p>
<p>Использование <strong>break</strong> в качестве функции:</p>
<p><code class="docutils literal notranslate"><span class="pre">результат:break</span></code> или <code class="docutils literal notranslate"><span class="pre">break^результат</span></code></p>
<p>Использование <strong>break</strong> в качестве обозначения:</p>
<p><code class="docutils literal notranslate"><span class="pre">результат</span> <span class="pre">&gt;&gt;</span> <span class="pre">break</span></code> или <code class="docutils literal notranslate"><span class="pre">break</span> <span class="pre">&lt;&lt;</span> <span class="pre">результат</span></code></p>
<p>Тип значения, возвращаемого из блока, должен быть известен компилятору и определяется из анализа элементов, входящих в блок или явно задается программистом.</p>
<p><strong>$ блок := «block» «{» [ элемент {«;» элемент }] «}».</strong></p>
</div>
<div class="section" id="id30">
<h2><span class="section-number">3.14. </span>Выражение<a class="headerlink" href="#id30" title="Ссылка на этот заголовок">¶</a></h2>
<p><strong>Выражение</strong> - это терм или цепочка термов, связанных между собой операциями
интерпретации. Под термом понимается объект, блок или
имя ранее обозначенного элемента. Наличие операции интерпретации позволяет трактовать
два ее операнда как функцию и аргумент. Существуют префиксная и постфиксная формы
записи операции интерпретации, отличающиеся друг от друга только порядком следования
аргумента и функции. Префиксная операция интерпретации задается стрелкой вверх <strong>«^»</strong>,
слева от которой стоит терм, выступающий в роли функции, а справа - аргумент: <strong>F^X</strong>. При
постфиксной записи это же выражение будет выглядеть следующим образом: <strong>X:F</strong>.
В том случае, если операция интерпретации возвращает ошибку, выполнение текущей функции прекращается. Ошибка порождает соответствующие системные сообщения и инициирует прекращение выполнения программы.</p>
<p><strong>$ выражение := терм {( «^» выражение | «:» терм )}.</strong></p>
<p><strong>$ терм := объект | блок | идентификатор.</strong></p>
<p>Приведенный синтаксис выражения показывает, что префиксная операция интерпретации выполняется справа налево, а постфиксная и обработка альтернатив слева направо. Изменение приоритетов можно осуществить использованием фигурных, квадратных или круглых скобок, являющихся операторами группировки, и,
следовательно, формирователями новых промежуточных объектов.</p>
</div>
<div class="section" id="id31">
<h2><span class="section-number">3.15. </span>Операторы<a class="headerlink" href="#id31" title="Ссылка на этот заголовок">¶</a></h2>
<p>Операторы языка определяются в соответствии с функционально-потоковой моделью вычислений. Они обеспечивают формирование каркаса функции. Выделяются операторы группировки и оператор интерпретации.</p>
<p><strong>Операторы группировки</strong> обеспечивают формирование значений составных типов. К ним относятся:</p>
<ul class="simple">
<li><p>оператор формирования вектора, обеспечивающий создание объектов векторного (<strong>vector</strong>) типа;</p></li>
<li><p>оператор формирования группы, обеспечивающий создание группового (<strong>group</strong>) типа;</p></li>
<li><p>оператор задержки, обеспечивающий создание задержанного (<strong>delay</strong>) типа.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p>Наряду с этими основными операторами нужно обратить внимание, что статическая типизация позволяет создавать составные типы с фиксированной структурой, доступ к элементам которых может обеспечиваться записью в отдельные поля с соблюдением принципа единственного присваивания.
Необходимо не забыть и описать соответствующие группы операторов для выше определенных типов данных с фиксированной структурой.</p>
</div>
<p><strong>Оператор интрепретации</strong> обеспечиваеь запись функциональных преобразований. Один из его входных параметров является функцией, а другой определяет аргумент, обрабатываемый этой функцией. Используются префиксная и постфиксаная формы оператора интрепретации.
В префиксной форме оператор обозначается знаком <strong>^</strong>. В этом случае функция <strong>F(x)</strong> будет записана ка <strong>F^x</strong>. Оператор интрепретации в постфиксной форме задется двоеточием (<strong>:</strong>), что позволяет записать приведенную функцию в виде <strong>x:F</strong>.</p>
</div>
<div class="section" id="id32">
<h2><span class="section-number">3.16. </span>Структура программы<a class="headerlink" href="#id32" title="Ссылка на этот заголовок">¶</a></h2>
<p>Программа состоит из множества программных объектов, взаимосвязанных между собой по контексту, наполнение которого определяется стартовой функцией. Эта функция запускается в начале выполнения программы и содержит вызовы других функций, использует различные типы данных и константы. Исходя из этого совокупность всех артефактов, доступных из стартовой функции и определяет общую структуру программы.</p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>Пока удовлетворюсь этим описанием, которого явно мало.</em></p>
</div>
<p>Программа содержит множество описаний, каждое из которых обозначено некоторым именем.</p>
<dl class="simple">
<dt><strong>$ обозначенное_описание := {/ идентификатор «&lt;&lt;» /}</strong></dt><dd><dl class="simple">
<dt><strong>описание {«&gt;&gt;»идентификатор}</strong></dt><dd><p><strong>| [описание»&gt;&gt;»] идентификатор {/ «&gt;&gt;» идентификатор /}.</strong></p>
</dd>
</dl>
</dd>
</dl>
<p><strong>$ описание := функция | const константное_выражение | описание_типа.</strong></p>
<p><strong>Константное выражение</strong> - это любой объект языка, вычисляемый на этапе
компиляции, и используемый в последующих выражениях как атомарная константа, вектор или группа, атомами которых на самом нижнем уровне вложенности являются константы.</p>
<p>Пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pi</span> <span class="o">&lt;&lt;</span> <span class="n">const</span> <span class="mf">3.14</span>
</pre></div>
</div>
</div>
<div class="section" id="id33">
<h2><span class="section-number">3.17. </span>Предопределенные функции и данные<a class="headerlink" href="#id33" title="Ссылка на этот заголовок">¶</a></h2>
<p><strong>Предопределенные функции и данные</strong> формируются на основе атомов, каждый из
которых может быть в роли как аргумента, так и функции оператора интерпретации. При этом ряд
атомарных объектов могут выступать только в роли данных, другие - в роли функций, третьи - в той и другой.</p>
<p>Большинство специальных знаков используются как предопределенные функции. Обычно за ними закрепляются вычислительные операции, традиционные для этих значков в большинстве существующих языков программирования. Задаются допустимые аргументы и значения этих функций. При этом типы аргумента и результата являются именованными типами и определяется аксиоматически при описании функции. Допускается перегрузка предопределенных функций.</p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>В данный момент я пытаюсь выделить подмножество предопределенных функций, предназначенных для формирования каркаса ФПП программы, характерного для Праязыка. В таком виде программа вряд ли может создаваться, так как минимальный набор манипуляций с данными (сравнения и т.д.) необходим даже для самого базового языка.</em></p>
<p><em>В рассматриваемой версии не все спецзнаки имеют определенную семантику. Предполагается, что в дальнейшем она будет разрабатываться и уточняться. Наряду со специальными знаками в качестве предопределенных функций могут выступать и идентификаторы, которые, как и ключевые слова, запрещены для других применений.</em></p>
</div>
<p>Ниже приводится описание семантики предопределенных функций, используемых в текущей версии. Следует отметить, что для аргументов, тип которых при описании не задан результатом будет ошибка: «неправильное использование предопределенных функций».</p>
<div class="section" id="id34">
<h3><span class="section-number">3.17.1. </span>Предопределенные базовые функции языка<a class="headerlink" href="#id34" title="Ссылка на этот заголовок">¶</a></h3>
<p>Предопределенные базовые функции обеспечивают формирование общего каркаса создаваемой функции. Они могут задаваться с использованием ряда спецсимволов, ключевыми словами, булевскими и целыми константами.</p>
<div class="section" id="id35">
<h4><span class="section-number">3.17.1.1. </span>Использование сигнальной константы «<strong>!</strong>»<a class="headerlink" href="#id35" title="Ссылка на этот заголовок">¶</a></h4>
<p>Данная функция имеет следующую сигнатуру:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span><span class="s2">&quot;!&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">funcdef</span> <span class="nd">@any</span> <span class="o">-&gt;</span> <span class="nd">@any</span>
</pre></div>
</div>
<p>Данный специальный знак зарезервирован для обозначения сигнальной константы, имеющий тип <strong>signal</strong>.
При использовании в качестве функции знак «<strong>!</strong>» интерпретируется как пустая операция, осуществляющая пропуск значения аргумента в качестве результата. То есть данном знаку можно сопоставить следующее определение функции:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span><span class="s2">&quot;!&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">funcdef</span> <span class="n">x</span><span class="nd">@any</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">&gt;&gt;</span><span class="k">return</span>
<span class="p">}</span>
</pre></div>
</div>
<p>То есть, если аргумент является вектором, группой или атомом, то происходит его выдача в качестве результата.
Если же аргумент определен как задержка, то преварительно оператор интерпретации осуществляет ее раскрытие, ведущее к вычислению задержанного выражения. Полученное значение передается функции, которая и возвращает его уже без дополнительных изменений.</p>
<p>Пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>{(2,3):+}:! ⇒ 5
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>Текст, размещенный в примечании подлежит пересмотру.</em></p>
<p>Использование этой операции позволяет получать из параллельного списка последовательный список данных (в соответствии с правилами эквивалентных преобразований):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>[2,3]:(!) ⇒ (2,3)
</pre></div>
</div>
</div>
<p>Использование сигнальной константы в качестве аргумента интерпретируюется как отсутствие аргумента.
Он может использоваться для формирования операции интерпретации тех функций, которые не получают аргументов.
Вместо этого <strong>«!»</strong> интерпретируется как сигнал, запускающий функцию в требуемый момент времени. Например, пусть будет задана функция:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sin_pi_div_4</span> <span class="o">&lt;&lt;</span> <span class="n">funcdef</span> <span class="o">-&gt;</span><span class="nd">@float</span> <span class="p">{</span>
    <span class="p">(</span><span class="mf">3.14</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">):</span><span class="o">/</span><span class="p">:</span><span class="n">sin</span> <span class="o">&gt;&gt;</span><span class="k">return</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Тогда ее вызов будет оформлен следующим образом:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>!:sin_pi_div_4
</pre></div>
</div>
</div>
<div class="section" id="id36">
<h4><span class="section-number">3.17.1.2. </span>Использование целых чисел в качестве функции<a class="headerlink" href="#id36" title="Ссылка на этот заголовок">¶</a></h4>
<p>Данная функция имеет следующую сигнатуру:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span><span class="s2">&quot;@int&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">funcdef</span> <span class="p">(</span><span class="nd">@any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nd">@any</span>
</pre></div>
</div>
<p>Целые положительные числа могут использоваться для выбора элементов из векторов. То есть они по сути могут выступать в качестве индексов. Целые отрицательные числа обеспечивают удаления из векторов элементов с индексом равным абсолютному значению индексирующего числа. То есть, после этой операции размер вектора уменьшается на единицу. Например:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(10, 9, 8, 7, 6, 5, 4, 3, 2, 1):5 ⇒ 6
(10, 9, 8, 7, 6, 5, 4, 3, 2, 1):-5 ⇒ (10, 9, 8, 7, 5, 4, 3, 2, 1)
</pre></div>
</div>
<p>В случае нулевого значения порождается ошибка <strong>BOUNDERROR</strong>, сигнализирующая о неправильном индексирующем значении.</p>
</div>
<div class="section" id="id37">
<h4><span class="section-number">3.17.1.3. </span>Использование булевских значений в качестве функций<a class="headerlink" href="#id37" title="Ссылка на этот заголовок">¶</a></h4>
<p>Функция, определяемая булевским значением, имеет следующую сигнатуру:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span><span class="s2">&quot;@bool&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">funcdef</span> <span class="p">(</span><span class="nd">@any</span><span class="p">)</span><span class="o">.</span><span class="mi">2</span> <span class="o">-&gt;</span> <span class="nd">@any</span>
</pre></div>
</div>
<p>Она осуществляет выбор первого или второго элемента двухэлементного вектора в зависимости от значения. Значение <code class="docutils literal notranslate"><span class="pre">`true`</span></code> обеспечивает выбор первого элемента вектора, а значение <code class="docutils literal notranslate"><span class="pre">`false`</span></code> - второго. Оба значения должны принадлежать одному и тому же типу. По сути это селектор значения, реализующий простейшее условие выбора. Например:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(10, 20):true  ⇒ 10
(10, 20):false ⇒ 20
</pre></div>
</div>
</div>
<div class="section" id="id38">
<h4><span class="section-number">3.17.1.4. </span>Использование знака «|»<a class="headerlink" href="#id38" title="Ссылка на этот заголовок">¶</a></h4>
<p>Данная функци имеет следующую сигнатуру:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span><span class="s2">&quot;|&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">funcdef</span> <span class="p">(</span><span class="nd">@any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nd">@int</span>
</pre></div>
</div>
<p>Знак <strong>«|»</strong> задает функцию нахождения длины списка. Аргумент – список данных любой
размерности и любого типа элементов. Результат – целое число, задающее количество
элементов в списке первого уровня вложенности.</p>
<p>Если аргумент не является списком, то результатом является ошибка операции интерпретации <strong>BASEFUNCERROR</strong>. Использование функции позволяет проверить размер аргумента перед обработкой, а лишь затем начать выделение его элементов.</p>
<p>Примеры:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(a, n, (q, w), s):| ⇒ 4
(1, 2, 3, 4, 5):| ⇒ 5
((1, 2, (f, d), x)):| ⇒ 1
</pre></div>
</div>
<p>Знак <strong>«|»</strong> в качестве аргумента имеет тип <strong>func</strong>.</p>
</div>
<div class="section" id="id39">
<h4><span class="section-number">3.17.1.5. </span>Функция «?»<a class="headerlink" href="#id39" title="Ссылка на этот заголовок">¶</a></h4>
<p>Данная функци имеет следующую сигнатуру:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span><span class="s2">&quot;?&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">funcdef</span> <span class="p">(</span><span class="nd">@bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="nd">@int</span><span class="p">]</span>
</pre></div>
</div>
<p>Она выполняет роль фильтра истинных значений, образуя из них группу, размер которой определяется количеством истинных значений в исходном векторе. Значения отдельных элементов результата равны порядковому номеру истинных значений в исходном списке. Например:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(true, false, true):? ⇒ [1, 2]
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>В качестве развития темы интерес представляет использование в качестве аргументов не только векторов, но и групп. Нужно будет подумать. В принципе отличие по использованию можно задать как раз за счет использования двойной интерпретации. Это же интересно продумать и для других вариантов, определяя тем самым асинхронную обработку данных вместо синхронизации.</em></p>
</div>
</div>
<div class="section" id="id40">
<h4><span class="section-number">3.17.1.6. </span>Использование знака «?»<a class="headerlink" href="#id40" title="Ссылка на этот заголовок">¶</a></h4>
<p>Функция <strong>«?»</strong>, осуществляет вычисление номеров позиций истинных булевских констант в булевском
списке данных. В качестве результата формируется параллельный целочисленный список с
номерами тех элементов списка аргументов, чьи значения были равны true. Функция
полезна для организации выборочного продолжения дальнейших вычислений.
Полученные целочисленные значения используются для выбора элементов из списков
данных. Например:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(true, false, true, false, false, true):? ⇒ [1, 3, 6]
</pre></div>
</div>
<p>Если список состоит только из ложных значений, на выходе формируется
пустой параллельный список, автоматически преобразуемый в ошибку базовой функции:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(false, false, false):? ⇒ [] ⇒ BASEFUNCERROR
</pre></div>
</div>
<p>Это позволяет непосредственно использовать результат проверки для выбора элементов списка. При пустом параллельном списке выбор из списка данных не происходит, а возвращается неопределенная ошибка:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(false, (7), 5):BASEFUNCERROR ⇒ ERROR
</pre></div>
</div>
<p>Поэтому идентификацию возврата функцией <strong>«?»</strong> корректного значения необходимо после ее выполнения. Знак <strong>«?»</strong> в качестве аргумента имеет тип <strong>spec</strong>.</p>
</div>
<div class="section" id="id41">
<h4><span class="section-number">3.17.1.7. </span>Использование знака «#»<a class="headerlink" href="#id41" title="Ссылка на этот заголовок">¶</a></h4>
<p>Знак <strong>«#»</strong> используется для задания функции транспонирования элементов списка подсписков.
Он аналогичен матрице, но отличается от последней тем, что количество элементов в разных
строках может отличаться. Результатом является транспонированный список подсписков, в
котором элементы первой строки будут состоять из первых элементов подстрок
обрабатываемой строки, вторая строка будет состоять из вторых элементов и т.д. В
результате транспонирования списка, состоящего из подсписков разной длины, происходит
перераспределение длины строк. Последние строки будут более короткими. Данная операция
в результате оказывается необратимой.</p>
<p>Пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">),(</span><span class="mi">8</span><span class="p">),(</span><span class="mi">9</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span><span class="c1"># ⇒ ((1,4,8,9),(2,5,0),(3,6),(7))</span>
<span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">),(</span><span class="mi">7</span><span class="p">)):</span><span class="c1"># ⇒ ((1,2,3,7),(4,5,6),(8,0),(9))</span>
</pre></div>
</div>
<p>Знак <strong>«#»</strong> в качестве аргумента имеет тип <strong>spec</strong>.</p>
</div>
<div class="section" id="id42">
<h4><span class="section-number">3.17.1.8. </span>Использование знака «()»<a class="headerlink" href="#id42" title="Ссылка на этот заголовок">¶</a></h4>
<p>Задает функцию охвата аргумента круглыми скобками. Аргумент – любой элемент. При использовании в качестве аргумента атома или списка данных операция <strong>«()»</strong> создает одноэлементные списки:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>атом:() ⇒ (атом)
(элемент, ... элемент):() ⇒ ((элемент, ... элемент))
</pre></div>
</div>
<p>Если в качестве аргумента вступает параллельный список, то операция группировки в
список выполняется над каждым из его элементов:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>[элемент, ... элемент]:() ⇒ [элемент:(), ... элемент:()]
</pre></div>
</div>
<p>Задержанный список перед выполнением данной функции как обычно раскрывается в
параллельный, а затем интерпретируется:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>{элемент, ... элемент}:() ⇒
    ⇒ [элемент, ... элемент]:() ⇒
    ⇒ [элемент:( ), ... элемент:()]
</pre></div>
</div>
<p>Знак <strong>«()»</strong> в качестве аргумента имеет тип <strong>spec</strong> и задает пустой список данных.</p>
</div>
<div class="section" id="id43">
<h4><span class="section-number">3.17.1.9. </span>Использование знака «[]»<a class="headerlink" href="#id43" title="Ссылка на этот заголовок">¶</a></h4>
<p>Задает функцию преобразования в параллельный список. Если аргумент является
списком данных, то он преобразуется в параллельный список путем преобразования
внешних круглых скобок в квадратные. Над атомами она выполняется как пустая операция:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>атом:[] ⇒ [атом] ⇒ атом
</pre></div>
</div>
<p>Если аргумент является списком данных, то он заменяется на параллельный список:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(элемент, ... элемент):[ ] ⇒ [элемент, ... элемент]
</pre></div>
</div>
<p>При аргументе, имеющим тип «параллельный список», функция выполняется над каждым из его элементов:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>[элемент, ... элемент]:[ ] ⇒ [элемент:[ ], ... элемент:[ ] ]
</pre></div>
</div>
<p>Такое же выполнение будет и при задержанном списке в качестве аргумента. Однако перед этим происходит раскрытие задержанного списка и вычисление каждого из его элементов:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>{элемент, ... элемент}:[ ] ⇒
    ⇒ [элемент, ... элемент]:[ ] ⇒
    ⇒ [элемент:[ ], ... элемент:[ ] ]
</pre></div>
</div>
<p>Знак <strong>«[]»</strong> в качестве аргумента имеет тип <strong>spec</strong>.</p>
</div>
<div class="section" id="id44">
<h4><span class="section-number">3.17.1.10. </span>Использование знака «{}»<a class="headerlink" href="#id44" title="Ссылка на этот заголовок">¶</a></h4>
<p>Использование функции формирования задержанного списка, задаваемой знаком <strong>«{}»</strong>,
позволяет создавать из других объектов задержанные списки:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>атом:{} ⇒ {атом}
(элемент, ... элемент):{} ⇒ {элемент, ... элемент}
[элемент, ... элемент]:{} ⇒ [элемент:{}, ... элемент:{}]
{элемент, ... элемент}:{} ⇒
    ⇒ [элемент, ... элемент]:{} ⇒
    ⇒ [элемент:{}, ... элемент:{}]
</pre></div>
</div>
<p>Знак <strong>«{}»</strong> в качестве аргумента имеет тип <strong>spec</strong>.</p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>В текущей версии интерпретатора генерируется «ошибка интерпретации». В целом пока непонятно, зачем нужна эта функция, так как создать задержанный список можно только в том случае, если в аргументах есть элементы, содержащие задержанные списки. Но в целом это не противоречит самой идее конструирования подобных программных объектов.</em></p>
</div>
</div>
<div class="section" id="id45">
<h4><span class="section-number">3.17.1.11. </span>Использование знака «..»<a class="headerlink" href="#id45" title="Ссылка на этот заголовок">¶</a></h4>
<p>Знак <strong>«..»</strong> используется в качестве функции, формирующей список данных из числовых
атомов. В качестве аргумента может выступать трехэлементный числовой список, в котором
первое число задает начало интервала, второе - его конец, а третье - шаг. Числа могут быть
как целые, так и действительные, а шаг принимать как положительные, так и отрицательные значения. Необходимо отсутствие расхождений между значением шага и границами
интервала.</p>
<p>Кроме этого аргумент функции может быть двухэлементным целочисленным списком.
В этом случае первый элемент определяет нижнюю целочисленную границу интервала, а
второй верхнюю. При этом нижняя граница должна быть меньше или равной верхней
границе, а шаг по умолчания принимается равным единице. При некорректном задании
границ интервала данная функция возвращает ошибку <strong>BOUNDERROR</strong>. Если некорректно
задана структура списка или тип его элементов, то возвращается ошибка предопределенной
функции <strong>BASEFUNCERROR</strong>.</p>
<p>Примеры:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(-3.5, 2.0, 1.5):.. ⇒ (-3.5, -2.0, -0.5, 1.0)
(1, 5):.. ⇒ (1, 2, 3, 4, 5)
(2, 1):.. ⇒ (BOUNDERROR, (2,1))
</pre></div>
</div>
<p>Знак <strong>«..»</strong> в качестве аргумента имеет тип <strong>spec</strong>.</p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>Пока, при неправильных границах возвращается ошибка интерпретации и выполнение завершается. В дальнейшем предполагается введение интервальных констант, задающих необходимый диапазон. Их использование позволит сформировать параллельный список на более поздних стадиях. Помимо этого предполагается, что в качестве результата этой функции будет возвращаться параллельный список.</em></p>
</div>
</div>
</div>
<div class="section" id="id46">
<h3><span class="section-number">3.17.2. </span>Использование данных<a class="headerlink" href="#id46" title="Ссылка на этот заголовок">¶</a></h3>
<p>Многие данные тоже могут допускать различное толкование в зависимости от того, в
какой части операции интерпретации они встретились.</p>
<div class="section" id="id47">
<h4><span class="section-number">3.17.2.1. </span>Использование целочисленной константы<a class="headerlink" href="#id47" title="Ссылка на этот заголовок">¶</a></h4>
<p>Целочисленная константа может интерпретироваться как функция выбора элемента из
списка. Аргумент – список любой размерности, содержащий элементы любого типа.
Результат зависит от значения константы.</p>
<p>Если константа является положительном числом в диапазоне от 1 до величины, равной
длине списка, то результат равен элементу из этого списка, порядковый номер которого
соответствует значению константы. Если значение константы превышает длину списка,
выдается ошибка <strong>BOUNDERROR</strong>, сигнализирующая о выходе за границу диапазона.</p>
<p>Целочисленная отрицательная константа интерпретируется как функция исключения
элемента из списка. Аргумент – список любой размерности и любого типа элементов.
Результат – список, полученный из аргумента путём удаления из него элемента, чей
порядковый номер соответствует абсолютному значению аргумента. Если абсолютное
значение константы превышает длину списка, выдается ошибка <strong>BOUNDERROR</strong>,
сигнализирующая о выходе за границу диапазона.</p>
<p>Нулевое значение константы интерпретируется как функция, осуществляющая возврат
в качестве результата пустого значения, обозначаемого <strong>«.»</strong>.</p>
<p>Примеры:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(234, 56.75, F, 3.14):2 ⇒ 56.75
(35, 23, 45, 76):[1, 3] ⇒ [35, 45]
(10, 9, 23, 43, 22):-4 ⇒ (10, 9, 23, 22)
(234, 56.75, F, 3.14):0 ⇒ .
</pre></div>
</div>
<p>Целочисленная константа в качестве аргумента имеет тип <strong>int</strong>.</p>
</div>
<div class="section" id="id48">
<h4><span class="section-number">3.17.2.2. </span>Использование булевской константы<a class="headerlink" href="#id48" title="Ссылка на этот заголовок">¶</a></h4>
<p>Булевские величины, при использовании в качестве функций, играют роль клапана.
Если значение селектора равно <strong>true</strong>, то аргумент выдается в качестве результата. При
значении равном <strong>false</strong> результатом является пустое значение. Подобная интерпретация
булевское величины позволяет в дальнейшем фильтровать результаты селекции с
использованием списка данных.</p>
<p>Примеры:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(x, y):true ⇒ (x, y)
(x, y):false ⇒ .
t: true ⇒ t
t:false ⇒ .
(1:true, 2: false) ⇒ (1, .) ⇒ (1)
(.):true ⇒ (.)
.:true ⇒ .
.:false ⇒ .
</pre></div>
</div>
<p>Булевская константа в качестве аргумента имеет тип <strong>bool</strong>.</p>
<p>Следует отметить, что предопределенное использование булевской константыкачестве селектора не позволяет непосредственно реализовать селекцию, аналогичную условному оператору. Однако существует несколько приемов, позволяющих решить эту задачу. Например, можно использовать дополнительные математические преобразованияцелое с вычитанием из двойки:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">expr1</span><span class="p">,</span><span class="n">expr2</span><span class="p">):[(</span><span class="mi">2</span><span class="p">,(</span><span class="n">x</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">:=</span><span class="p">:</span><span class="nb">int</span><span class="p">):</span><span class="o">-</span><span class="p">]</span>
</pre></div>
</div>
<p>Другим возможным вариантов является использование альтернативных условий,
которые после синхронизации в списке данных порождают необходимое выражение,
раскрываемое преобразованием в параллельный список:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">expr1</span><span class="o">:=</span><span class="p">,</span><span class="n">expr2</span><span class="p">:</span><span class="o">/=</span><span class="p">):[]</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id49">
<h3><span class="section-number">3.17.3. </span>Функции, расширяющие возможности языка<a class="headerlink" href="#id49" title="Ссылка на этот заголовок">¶</a></h3>
<div class="section" id="id50">
<h4><span class="section-number">3.17.3.1. </span>Слжение «<strong>+</strong>»<a class="headerlink" href="#id50" title="Ссылка на этот заголовок">¶</a></h4>
<p>Интерпретация знака <strong>«+»</strong> в качестве функции зависит от типа аргумента. Если
аргумент является двухэлементным списком числовых атомов (целых или действительных),
то выполняется арифметическое сложение. При сложении двух целых чисел результат
всегда является целым числом. В этом случае автоматическое преобразование к
действительному числу не происходит даже при переполнении, а выдается соответствующая
ошибка. Во всех остальных случаях осуществляется сложение действительных чисел с
преобразованием, в случае необходимости, целочисленного операнда к действительному.
Результатом в этом случае является действительное число.</p>
<p>Если аргумент является числовым атомом, то он выдается в качестве результата без
каких-либо преобразований.</p>
<p>Аргумент функции <strong>«+»</strong> может также быть булевским списком длиной, равной 2. Результатом интерпретации в этом случае является дизъюнкция (логическое «или») всех элементов списка. Допускается одноэлементный булевский список или булевский атом, порождающий в качестве результата значение этого элемента. Во всех остальных случаях результатом является ошибка операции интерпретации <strong>BASEFUNCERROR</strong>.</p>
<p>Знак <strong>«+»</strong> в качестве аргумента имеет тип <strong>spec</strong>.</p>
<p>Примеры сложения:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(3,5):+ ⇒ 8
(3,5.0):+ ⇒ 8.0
(5):+ ⇒ (BASEFUNCERROR, (5))
5:+ ⇒ 5
(max_integer,1):+ ⇒ (INTERROR, (max_integer,1))
(true, false, true):+ ⇒ true
true:+ ⇒ true
false:+ ⇒ false
(true):+ ⇒ true
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>Возможно, имеет смысл использовать для булевских операций другой символ или идентификатор. Например, or или «!». Это относится и к операциям, описанным ниже.</em></p>
</div>
</div>
<div class="section" id="id51">
<h4><span class="section-number">3.17.3.2. </span>Использование знака «-«<a class="headerlink" href="#id51" title="Ссылка на этот заголовок">¶</a></h4>
<p>Интерпретация знака <strong>«-«</strong> в качестве функции зависит от типа аргумента. Если
аргумент является двухэлементным списком числовых атомов (целых или действительных),
то выполняется арифметическое вычитание. При вычитании двух целых чисел результат
всегда является целым числом. В этом случае автоматическое преобразование к
действительному числу не происходит даже при переполнении, а выдается соответствующая
ошибка. Во всех остальных случаях осуществляется вычитание действительных чисел с
преобразованием, в случае необходимости, целочисленного операнда к действительному.
Результатом в этом случае является действительное число.</p>
<p>Если аргумент является числовым атомом, то выполняется операция «унарный минус»,
изменяющая знак числа.</p>
<p>Аргумент функции <strong>«-«</strong> может также быть непустым булевским списком длиной
большей или равной 2. Результатом интерпретации в этом случае является «исключающее
или» (сложение по модулю два) всех элементов списка. Допускается одноэлементный
булевский список, возвращающий в качестве результата отрицание элемента. Если аргумент
– булевский атом, то результат данной операции равен отрицанию значения аргумента.
Во всех остальных случаях результатом является ошибка операции интерпретации <strong>BASEFUNCERROR</strong>.
Знак <strong>«-«</strong> в качестве аргумента имеет тип spec.</p>
<p>Примеры:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(3,5):- ⇒ -2
(3,5.0):- ⇒ -2.0
(5):- ⇒ (BASEFUNCERROR, (5))
5:- ⇒ -5
(max_integer,-1):- ⇒ (INTERROR, (max_integer,-1))
(true,false,true):- ⇒ false
true:- ⇒ false
false:- ⇒ true
(true):- ⇒ false
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>Возможно, имеет смысл использовать для булевских операций другой символ или идентификатор. Например, xor или «~».</em></p>
</div>
</div>
<div class="section" id="id52">
<h4><span class="section-number">3.17.3.3. </span>Использование знака «*»<a class="headerlink" href="#id52" title="Ссылка на этот заголовок">¶</a></h4>
<p>Аргумент функции <strong>«*»</strong> может быть двухэлементным списком числовых атомов (целых
или действительных), а знак <strong>«*»</strong> интерпретируется как арифметическое умножение. При
умножении двух целых чисел результат всегда является целым числом. В этом случае
автоматическое преобразование к действительному числу не происходит даже при
переполнении, а выдается соответствующая ошибка. Во всех остальных случаях
осуществляется умножение действительных чисел с преобразованием, в случае
необходимости, целочисленного операнда к действительному. Результатом в этом случае
является действительное число.</p>
<p>Аргумент функции <strong>«*»</strong> может также быть булевским списком длиной, большей или
равной 2. Результатом интерпретации в этом случае является конъюнкция (логическое «и»)
всех элементов списка. Допускается одноэлементный список, возвращающий в качестве
результата значение этого элемента.</p>
<p>Если аргумент – булевский атом, то результат данной операции равен значению аргумента.</p>
<p>Во всех остальных случаях результатом является ошибка операции интерпретации BASEFUNCERROR.</p>
<p>Знак “*” в качестве аргумента имеет спецзнаковый тип.</p>
<p>Примеры:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(3,5):* ⇒ 15
13 из 22
(3,5.0):* ⇒ 15.0
(5):* ⇒ (BASEFUNCERROR, (5))
5:* ⇒ (BASEFUNCERROR, 5)
(max_integer, 2):* ⇒ INTERROR
(true, false, true):* ⇒ false
(true, true, true):* ⇒ true
true:* ⇒ true
(true):* ⇒ true
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>Возможно, имеет смысл использовать для булевских операций другой символ или идентификатор. Например, and или «&amp;».</em></p>
</div>
</div>
<div class="section" id="id53">
<h4><span class="section-number">3.17.3.4. </span>Использование знака «/»<a class="headerlink" href="#id53" title="Ссылка на этот заголовок">¶</a></h4>
<p>Аргумент функции должен быть двухэлементным списком числовых атомов (целых
или действительных), а знак <strong>«/»</strong> интерпретируется как арифметическое деление. При этом
результат всегда является действительным числом. При делении на ноль выдается ошибка ZERODIVIDE.
Во всех остальных случаях результатом является ошибка операции интерпретации (BASEFUNCERROR, (5)).</p>
<p>Знак “/” в качестве аргумента имеет тип spec.</p>
<p>Примеры деления:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(3,5):/ ⇒ 0.66667
(3,5.0):/ ⇒ 0.66667
(5):/ ⇒ (BASEFUNCERROR, (5))
5:/ ⇒ (BASEFUNCERROR, 5)
</pre></div>
</div>
</div>
<div class="section" id="id54">
<h4><span class="section-number">3.17.3.5. </span>Использование знака «%»<a class="headerlink" href="#id54" title="Ссылка на этот заголовок">¶</a></h4>
<p>Аргумент должен быть двухэлементным списком целочисленных атомов, а знак <strong>«%»</strong>
интерпретируется как целочисленное деление с формированием частного и остатка.
Результатом данной операции явится двухэлементный список целых констант, первая из
которых является целым частным элементов аргумента, а вторая – остатком от деления.
Используется «компьютерная» интерпретация результатов, при которой частное округляется
к нулю, а знак остатка равен знаку делимого. Операции связаны между собой следующими
выражениями:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="n">DIV</span> <span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span> <span class="n">MOD</span> <span class="n">y</span><span class="p">)</span>
<span class="mi">0</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">x</span> <span class="n">MOD</span> <span class="n">y</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">,</span> <span class="n">если</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="n">или</span>
<span class="mi">0</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">x</span> <span class="n">MOD</span> <span class="n">y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">,</span> <span class="n">если</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span>
</pre></div>
</div>
<p>При делении на ноль выдается ошибка ZERODIVIDE. Во всех остальных случаях
результатом является ошибка операции интерпретации BASEFUNCERROR.</p>
<p>Знак <strong>«%»</strong> в качестве аргумента имеет тип spec.</p>
<p>Примеры целочисленного деления:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(13,5): % ⇒ (2, 3)
(13,-5): % ⇒ (-2, 3)
(-13,5): % ⇒ (-2, -3)
(-13,-5): % ⇒ (2, -3)
</pre></div>
</div>
<p>Подобная трактовка отличается от математической, рассматриваемой, например в
первом томе книги Кнута [Кнут]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="n">DIV</span> <span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span> <span class="n">MOD</span> <span class="n">y</span><span class="p">)</span>
<span class="mi">0</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">x</span> <span class="n">MOD</span> <span class="n">y</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">,</span> <span class="n">если</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="n">или</span>
<span class="mi">0</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">x</span> <span class="n">MOD</span> <span class="n">y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">,</span> <span class="n">если</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Кстати, Кнут и не называет операцию MOD остатком. Получить математические
версии функции, использую предопределенную операцию можно следующим образом:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// функция целочисленного деления:
div &lt;&lt; funcdef x {
    dm&lt;&lt;x:%:1;
    [((dm,0):[&gt;=,&lt;]):?]^
    (
        dm,
        {(dm,1):-}
    ):. &gt;&gt;return
}

// функция выделения остатка от целочисленного деления:
mod &lt;&lt; funcdef x {
    dm&lt;&lt;x:%;
    [((dm:1,0):[&gt;=,&lt;]):?]^
    (
        dm:2,
        [((dm:2,0):[&gt;=,&lt;]):?]^
        (
            {(dm:2,1):-:-},
            {(dm:2,1):+:-}
        )
    ):. &gt;&gt;return
}
</pre></div>
</div>
</div>
<div class="section" id="id55">
<h4><span class="section-number">3.17.3.6. </span>Использование знаков: «=», «/=», «&lt;», «&lt;=», «&gt;», «&gt;=»<a class="headerlink" href="#id55" title="Ссылка на этот заголовок">¶</a></h4>
<p>Представленные знаки используются как функции сравнения аргументов, двухэлементного списка данных. Подобная интерпретация используется во многих языках программирования. Элементы списка должны быть сравнимы между собой. Если на множестве сравниваемых элементов определено отношение порядка, то могут использоваться любые функции. В противном случае допускается сравнение только на равенство (“=”) и неравенство (“!=”). Допускается сравнение между собой:</p>
<ul class="simple">
<li><p>Всех числовых данных (все операции);</p></li>
<li><p>Символов (все операции);</p></li>
<li><p>Булевских данных (все операции);</p></li>
<li><p>Спецсимволов (на равенство и неравенство);</p></li>
<li><p>Типов (на равенство и неравенство);</p></li>
<li><p>Функций (на равенство и неравенство).</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>Дальнейшие варианты предполагается уточнять в ходе последующих работ.</em></p>
</div>
<p>Знаки «=», «!=», «&lt;», «&lt;=», «&gt;», «&gt;=» в качестве аргумента имеют тип <strong>spec</strong>.</p>
</div>
</div>
<div class="section" id="id56">
<h3><span class="section-number">3.17.4. </span>Использование специальных функций<a class="headerlink" href="#id56" title="Ссылка на этот заголовок">¶</a></h3>
<div class="section" id="dup">
<h4><span class="section-number">3.17.4.1. </span>Использование функции «dup»<a class="headerlink" href="#dup" title="Ссылка на этот заголовок">¶</a></h4>
<p>Функция обеспечивает создания списка из одинаковых элементов путем дублирования.
Аргумент – двухэлементный список, первый элемент которого – любая допустимая в языке
конструкция, а второй – положительнгая целочисленная константа. Результат – список, элементами которого являются копии первого элемента аргумента, а количество элементов результирующего
списка равно значению второго элемента аргумента.</p>
<p>Пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(10, 5):dup ⇒ (10, 10, 10, 10, 10)
</pre></div>
</div>
<p>Функция <strong>dup</strong> в качестве аргумента имеет тип <strong>func</strong>.</p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>Скорее всего в новой версии данная функция будет возвращать параллельный список. Вполне возможно появятся константы, позволяющие компактно задать дубликат. Или в случае константного выражения возможно его развертывание во время компиляции.</em></p>
</div>
</div>
</div>
</div>
<div class="section" id="id57">
<h2><span class="section-number">3.18. </span>Использование предопределенных типов<a class="headerlink" href="#id57" title="Ссылка на этот заголовок">¶</a></h2>
<p>Механизм работы с типами, используемый в настоящее время, является традиционным для языков с динамической типизацией. Все предопределенные данные имеют признак (тег), задающий их тип. Значение размещается либо непосредственно за тегом или расположено в памяти и доступно через указатель на некоторую область памяти. Любая операция перед выполнением анализирует теги аргументов и в соответствии с этим интерпретирует значение. Формально объект данных можно представить в виде двойки:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Структура</span> <span class="n">элемента</span> <span class="o">=</span> <span class="p">(</span><span class="n">тип</span><span class="p">,</span> <span class="n">величина</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
<p>Наряду с обработкой данных, осуществляемой неявно, допускается выделять тип любого элемента данных. Для этого используется предопределенная операция type. Формируемая при этом величина принадлежит к «типовым» и имеет точно такую же организацию, как и любой другой аргумент. Ее специфика проявляется лишь в том, что типом аргумента является type.</p>
<blockquote>
<div><p>Структура типового элемента = (type, значение типа).</p>
</div></blockquote>
<p>Имена предопределенных типов также могут использоваться интерпретироваться в
качестве функций и данных. Если имена типов используются в качестве данных, то в роли
функций могут выступать сравнения, что позволяет сравнивать типы различных объектов и
проверять принадлежность некоторого объекта заданному типу. Для выделения типа
объекта используется предопределенная функция type, аргументом которой является объект,
а результатом – значение его типа.</p>
<p>Например:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>10:type ⇒ int
3.14:type ⇒ float
(1, 2, (4, 7)) :type ⇒ datalist
[1, 2, 3, (3, 4)] :type ⇒ [int, int, int, datalist]
{x, y, z}:type ⇒ [int,int,int]
</pre></div>
</div>
<p>Функция <strong>type</strong> в качестве аргумента имеет тип <strong>func</strong>. Следует отметить, что данная функция не определяет тип для параллельных и задержанных списков.</p>
<p>Применение функции <strong>type</strong> к «типовому» элементу невозможно и ведет к ошибке интерпретации <strong>TYPEERROR</strong>, например:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>int : type ⇒ TYPEERROR
</pre></div>
</div>
<p>Использование предопределенных типов в качестве функций позволяет осуществлять
преобразование объектов.</p>
<p>Функция <strong>int</strong> осуществляет преобразование к целочисленной величине действительных
символьных и булевых значений. Если аргумент является символом, то в качестве
результата преобразования берется значения кода символа в соответствии с используемой
таблицей кодировки. Если же аргумент - булева величина, то значение <strong>false</strong> преобразуется в
0, а <strong>true</strong> - в 1. Действительные числа преобразуются с округлением в соответствии с
общепринятыми математическими правилами. При невозможности преобразования
действительных чисел к целым возвращается ошибка целочисленного переполнения.</p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>В существующей версии интерпретатора действительные числа не округляются, а просто берется целая часть. Надо исправить! Или привести в соответствие с C++ (может так и есть).</em></p>
<p><em>Вместо ошибки для слишком больших чисел возвращается нулевое значение. Надо исправить!</em></p>
<p><em>Преобразование русских букв осуществляется некорректно! Они становятся отрицательными числами. Необходимо исправить!</em></p>
</div>
<p>Функция <strong>float</strong> (<strong>real</strong>) осуществляет аналогичные преобразования булевских, целых и
символьных величин к действительному значению.</p>
<p>Функция <strong>char</strong> обеспечивает перевод целых чисел в символы. Если значение целого
числа выходит за диапазон таблицы, то возвращается ошибка выхода за границы диапазона.</p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>Преобразование чисел осуществляется некорректно! Выход за границы диапазона не отлавливается. Допускаются отрицательные значения. В преобразовании участвуют и действительные числа. Необходимо исправить!</em></p>
</div>
<p>Функция <strong>bool</strong> преобразует целые и действительные числа в булевское значение.
Значение <strong>false</strong> формируется при аргументе, равном нулю, а значение <strong>true</strong> - при любом
отличном от нуля входном значении.</p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>Осуществляется преобразование символов, что вряд ли имеет смысл. Необходимо исправить!</em></p>
</div>
<p>Функция <strong>datalist</strong> является аналогом предопределенной функции <strong>«( )»</strong>.</p>
<p>Функция <strong>parlist</strong> является аналогом предопределенной функции <strong>«[ ]»</strong>.</p>
<p>Функция <strong>delaylist</strong> является аналогом предопределенной функции <strong>«{}»</strong>.</p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>delaylist, как и {}, отрабатывает некорректно. Необходимо разобраться с семантикой!</em></p>
</div>
<p>Функция <strong>signal</strong> преобразует любой вычисленный объект в сигнал (пустое значение).</p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>Должно формироваться пустое значение. Необходимо исправить!</em></p>
</div>
<p>Функция <strong>error</strong> в данной версии не интерпретируется.</p>
</div>
<div class="section" id="id58">
<h2><span class="section-number">3.19. </span>Пользовательские типы<a class="headerlink" href="#id58" title="Ссылка на этот заголовок">¶</a></h2>
<p>Инструментальная поддержка механизма динамически порождаемых пользовательских типов позволяет создавать аналоги абстрактных типов данных. Для этого используется дополнительных конструкций:</p>
<ol class="arabic simple">
<li><p>определение пользовательского типа;</p></li>
<li><p>сравнения пользовательских типов на равенство и неравенство;</p></li>
<li><p>проверка на принадлежность некоторого значения величине, допустимой для заданного пользовательского типа;</p></li>
<li><p>преобразование в пользовательский тип;</p></li>
<li><p>разыменование пользовательского типа.</p></li>
</ol>
<p>Определение пользовательского типа задается соответствующим предикатом, сопоставляющим проверяемый элемент некоторому выражению. Если результат проверки является истиной, то элемент принадлежит проверяемому типу. Предикат оформляетсявиде специальной функции <strong>typedef</strong>, возвращающей булевское значение. Ее обозначение регистрируется в таблице пользовательских типов.
В качестве примера можно рассмотреть, как задаются треугольник и круг:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Описание</span> <span class="n">пользовательского</span> <span class="n">типа</span><span class="p">,</span> <span class="n">задающего</span> <span class="n">треугольник</span> <span class="n">как</span>
<span class="o">//</span> <span class="n">трехэлементный</span> <span class="n">целочисленный</span> <span class="n">список</span>
<span class="n">Triangle</span> <span class="o">&lt;&lt;</span> <span class="n">typedef</span> <span class="n">X</span> <span class="p">{</span>
    <span class="p">[(((</span><span class="n">X</span><span class="p">:</span><span class="nb">type</span><span class="p">,</span><span class="n">datalist</span><span class="p">)</span><span class="o">:=</span><span class="p">,(</span><span class="n">X</span><span class="p">:</span><span class="o">|</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="o">:=</span><span class="p">):</span><span class="o">*</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span><span class="o">+</span><span class="p">]</span><span class="o">^</span>
    <span class="p">(</span>
        <span class="n">false</span><span class="p">,</span>
        <span class="p">{([(</span><span class="n">X</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span><span class="nb">type</span><span class="p">,</span><span class="nb">int</span><span class="p">),(</span><span class="n">X</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="nb">type</span><span class="p">,</span><span class="nb">int</span><span class="p">),(</span><span class="n">X</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span><span class="nb">type</span><span class="p">,</span><span class="nb">int</span><span class="p">)]</span><span class="o">:=</span><span class="p">):</span><span class="o">*</span><span class="p">}</span>
    <span class="p">):</span><span class="o">.</span>
    <span class="o">&gt;&gt;</span> <span class="k">return</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">Описание</span> <span class="n">пользовательского</span> <span class="n">типа</span><span class="p">,</span> <span class="n">задающего</span> <span class="n">круг</span> <span class="n">как</span>
<span class="o">//</span> <span class="n">целочисленный</span> <span class="n">атом</span>
<span class="n">Circle</span> <span class="o">&lt;&lt;</span> <span class="n">typedef</span> <span class="n">X</span>
<span class="n">typedef</span> <span class="n">X</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">X</span><span class="p">:</span><span class="nb">type</span><span class="p">,</span><span class="nb">int</span><span class="p">)</span><span class="o">:=</span> <span class="o">&gt;&gt;</span> <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Сравнение пользовательских типов</strong> осуществляется точно также как и сравнение базовых
типов языка: выделяется тип элемента функцией <strong>type</strong>, проверяется совпадение имен
выделенного и проверяемого типа. Результат сравнения является истиной при совпадении
имен типов. Ниже приводится пример использования сравнения пользовательских типов для
описания типа обобщенной геометрической фигуры.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Описание</span> <span class="n">фигуры</span><span class="p">,</span> <span class="n">являющейся</span> <span class="n">треугольником</span> <span class="n">или</span> <span class="n">кругом</span>
<span class="n">Figure</span> <span class="o">&lt;&lt;</span> <span class="n">typedef</span> <span class="n">X</span> <span class="p">{</span>
    <span class="o">//</span> <span class="n">Аргумент</span> <span class="o">-</span> <span class="n">треугольник</span> <span class="n">или</span> <span class="n">круг</span>
    <span class="n">X</span><span class="p">:</span><span class="nb">type</span> <span class="o">&gt;&gt;</span> <span class="n">t</span><span class="p">;</span>
    <span class="p">([(</span><span class="n">t</span><span class="p">,</span> <span class="n">Triangle</span><span class="p">),</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">Circle</span><span class="p">)]</span><span class="o">:=</span><span class="p">):</span><span class="o">+</span> <span class="o">&gt;&gt;</span> <span class="k">return</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p><strong>Проверка на принадлежность</strong> позволяет выяснить возможность соответствия между
динамически формируемыми данными и <strong>typedef</strong>. Для этого используется функция <strong>in</strong>,
которая возвращает значение, полученное в результате выполнения предиката, заданного в
описании пользовательского типа. Принадлежность позволяет в дальнейшем осуществить
преобразование проверяемого аргумента в элемент пользовательского типа. Ниже
представлены примеры использования функции принадлежности:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>((10,20,15),Triangle):in ⇒ true
((10,20,15),Circle):in ⇒ false
(10,Circle):in ⇒ true
</pre></div>
</div>
<p><strong>Преобразование в пользовательский тип</strong> используется для формирования требуемых
абстракций по принципу «обертки» преобразуемых данных. Является расширением
операции преобразования базовых типов. Суть заключается в получении нового значения
элемента, следующей структуры:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Элемент</span> <span class="n">пользовательского</span> <span class="n">типа</span> <span class="o">=</span> <span class="p">(</span><span class="n">пользовательский</span> <span class="n">тип</span><span class="p">,</span> <span class="n">преобразуемый</span> <span class="n">элемент</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
<p>Само преобразование задается указанием пользовательского типа в качестве функцииосуществляется в зависимости от значения аргумента:</p>
<ol class="arabic simple">
<li><p>если тип аргумента совпадает с типов в операции преобразования, то возвращается значение исходного аргумента;</p></li>
<li><p>преобразование осуществляется только в том случае, если проверка аргумента на принадлежность функцией <strong>in</strong>, осуществляемая неявно, дает «истину»;</p></li>
<li><p>во всех остальных случаях функция преобразования в пользовательский тип возвращает ошибку <strong>TYPEERROR</strong>.</p></li>
</ol>
<p>Использование данной операции позволяет формировать необходимые абстракции при
выполнении программы:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(10,20,15):Triangle ⇒ Треугольник со сторонами (10,20,15)
</pre></div>
</div>
<p>Описанная операция не обеспечивает автоматического преобразования пользовательских
типов друг в друга, даже если их значения принадлежать единому подмножеству. Данное
ограничение введено для более строгого контроля. Зачастую подобные преобразования
бывают необходимы. В этом случае можно воспользоваться разыменованием
пользовательского типа, заключающемся в выделении «обернутого» значение функцией
<strong>value</strong>. Данная функция «отбрасывает» пользовательский тип, тем самым «обезличивая»
преобразуемый элемент:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(10,20,15):Triangle:value ⇒ (10,20,15)
(10,20,15):Triangle:value:1:Circle ⇒ Круг радиусом 10
</pre></div>
</div>
<p>Попытка применить операцию разыменования к базовым типам ведет к генерации ошибки
<strong>VALUEERROR</strong>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>10:value ⇒ VALUEERROR
</pre></div>
</div>
</div>
<div class="section" id="id59">
<h2><span class="section-number">3.20. </span>Правила эквивалентных преобразований<a class="headerlink" href="#id59" title="Ссылка на этот заголовок">¶</a></h2>
<p>Правила эквивалентных преобразований уже рассматривались при описании модели
вычислений. Ниже они сведены воедино с учетом дополнительно введенных конструкций.</p>
<p>Cлияние параллельных списков в списке данных:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>([X1], [X2], ..., [Xn]) ≡ (X1, X2, ..., Xn) .
</pre></div>
</div>
<p>Эквивалентность параллельных списков набору их элементов:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>[x1, x2, ... xn] ≡ x1, x2, ... xn .
</pre></div>
</div>
<p>Интерпретация параллельных списков:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>[x1, ... xn]:[f1, ... fk] ≡
    ≡ x1:f1, ... x1:fk, ... xn:f1, ... xn:fk .
</pre></div>
</div>
<p>Как частные случаи можно рассмотреть ситуации, когда функция или аргумент являются атомами:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>[x1, x2,...xn]:f ≡ x1:f, x2:f, ... xn:f .

x:[f1, f2,...fk] ≡ x:f1, x:f2, ... x:fk .
</pre></div>
</div>
<p>Эквивалентность многократно вложенных задержанных списков:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>{{ X }} ≡ { X } .
</pre></div>
</div>
<p>Эквивалентность формирования списков данных:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>X:(F) ≡ (X:F) .
</pre></div>
</div>
<p>При пустом списке данных в качестве функции имеем:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>X:(.) ≡ (X) .
</pre></div>
</div>
<p>Эквивалентность пустого элемента и пустого параллельного списка:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>. ≡ [.]≡ {.} .
</pre></div>
</div>
<p>Данное правило определяет размножение альтернативной части операции
интерпретации, если его аргумент и функция являются параллельными списками. В этом
случае альтернатива приписывается каждой созданной операции интерпретации:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>[x1,...xn]:[f1,...fk] else Z ≡
    ≡ [x1:f1 else Z,...x1:fk else Z,...
        ...xn:f1 else Z,...xn:fk else Z]
</pre></div>
</div>
<p>Если список данных содержит пустой элемент <strong>«.»</strong>, то этот элемент исключается из
списка. При этом длина данного списка уменьшается на количество содержавшихся пустых
элементов.</p>
<p>Пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(x1, x2, ., ., x3) ≡ (x1, x2, x3)
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>В новой версии предполагается не убирать пустые элементы, планируется организовать на их основе событийную логику. Помимо этого планируется не раскрывать и параллельные списки. Для того, чтобы раскрыть параллельные списки или убрать пустые элементы, планируется использовать специальные фильтры.</em></p>
</div>
</div>
<div class="section" id="id60">
<h2><span class="section-number">3.21. </span>Сокращения<a class="headerlink" href="#id60" title="Ссылка на этот заголовок">¶</a></h2>
<p><strong>ФПП</strong> - функционально-потоковое параллельное.</p>
<p><strong>ФППП</strong> - функционально-потоковое параллельное программирование.</p>
<p><strong>ЯФППП</strong> - язык функционально-потокового параллельного программирования.</p>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Оглавление</a></h3>
  <ul>
<li><a class="reference internal" href="#">3. Язык программирования Smile. Предварительное описание</a><ul>
<li><a class="reference internal" href="#id1">3.1. Общие соображения</a></li>
<li><a class="reference internal" href="#id2">3.2. Введение</a></li>
<li><a class="reference internal" href="#id3">3.3. Используемый метаязык</a></li>
<li><a class="reference internal" href="#id4">3.4. Элементарные конструкции</a><ul>
<li><a class="reference internal" href="#id5">3.4.1. Разделители</a></li>
<li><a class="reference internal" href="#id6">3.4.2. Комментарии</a></li>
<li><a class="reference internal" href="#id7">3.4.3. Идентификаторы</a></li>
<li><a class="reference internal" href="#id8">3.4.4. Зарезервированные слова</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id9">3.5. Обозначения</a></li>
<li><a class="reference internal" href="#id10">3.6. Объекты</a></li>
<li><a class="reference internal" href="#id11">3.7. Сигнал</a></li>
<li><a class="reference internal" href="#id12">3.8. Значащие величины (константы)</a><ul>
<li><a class="reference internal" href="#id13">3.8.1. Целая константа</a></li>
<li><a class="reference internal" href="#id14">3.8.2. Логическая константа</a></li>
<li><a class="reference internal" href="#id15">3.8.3. Сигнальная константа</a></li>
<li><a class="reference internal" href="#id16">3.8.4. Специальные знаки</a></li>
<li><a class="reference internal" href="#id17">3.8.5. Константы ошибок</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id18">3.9. Типы</a><ul>
<li><a class="reference internal" href="#id19">3.9.1. Предопределенные атомарные типы</a></li>
<li><a class="reference internal" href="#id20">3.9.2. Составные типы</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id21">3.10. Описания типов</a></li>
<li><a class="reference internal" href="#id22">3.11. Преобразование (приведение) типов</a><ul>
<li><a class="reference internal" href="#id23">3.11.1. Статические преобразования типов во время компиляции</a></li>
<li><a class="reference internal" href="#id24">3.11.2. Преобразование между атомарными константами</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id25">3.12. Функция</a><ul>
<li><a class="reference internal" href="#id26">3.12.1. Перегрузка имен функций</a></li>
<li><a class="reference internal" href="#id27">3.12.2. Определение спецзнаков в качестве имен функций</a></li>
<li><a class="reference internal" href="#id28">3.12.3. Базовые функции</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id29">3.13. Блок</a></li>
<li><a class="reference internal" href="#id30">3.14. Выражение</a></li>
<li><a class="reference internal" href="#id31">3.15. Операторы</a></li>
<li><a class="reference internal" href="#id32">3.16. Структура программы</a></li>
<li><a class="reference internal" href="#id33">3.17. Предопределенные функции и данные</a><ul>
<li><a class="reference internal" href="#id34">3.17.1. Предопределенные базовые функции языка</a><ul>
<li><a class="reference internal" href="#id35">3.17.1.1. Использование сигнальной константы «<strong>!</strong>»</a></li>
<li><a class="reference internal" href="#id36">3.17.1.2. Использование целых чисел в качестве функции</a></li>
<li><a class="reference internal" href="#id37">3.17.1.3. Использование булевских значений в качестве функций</a></li>
<li><a class="reference internal" href="#id38">3.17.1.4. Использование знака «|»</a></li>
<li><a class="reference internal" href="#id39">3.17.1.5. Функция «?»</a></li>
<li><a class="reference internal" href="#id40">3.17.1.6. Использование знака «?»</a></li>
<li><a class="reference internal" href="#id41">3.17.1.7. Использование знака «#»</a></li>
<li><a class="reference internal" href="#id42">3.17.1.8. Использование знака «()»</a></li>
<li><a class="reference internal" href="#id43">3.17.1.9. Использование знака «[]»</a></li>
<li><a class="reference internal" href="#id44">3.17.1.10. Использование знака «{}»</a></li>
<li><a class="reference internal" href="#id45">3.17.1.11. Использование знака «..»</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id46">3.17.2. Использование данных</a><ul>
<li><a class="reference internal" href="#id47">3.17.2.1. Использование целочисленной константы</a></li>
<li><a class="reference internal" href="#id48">3.17.2.2. Использование булевской константы</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id49">3.17.3. Функции, расширяющие возможности языка</a><ul>
<li><a class="reference internal" href="#id50">3.17.3.1. Слжение «<strong>+</strong>»</a></li>
<li><a class="reference internal" href="#id51">3.17.3.2. Использование знака «-«</a></li>
<li><a class="reference internal" href="#id52">3.17.3.3. Использование знака «*»</a></li>
<li><a class="reference internal" href="#id53">3.17.3.4. Использование знака «/»</a></li>
<li><a class="reference internal" href="#id54">3.17.3.5. Использование знака «%»</a></li>
<li><a class="reference internal" href="#id55">3.17.3.6. Использование знаков: «=», «/=», «&lt;», «&lt;=», «&gt;», «&gt;=»</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id56">3.17.4. Использование специальных функций</a><ul>
<li><a class="reference internal" href="#dup">3.17.4.1. Использование функции «dup»</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#id57">3.18. Использование предопределенных типов</a></li>
<li><a class="reference internal" href="#id58">3.19. Пользовательские типы</a></li>
<li><a class="reference internal" href="#id59">3.20. Правила эквивалентных преобразований</a></li>
<li><a class="reference internal" href="#id60">3.21. Сокращения</a></li>
</ul>
</li>
</ul>

  <h4>Предыдущий раздел</h4>
  <p class="topless"><a href="ModelReference.html"
                        title="предыдущая глава"><span class="section-number">2. </span>Статически типизированная модель модель функционально-потоковых параллельных вычислений</a></p>
  <h4>Следующий раздел</h4>
  <p class="topless"><a href="SmileSyntaxRu.html"
                        title="следующая глава"><span class="section-number">4. </span>Синтаксис языка программирования Smile</a></p>
  <div role="note" aria-label="source link">
    <h3>Эта страница</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/SmileReference.rst.txt"
            rel="nofollow">Исходный текст</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Быстрый поиск</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Искать" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Навигация</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Алфавитный указатель"
             >указатель</a></li>
        <li class="right" >
          <a href="SmileSyntaxRu.html" title="4. Синтаксис языка программирования Smile"
             >вперёд</a> |</li>
        <li class="right" >
          <a href="ModelReference.html" title="2. Статически типизированная модель модель функционально-потоковых параллельных вычислений"
             >назад</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">документация smile </a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">3. </span>Язык программирования Smile. Предварительное описание</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Alexander Legalov.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.1.2.
    </div>
  </body>
</html>
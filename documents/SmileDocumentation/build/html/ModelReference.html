
<!DOCTYPE html>

<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta content="Описание концепций, языковых и инструментальных средств функционально-потокового параллельного программирования." name="description" />
<meta content="парадигмы программирования, функционально-потоковое параллельное программирование" name="keywords" />

    <title>2. Статически типизированная модель модель функционально-потоковых параллельных вычислений &#8212; документация smile </title>
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/translations.js"></script>
    <link rel="shortcut icon" href="_static/smile48.png"/>
    <link rel="index" title="Алфавитный указатель" href="genindex.html" />
    <link rel="search" title="Поиск" href="search.html" />
    <link rel="next" title="3. Язык программирования Smile. Предварительное описание" href="SmileReference.html" />
    <link rel="prev" title="1. Введение" href="Introduction.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Навигация</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Алфавитный указатель"
             accesskey="I">указатель</a></li>
        <li class="right" >
          <a href="SmileReference.html" title="3. Язык программирования Smile. Предварительное описание"
             accesskey="N">вперёд</a> |</li>
        <li class="right" >
          <a href="Introduction.html" title="1. Введение"
             accesskey="P">назад</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">документация smile </a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">2. </span>Статически типизированная модель модель функционально-потоковых параллельных вычислений</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="id1">
<h1><span class="section-number">2. </span>Статически типизированная модель модель функционально-потоковых параллельных вычислений<a class="headerlink" href="#id1" title="Ссылка на этот заголовок">¶</a></h1>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p>Описывается модель параллельных вычислений, ориентированная на представление динамики поведения при статической типизации. То есть речь идет о статически типизированной модели функционально-потоковых параллельных вычислений (СТМФППВ). Ее отличительной чертой является более эффективная поддержка процесса трансформации программ во время компиляции.</p>
<p><em>Предполагается, что в данном тексте замечания могут касаться и изменений, вносимых в модель и язык. В ходе дальнейших версий эти замечания будут удаляться.</em></p>
</div>
<div class="section" id="id2">
<h2><span class="section-number">2.1. </span>Введение<a class="headerlink" href="#id2" title="Ссылка на этот заголовок">¶</a></h2>
<p>Статически типизированная модель модель функционально-потоковых параллельных вычислений (СТМФППВ) определяет динамику поведения и базовую семантику статически типизированного языка функционально-потокового параллельного программирования (СТЯФППП) Smile. В отличие от ранее предложенной функционально-потоковой модели параллельных вычислений (ФПМПВ) данная модель ориентирована на  статическая типизацию данных и фиксацию размерностей данных, используемых в массовых операциях. Это, в свою очередь, ведет к изменению семантики программо-формирующих операторов. Изменяются также аксиомы модели и ее алгебра преобразований за счет ориентации на период компиляции. Вместе с тем основные характеристики модели, определяющие концепцию архитектурно-независимого параллельного программирования остаются практически неизменными:</p>
<ul class="simple">
<li><p>вычисления протекают внутри неограниченных ресурсов, что позволяет неявно описывать параллелизм без возникновения ресурсных конфликтов;</p></li>
<li><p>управление вычислениями осуществляется по готовности данных;</p></li>
<li><p>выбор операций и аксиом, определяющих базовый набор функций, ориентирован на наглядное текстовое представление информационного графа программы при его описании на языке программирования;</p></li>
<li><p>модель вычислений определяет общую структуру функционально-потоковой параллельной программы без привязки к операционной семантике, которая может определяться дополнительно, определяя тем самым специфику конкретного языка (подъязыка) программирования.</p></li>
</ul>
<p>Первое требование обеспечивает ресурсную независимость предлагаемой модели, что позволяет описать параллелизм, ограниченный только информационными зависимостями между функциями и данными, присущими решаемой задаче. Это сводит перенос разработанной и отлаженной функционально-потоковой параллельной программы на любую вычислительную систему к распределению ресурсов в соответствии с целевой архитектурой. Подобный подход используется также в ряде известных схем потока данных (СПД) [Алгоритмы1982], ориентированных на рекурсивное описание программ, обрабатывающих только один входной поток данных и не поддерживающих их конвейерное продвижение. В связи с отсутствием циклических конструкций граф данной модели является <em>ациклическим</em>.</p>
<p>Использование текстового описания для представления параллельных программ связано с трудностями непосредственного описания информационного графа, что привело к синтаксису языка, несколько отличающемуся от общепринятого. Кроме того, в языке отсутствуют вентили, обеспечивающие условную передачу данных в традиционных СПД [Деннис1972, Arvind1975]. Эти вентили трудно структурировать при текстовом описании программ без использования дополнительной синхронизации информационных потоков.</p>
<p>Отличительной особенностью СТМФППВ является ориентация программо-формирующих операторов на использование статически типизированных вычислений. Это ведет к уменьшению динамических свойств операторов, что облегчает трансформацию в структуры данных, типичные практически для всех современных статически типизированных языков программирования (как императивных, так и функциональных). Подобные модификации, в свою очередь, достаточно сильно изменяет семантику как модели вычислений, так и формируемого на ее основе СТЯФППП Smile.</p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p>Следует отметить, что понятие СТМФППВ не связано только со статической типизацией данных. Как и основная ФПМПВ новая модель предназначена для описания семантики вычислений и организации параллельных процессов. Вместе с тем следует отметить, что использование статической типизации накладывает определенную специфику на операторы модели, что, в свою очередь, ведет к изменению их семантики функционирования. В связи с этим поведение операторов модели и, как следствие, программы, написанной на соответствующем языке, тоже будет иным. Изменяются аксиомы модели и алгебра эквивалентных преобразований.</p>
</div>
</div>
<div class="section" id="id3">
<h2><span class="section-number">2.2. </span>Общие принципы организации модели<a class="headerlink" href="#id3" title="Ссылка на этот заголовок">¶</a></h2>
<p>Модель задается тройкой:</p>
<blockquote>
<div><p>M = ( G, P, S<sub>0</sub> ),</p>
</div></blockquote>
<p>где G - ациклический ориентированный граф, определяющий информационную
структуру программы (ее информационный граф), P - набор правил, определяющих
динамику функционирования модели (механизм формирования разметки), S<sub>0</sub> - начальная
разметка.</p>
<p>Информационный граф</p>
<blockquote>
<div><p>G = ( V, A ),</p>
</div></blockquote>
<p>где V - множество вершин определяющих программо-формирующие операторы, а A - множество дуг, задающих пути передачи информации между ними.</p>
<p>Вершины графа, соответствующие программо-формирующим операторам и хранилищам, обеспечивают информационные преобразования данных, их структуризацию и размножение. Существуют следующие типы операторов:</p>
<ul class="simple">
<li><p>операторы интерпретации;</p></li>
<li><p>константный оператор или константа (const);</p></li>
<li><p>оператор копирования;</p></li>
<li><p>оператор группировки в кортеж (tuple);</p></li>
<li><p>оператор группировки в рой (swarm);</p></li>
<li><p>оператор задержки (delay);</p></li>
<li><p>оператор группировки в поток (stream);</p></li>
<li><p>хранилище данных заданного типа.</p></li>
</ul>
<p>Следует отметить, что появление хранилищ связано с возможностью задания типов данных. Это позволяет создать хранилище данных определенного типа, занесение данных в которые возможно с использованием принципа единственного присваивания. Хранимые данные можно читать по их готовности. Операции записи в хранилища и чтения из них зависят от заданного типа.</p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p>В отличие от ФПМПВ появление хранилищ позволяет организовывать их использование за счет операций, распределенных в различных частях функции или даже из нескольких различных функций.</p>
<p>Также следует отметить, что хранилища могут выпасть из описания МВ, как операторы. Но появляются некоторые функции для работы с хранилищами. Этот вопрос нужно еще проработать…</p>
</div>
<p>Операторы и хранилища являются вершинами информационного графа, определяющего функцию. Имеется одна начальная вершина V<sub>0</sub>, определяющая точку входа для аргумента, инициирующего вычисления. Существует также одна выходная вершина V<sub>end</sub>, определяющий узел выхода результата вычисления функции. Запуск вычислений в функции инициируется поступлением в нее аргумента, что фиксируется соответствующей разметкой дуги, выходящей из входной вершины. Вычисления заканчиваются, когда все дуги информационного  графа, включая и дугу, входящую в выходную вершину, окажутся размеченными. Все прочие вершины определяют программо-формирующие операторы. Из каждой вершины информационного графа (за исключением выходной вершины) может выходить несколько дуг в другие вершины. Эти дуги определяют пути перемещения вычисляемых значений.</p>
<p>Динамика выполнения операторов задается механизмом продвижения начальной разметки графа по дугам модели. Разметка дуги определяется типом передаваемых данных или оператором, заданным в вершине информационного графа.</p>
<p>Большинство операторов формируют единичную разметку (разметку кратностью 1). То есть, на выходе создается тольно одно значение определенного типа. Исключением является рой, который в асинхронном режиме может порождать и выдавать более одного значения…</p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p>Необходимо переработать понятие разметки с учетом изменения концепции параллельных списков. Это касается ниже расположенного текста.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>Данный текст нужно переработать и не забыть использовать при описании динамики роя.</em></p>
<p>«и в общем случае (при передаче роев) задается вектором:»</p>
<p>M<sub>i</sub> = (N, R),</p>
<p>где N - кратность роя, определяющая количество перемещаемых независимых значений,
полученных в результате выполнения оператора, выход которого соединен с этой дугой; R - вектор данных (r<sub>1</sub>, r<sub>2</sub>, … r<sub>N</sub>), полученный в ходе вычислений.</p>
<p>Наличие разметок на всех дугах некоторой вершины графа позволяет запустить ее и получить выходную разметку. Разметку кратности большей, чем единица назовем параллельной. Набор независимых данных, соответствующий такой разметке, будем называть параллельным списком или роем. При разметке кратности 1 имеем частный случай параллельного списка, вырожденного до одноэлементного параллельного списка или просто элемента.</p>
<p>Следует отметить, что поддержка разметкой дуги нескольких независимых наборов данных позволяет описывать на уровне ФПМПВ массовый параллелизм, порождаемый использованием роя (swarm). При этом передача данных роя из формирующей его вершины может начинаться до формирования полной разметки, так как обработка каждого из его элементов осуществляется независимо. То есть осуществляется асинхронное выполнение вычислений надНа его выходе сформировано значение тип которого определяется видом константы. То есть, н независимыми наборами данных по их готовности.</p>
<p>Например, если вершина V<sub>i</sub> получает данные с дуги A<sub>j</sub> с кратностью разметки N, то для формирования неполной разметки на выходной дуге A<sub>k</sub> достаточно появления хотя бы одного набора данных r<sub>m</sub>. Дальнейшее формирование разметки на входной дуге позволяет пополнять разметку на выходе. Данный механизм поддерживается аксиомами языка. Необходимым условием является наличие полных разметок только при окончании вычислений функции. Назовем разметку дуги, не сформированную до конца, неполной.</p>
<p>Отметим также, что произвольное поступление элементов вектора значений R на обработку не приводит к неоднозначности, так как каждый элемент идентифицирован уникальным порядковым номером от 1 до N.</p>
</div>
</div>
<div class="section" id="id4">
<h2><span class="section-number">2.3. </span>Описание программо-формирующих операторов<a class="headerlink" href="#id4" title="Ссылка на этот заголовок">¶</a></h2>
<p>Для графического представления операторов используются специальные обозначения,
приведенные на рис. 1.1 - 1.7. Наряду с графическими обозначениями применяется и текстовое описание элементов модели, аналогичное принятому в разработанном языке программирования.</p>
<div class="section" id="id5">
<h3><span class="section-number">2.3.1. </span>Операторы интерпретации<a class="headerlink" href="#id5" title="Ссылка на этот заголовок">¶</a></h3>
<p><strong>Операторы интерпретации</strong> предназначены для описания функциональных преобразования аргументов. Каждый такой оператор имеет два входа, на один из которых поступает значение интерпретируемое как функция F (функциональный вход), а на другой величина, являющаяся аргументом (вход данных) X, обрабатываемым данной функцией. Существует два вида операторов интерпретации: одноаргументный и массовый.</p>
<p><strong>Одноаргументный оператор интерпретации</strong> применяется к своим входам как обычная функция. То есть считается, что одна функция обрабатывает аргумент как единое целое, формируя на выходе результат функционального преобразования (рис. 1.1).</p>
<div class="figure align-center" id="id16">
<a class="reference internal image-reference" href="_images/f1_1.png"><img alt="Оператор интерпретации" src="_images/f1_1.png" style="width: 115.5px; height: 118.0px;" /></a>
<p class="caption"><span class="caption-text">Рис. 1.1. Оператор интерпретации
с входами аргумента <strong>X</strong> и функцией <strong>F</strong>.</span><a class="headerlink" href="#id16" title="Постоянная ссылка на рисунок">¶</a></p>
</div>
<p>При текстовом описании одноаргументный оператор интерпретации имеет две формы: постфиксную, обозначаемую
знаком <strong>«:»</strong>, и префиксную, при которой функция отделяется от аргумента знаком <strong>«^»</strong>.
Наличие двух способов записи одного оператора позволяет в дальнейшем комбинировать их
с целью получения более наглядного текста программы. Следовательно, традиционное обозначение функции <strong>F(X)</strong> оператор интерпретации позволяет задать одной из форм:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span><span class="p">:</span><span class="n">F</span> <span class="n">или</span> <span class="n">F</span><span class="o">^</span><span class="n">X</span> <span class="o">.</span>
</pre></div>
</div>
<p><strong>Массовый оператор интерпретации</strong> предназначен для описания параллельных вычислений (рис. 1.2), когда аргумент и/или функция являются контейнерными типам, к которым относятся кортежи, векторы, рои, потоки. В этом случае функцией осуществляется обработка каждого элемента контейнера как отдельного аргумента. На выходе данной операции интерпретации формируется результат, являющийся контейнером такого же типа, что и контейнер аргумента, а элементы этого контейнера образуются результатами вычислений для каждого аргумента. Особенности семантики массового оператора интерпретации для различных вариантов описываются алгеброй эквивалентных преобразований.</p>
<div class="figure align-center" id="id17">
<a class="reference internal image-reference" href="_images/f1_2.png"><img alt="Оператор интерпретации" src="_images/f1_2.png" style="width: 115.5px; height: 118.0px;" /></a>
<p class="caption"><span class="caption-text">Рис. 1.2. Оператор интерпретации
с входами аргумента <strong>X</strong> и функцией <strong>F</strong>.</span><a class="headerlink" href="#id17" title="Постоянная ссылка на рисунок">¶</a></p>
</div>
<p>При текстовом описании одноаргументный оператор интерпретации имеет две формы: постфиксную, обозначаемую
знаком <strong>«::»</strong>, и префиксную, при которой функция отделяется от аргумента знаком <strong>«^^»</strong>.
Массовый оператор интерпретации можно задать одним из способов:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span><span class="p">::</span><span class="n">F</span> <span class="n">или</span> <span class="n">F</span><span class="o">^^</span><span class="n">X</span> <span class="o">.</span>
</pre></div>
</div>
<p>В любом опереторе интерпретации как аргумент, так и функция могут являться результатами предшествующих вычислений. Это обуславливается тем, что семантика оператора допускает использование в качестве функции различные типы данных (что определяется на уровне семантики языка). Однако типы функционального аргумента и аргумента данных должны быть известны во время компиляции, что обеспечивает прозрачную трансформацию в другие статически типизированные языки программирования.</p>
<p>Операторы интерпретации запускаются по готовности функции и аргумента, что определяется появлением разметки на входных дугах. Получение результата задается разметкой выходной дуги.</p>
</div>
<div class="section" id="id6">
<h3><span class="section-number">2.3.2. </span>Константный оператор<a class="headerlink" href="#id6" title="Ссылка на этот заголовок">¶</a></h3>
<p><strong>Константный оператор</strong> или <strong>константа</strong> определяет вершину информационного графа, хранящую постоянную величину и всегда готовую к выполнению.Он не имеет входов (рис. 1.3). Данный оператор не имеет входа. На выходе изначально устанавливается разметка, определяющая предписанное значение. Множество константных операторов информационного графа формируют внутреннюю начальную разметку модели вычислений. В языковом представлении константный оператор задается значением соответствующего типа. Тип константы должен быть известен во время компиляции функции</p>
<div class="figure align-center" id="id18">
<a class="reference internal image-reference" href="_images/f1_3.png"><img alt="Константный оператор" src="_images/f1_3.png" style="width: 97.5px; height: 79.0px;" /></a>
<p class="caption"><span class="caption-text">Рис. 1.3. Константный оператор</span><a class="headerlink" href="#id18" title="Постоянная ссылка на рисунок">¶</a></p>
</div>
</div>
<div class="section" id="id7">
<h3><span class="section-number">2.3.3. </span>Оператор копирования<a class="headerlink" href="#id7" title="Ссылка на этот заголовок">¶</a></h3>
<p><strong>Оператор копирования</strong> (рис. 1.4) осуществляет передачу данных с одного своего
входа на множество выходов. В графическом представлении данная передача фиксируется
установкой разметки на дугах, связанных с выходами вершины при размеченной входной
дуге.</p>
<div class="figure align-center" id="id19">
<a class="reference internal image-reference" href="_images/f1_4.png"><img alt="Оператор копирования данных" src="_images/f1_4.png" style="width: 127.5px; height: 128.0px;" /></a>
<p class="caption"><span class="caption-text">Рис. 1.4. Оператор копирования данных</span><a class="headerlink" href="#id19" title="Постоянная ссылка на рисунок">¶</a></p>
</div>
<p>По сути оператор копирования представляет источник данных к которому осуществляется доступ из различных точек функции. Поэтому представленное отдельное графическое обозначение не означает реально выделенного отдельного оператора. В общем случае оператор копирования может объединяться с предшествующим оператором, из которого выходит его выходная дуга. Также возможна цепочка операторов копирования, которая может восприниматься как один оператор.</p>
<p>В текстовой форме он определяется через именование передаваемой величины и дальнейшее использование введенного обозначения в требуемых точках функции. Используются как постфиксное именование размножаемого объекта в форме:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">величина</span> <span class="o">&gt;&gt;</span> <span class="n">имя</span> <span class="p">,</span>
</pre></div>
</div>
<p>так и его префиксный эквивалент, имеющий вид:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">имя</span> <span class="o">&lt;&lt;</span> <span class="n">величина</span> <span class="o">.</span>
</pre></div>
</div>
<p>Например:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="n">F</span><span class="o">^</span><span class="n">x</span><span class="p">;</span>
<span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span><span class="o">+</span> <span class="o">&gt;&gt;</span> <span class="n">c</span><span class="p">;</span>
</pre></div>
</div>
<p>При этом тип обозначения совпадает с типом результата предшествующих вычислений и определяется во время компиляции.</p>
</div>
<div class="section" id="id8">
<h3><span class="section-number">2.3.4. </span>Оператор группировки в кортеж<a class="headerlink" href="#id8" title="Ссылка на этот заголовок">¶</a></h3>
<p><strong>Оператор группировки в кортеж</strong> (рис. 1.5) имеет несколько входов и один выход. Он обеспечивает структуризацию, упорядочение и синхронизацию разнотипных данных, поступающих по дугам из различных источников. Типы поступающих элементов должны быть известны во время компиляции. Данная структура является неименованной, то есть доступ к ее элементам осуществляется по порядковому номеру (индексу). Порядок элементов определяется номерами входов, каждому из которых
соответствует натуральное число в диапазоне от 1 до N, где N - длина вектора. В текстовом виде оператор задается ограничением элементов списка круглыми скобками «(» и «)». Например:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span><span class="p">,</span> <span class="n">x4</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p>Насчет нумерации нужно подумать. Стоит ли сводить индексации к диапазону 0 … N-1? При этом естественно нужно будет убрать операции удаления элементов из списков. Возможно, что в статически типизированной версии они не очень-то и нужны.</p>
</div>
<p>Нумерация элементов вектора в данном случае задается неявно в соответствии с порядком их следования слева направо (это же соглашение предполагается и в графическом представлении при отсутствии явной нумерации входов).</p>
<div class="figure align-center" id="id20">
<a class="reference internal image-reference" href="_images/f1_5.png"><img alt="Оператор группировки в вектор" src="_images/f1_5.png" style="width: 145.0px; height: 151.0px;" /></a>
<p class="caption"><span class="caption-text">Рис. 1.5.  Оператор группировки в вектор</span><a class="headerlink" href="#id20" title="Постоянная ссылка на рисунок">¶</a></p>
</div>
<p>Количество элементов в сформированном списке равно сумме всех входных дуг.</p>
</div>
<div class="section" id="id9">
<h3><span class="section-number">2.3.5. </span>Оператор группировки в рой<a class="headerlink" href="#id9" title="Ссылка на этот заголовок">¶</a></h3>
<p><strong>Оператор группировки в рой</strong> (рис. 1.6), как и оператор группировки в кортеж обеспечивает формирование набора данных. Основное отличие роя от кортежа заключается в том, что группируемые данные являются независимыми друг от друга. Поступление в рой каждого элемента данных сопровождается выдачей управляющих сигналов, информирующих об этом событии, что позволяет оперативно реагировать на изменение состояния роя.</p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p>В данном случае, несмотря на то, что изменяется алгебра преобразований, на выходе кратность разметки определяется общим числом всех входных дуг вложенных роев, образующих начальный уровень вложенности. Как и ранее, вложенные рои не раскрываются</p>
</div>
<div class="figure align-center" id="id21">
<a class="reference internal image-reference" href="_images/f1_6.png"><img alt="Оператор группировки в рой" src="_images/f1_6.png" style="width: 153.0px; height: 177.0px;" /></a>
<p class="caption"><span class="caption-text">Рис. 1.6.  Оператор группировки в рой</span><a class="headerlink" href="#id21" title="Постоянная ссылка на рисунок">¶</a></p>
</div>
<p>В текстовом виде группировка в рой задается ограничением его элементов квадратными скобками <strong>«[«</strong> и <strong>«]»</strong>. Например:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span><span class="p">,</span> <span class="n">x4</span> <span class="p">]</span> <span class="o">.</span>
</pre></div>
</div>
<p>Каждый элемент роя формируется независимо и по его появлению готов к выполнению. Это позволяет выполнять массовую операцию интерпретации по мере поступления элементов в рой, реализуя по сути следующие эквивалентные преобразования:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>[x1, x2, x3,x4]::f ≡ [x1:f, x2:f, x3:f, x4:f] .
</pre></div>
</div>
<p>Если же рой определяет набор функций, то все они выполняются одновременно над одним и тем же аргументом. Таким образом, данная конструкция обеспечивает организацию массового параллелизма:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>x::[f1, f2, f3, f4] ≡ [x:f1, x2:f2, x3:f3, x4:f4] .
</pre></div>
</div>
<p>При этом осуществляется сквозная перенумерация всех элементов сформированного роя слева направо. Все элементы роя должны быть одного типа, что обуславливается однородностью данных при массовом параллелизме. Это касается роя, выступающего в роли как данных, так и функции. Для функций все элементы роя должны иметь одинаковую сигнатуру и одинаковый тип результата.</p>
</div>
<div class="section" id="id10">
<h3><span class="section-number">2.3.6. </span>Оператор задержки<a class="headerlink" href="#id10" title="Ссылка на этот заголовок">¶</a></h3>
<p><strong>Оператор задержки</strong> или <strong>задержка</strong> (рис. 1.7) задается вершиной, содержащей допустимый информационный подграф, в который входят несколько входных дуг и выходит одна выходная дуга. Входные дуги определяют поступление аргументов, а выход задает выдаваемый из подграфа результат. Специфической особенностью такой группировки является то, что ограниченные оператором задержки вершины (на графе ограничение задается контуром формируемой мультивершины), представляющие другие программо-формирующие операторы, не могут выполняться, даже при наличии на входах всех аргументов. Их активизация возможна только при снятии задержки (раскрытии контура), когда ограниченный подграф становится частью всего вычисляемого графа.</p>
<div class="figure align-center" id="id22">
<a class="reference internal image-reference" href="_images/f1_7.png"><img alt="Оператор задержки" src="_images/f1_7.png" style="width: 250.5px; height: 324.5px;" /></a>
<p class="caption"><span class="caption-text">Рис. 1.7.  Оператор задержки</span><a class="headerlink" href="#id22" title="Постоянная ссылка на рисунок">¶</a></p>
</div>
<p>Первоначально задержанный подграф создает на своем единственном выходе константную разметку, которая является образом (иконкой) данного подграфа. Эта разметка распространяется по дугам графа от одного программо-формирующего оператора к другому, размножаясь, входя
в различные списки и выделяясь из них до тех пор, пока не поступит на один из входов оператора интерпретации. Как только оператор задержки становится одним из аргументов оператора интерпретации, вместо иконки происходит подстановка ранее определенного задержанного подграфа с сохранением входных связей. Опоясывающий подграф контур оператора задержки при этом «убирается», и происходит выполнение активированных операторов. В результате на выходной дуге раскрытого подграфа вновь формируется результирующая разметка, которая
и является одним из аргументов оператора интерпретации, раскрывшего задержанный
подграф. Данная процедура называется раскрытием задержанного подграфа.</p>
<p>В текстовом виде оператор задержки задается охватом других операторов фигурными
скобками <strong>«{«</strong> и <strong>«}»</strong>. Например:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span><span class="o">+</span><span class="p">}</span> <span class="o">.</span>
</pre></div>
</div>
<p>Если внутри задержки необходимо сформировать несколько независимых аргументов, то они группируются в рой, который инициируется при раскрытии:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{[</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span><span class="p">,</span> <span class="n">x4</span><span class="p">]}</span> <span class="o">.</span>
</pre></div>
</div>
<p>Наличие этой конструкции позволяет откладывать момент начала некоторых вычислений или вообще не начинать их, что необходимо при организации выборочной обработки данных. Помимо этого данный оператор, при необходимости, может использоваться в качестве скобок, меняющих приоритет выполнения операторов. Для этого он может быть непосредственно представлен как один из аргументов оператора интерпретации.</p>
</div>
<div class="section" id="id11">
<h3><span class="section-number">2.3.7. </span>Хранилища данных<a class="headerlink" href="#id11" title="Ссылка на этот заголовок">¶</a></h3>
<p><strong>Хранилища данных</strong> определяют дополнительный тип верши информационного графа.</p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p>Пока непонятно, стоит ли хранилища включать в модель, так как МВ описывает в основном операторный уровень, а хранилища являются декларацией данных. Вполне возможно, что их стоит ввести как дополнительные фичи на уровне языка программирования…</p>
</div>
</div>
</div>
<div class="section" id="id12">
<h2><span class="section-number">2.4. </span>Основные типы данных<a class="headerlink" href="#id12" title="Ссылка на этот заголовок">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p>Раз речь идет о статически типизированной модели, то необходим описать не только основные фунции, но и данные, включая и фукнциональный тип. Также нужн охарактеризовать сигналы, булевский тип, целые числа, так как они несут дополнительную семантическую нагрузку, включая и проявление дуализма. Этот раздел пока не проработан…</p>
</div>
</div>
<div class="section" id="id13">
<h2><span class="section-number">2.5. </span>Описание динамики функционирования<a class="headerlink" href="#id13" title="Ссылка на этот заголовок">¶</a></h2>
<p>Правила распространения разметки по графу складываются из общих правил
межоператорных переходов, правил срабатывания программо-формирующих операторов, правил выполнения операторов интерпретации над предопределенными функциями модели (а далее и языка), правил эквивалентных преобразований операторов и связей допустимого графа (алгебры преобразований, связанной с исполнением отдельных операторов и описанной выше).</p>
<p><strong>Правила межоператорных переходов</strong> задают распространение разметки по графу:</p>
<ol class="arabic simple">
<li><p>Если входные дуги вершины имеют разметку, то на выходных дугах происходит формирование разметки в соответствии с правилами срабатывания вершины, определяющий программо-формирующий оператор.</p></li>
<li><p>Рой может формировать разметку кратность которой превышает единицу и зависит от числа его элементов. Это обуславливается асинхронностью формирования в нем данных, которые сразу же могут поступать на дальнейшую обработку независимо друг от друга. В данной ситуации обработка элементов определяется правилами эквивалентных преобразований, сводящих обработку роя к массовым параллельным операциям над отдельными его элементами.</p></li>
<li><p>В процессе распространения разметка не убирается и не замещается. Каждая дуга графа может получить разметку только один раз. Из требования о недопустимости повторной разметки вытекает требование ацикличности графа.</p></li>
<li><p>Процесс распространения разметки заканчивается, когда все дуги графа имеют полную разметку в соответствии с предписанной кратностью или при невозможности распространения разметки.</p></li>
</ol>
<p><strong>Правила срабатывания программо-формирующих операторов</strong> конкретизируют формирование разметок на выходных дугах для каждого из ранее введенных операторов. <em>Оператор интерпретации</em> обеспечивает преобразование входного набора данных X, выступающего в качестве аргумента, в выходной набор Y, играющего роль результата, используя при этом входной набор F в качестве функции, определяющей алгоритм преобразования. В постфиксной нотации, выбранной для дальнейших иллюстраций, данное преобразование можно записать следующим образом:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>X:F ⇒ Y .
</pre></div>
</div>
<p>Можно рассмотреть множество унарных функций F, разделив его при этом на два подмножества:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">F</span> <span class="o">=</span> <span class="p">{</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">},</span>
</pre></div>
</div>
<p>где <strong>f1</strong> - множество предопределенных функций, для каждой из которых аксиоматически задается области определения и изменения; <strong>f2</strong> - множество функций, порождаемых при программировании. Необходимо отметить, что областью определения любой функции из <strong>F</strong> является множество одноэлементных наборов данных. Обработка же роя определяется с помощью правил эквивалентных преобразований.</p>
<p>Поступающий на вход оператора интерпретации аргумент должен иметь тип, совпадающий с типом аргумента функции, поступающей на функциональный вход. Эта специфика определяется статической типизацией, введенной в модель. Исходя из типа аргумента и сигнатуры функции на этапе компиляции обеспечивается определение типа результата и его сопоставление с типом результата, возвращаемого функцией. В общем случае используется структурная эквивалентность типов.</p>
<p>Результатом выполнения функции может быть любой тип данных, включая рой произвольной размерности. При этом типы аргумента и результата определяются из описания функции во время компиляции. Следует отметить, что выбор базового набора предопределенных функций осуществляется в некоторой степени субъективно, исходя из соображений удобства пользования разрабатываемым языком. Вводятся аксиоматически определенные арифметические функции, функции сравнения и прочие, аналогично тому, как это сделано и в других языках программирования. Например, функция сложения двух чисел
<strong>x1</strong>, <strong>x2</strong>, порождающая в качестве разметки число <strong>y</strong>, задается следующим образом:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(x1, x2):+ ⇒ y,
</pre></div>
</div>
<p>где первый аргумент оператора интерпретации является двухэлементным списком заданного типа, описанного для данной функции при описании языка. Аналогично описан и тип результата. Второй аргумент оператора
интерпретации является функцией сложения, обозначенной значком «<strong>+</strong>». Результат
функции сложения, значение y, является атомарным элементом.
Наряду с определением функций, присущих всем языкам программирования, целесообразно определить множество функций, нестандартных в традиционном понимании. Например, целое число может непосредственно интерпретироваться как функция выбора элемента списка:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(x1, x2, ... xi, ... xn):i ⇒ xi ,
</pre></div>
</div>
<p>где i - натуральное число, xi – элемент списка. Данная функция выделяет из списка
данных i-й элемент, который и определяет разметку выходной дуги.
Другой полезной предопределенной функцией является:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(b1, b2, b3, ... bn):? ⇒ [i1, i2, ... ik] ,
</pre></div>
</div>
<p>где (b1,…bn) - список булевских величин; [i1,… ik] - рой из натуральных чисел, определяющих номера тех компонент булевского списка, которые имеют истинные значения. Наличие данной функции позволяет формировать условия, обеспечивающие выполнение нескольких альтернативных ветвей программы.</p>
<p>Наряду с определением операции интерпретации для аксиоматически определенных функций, она также определяется и для уже существующих программо-формирующих операторов. Так, в частности, определены следующие правила раскрытия оператора задержки:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>{X}:f ⇒ X:f                       (1.1)
x:{F} ⇒ x:F                       (1.2)
{X}:{F} ⇒ X:F                     (1.3)
</pre></div>
</div>
<p>Выражение (1.1) показывает, что, независимо от наличия разметки на дуге, определяющей вход <code class="docutils literal notranslate"><span class="pre">f</span></code>, задержка данных <code class="docutils literal notranslate"><span class="pre">{X}</span></code> раскрывается. Далее, если X является допустимым подграфом, следует получение его значения, после чего осуществляется выполнение заданного оператора интерпретации. Следует также отметить, что задержка раскрывается сразу же по поступлению на один из входов оператора интерпретации не дожидаясь готовности второго аргумента.</p>
<p>Выражение (1.2) описывает аналогичное раскрытие задержки функции F независимо от появления разметки на входе, определяющем x. Если же оба аргумента оператора интерпретации являются операторами задержки (1.3), то они воспринимаются, как константные значения, что определяет их немедленное раскрытие. После этого каждое из выражений вычисляется, что приводит к разметке входных дуг описанного оператора интерпретации окончательными значениями и его последующему выполнению.</p>
</div>
<div class="section" id="id14">
<h2><span class="section-number">2.6. </span>Эквивалентные преобразования<a class="headerlink" href="#id14" title="Ссылка на этот заголовок">¶</a></h2>
<p>Правила эквивалентных преобразований операторов и связей допустимого графа определяют алгебру модели и языка программирования. Они позволяют осуществить трансформацию графа, обеспечивающую сведение сложных структурированных операций к набору более элементарных действий над предопределенными компонентами. Возможна также обратная структуризация элементарных действий, полезная при адаптации полученной функционально-потоковой параллельной программы к архитектуре конкретной ВС. Эквивалентные преобразования определены на множестве программо-формирующих операций и отражают общие алгебраические свойства модели.</p>
<p>Проведение этих преобразований может происходить как перед началом вычислений, когда они применяются к исходному информационному графу, так и непосредственно в ходе выполнения программы. В этом случае преобразования проходят на уже частично размеченном графе.</p>
<p>Для описания правил эквивалентных преобразований введем ряд обозначений.
Отдельные значения элементов будем обозначать малыми латинскими буквами: <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>, <code class="docutils literal notranslate"><span class="pre">c</span></code>, <code class="docutils literal notranslate"><span class="pre">d</span></code>, <code class="docutils literal notranslate"><span class="pre">e</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, <code class="docutils literal notranslate"><span class="pre">z</span></code> для данных и <code class="docutils literal notranslate"><span class="pre">f</span></code>, <code class="docutils literal notranslate"><span class="pre">g</span></code>, <code class="docutils literal notranslate"><span class="pre">h</span></code> для функций. Значения роев данных и функций обозначим соответствующими заглавными латинскими буквами. Аналогично для еще не вычисленных
элементов будем использовать малые латинские буквы: <code class="docutils literal notranslate"><span class="pre">q</span></code>, <code class="docutils literal notranslate"><span class="pre">r</span></code>, <code class="docutils literal notranslate"><span class="pre">s</span></code>, <code class="docutils literal notranslate"><span class="pre">t</span></code>, <code class="docutils literal notranslate"><span class="pre">v</span></code>, <code class="docutils literal notranslate"><span class="pre">w</span></code>. Еще не
вычисленные выражения внутри роев обозначим через эти же, но
заглавные буквы. Для описания порядкового расположения элементов списков будем
использовать индексы, задаваемые натуральными числами и буквами <code class="docutils literal notranslate"><span class="pre">i</span></code>, <code class="docutils literal notranslate"><span class="pre">j</span></code>, <code class="docutils literal notranslate"><span class="pre">k</span></code>, <code class="docutils literal notranslate"><span class="pre">l</span></code>, <code class="docutils literal notranslate"><span class="pre">m</span></code>, <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p>
<p>Например:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="n">xn</span> <span class="p">;</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">f3</span>  <span class="p">;</span>
<span class="n">W</span> <span class="o">=</span> <span class="n">w</span> <span class="mi">1</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="n">wk</span> <span class="o">.</span>
</pre></div>
</div>
<p>Перед выполнением любой операции интерпретации выполняются (в случае необходимости) следующие эквивалентные преобразования.</p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p>Следует отметить, что представленные эквивалентные преобразования отличаются от тех, которые имеются в ФПМПВ, реализуемой я ЯФППП Пифагор. Это связано со спецификой статической типизации, ограничивающей возможности динамических трансформаций.</p>
</div>
<div class="section" id="id15">
<h3><span class="section-number">2.6.1. </span>Отсутствие в СТМФППВ неявных преобразований внутри составных конструкций<a class="headerlink" href="#id15" title="Ссылка на этот заголовок">¶</a></h3>
<p>Формируемые в ходе вычислений составные конструкции могут содержать другие составные конструкции. При этом в статически типизированной модели отсутствуют их неявные преобразования по умолчанию. Поэтому внутри структур могут содержаться рои, сигналы, что в ФПМПВ приводилось к более простому виду. Поэтому такие структуры как:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">,[</span><span class="n">x3</span><span class="p">],[</span><span class="n">x4</span><span class="p">,[</span><span class="n">x5</span><span class="p">]],</span><span class="n">x6</span><span class="p">)</span>
</pre></div>
</div>
<p>остаются неизменными. Также не подлежит преобразованию кортеж, содержащий сигналы, которые не воспринимаются в данном случае как пустые элементы. Например, <code class="docutils literal notranslate"><span class="pre">(x1,x2,.,x3,</span> <span class="pre">x4,x5,!,!,x6)</span></code> или <code class="docutils literal notranslate"><span class="pre">[x1,x2,.,x3,x4,x5,!,!,x6]</span></code> далее не изменяются. Предполагается, что при необходимости дополнительной трансформации этих структур к другой форме будут использоваться специальные функции.</p>
</div>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Оглавление</a></h3>
  <ul>
<li><a class="reference internal" href="#">2. Статически типизированная модель модель функционально-потоковых параллельных вычислений</a><ul>
<li><a class="reference internal" href="#id2">2.1. Введение</a></li>
<li><a class="reference internal" href="#id3">2.2. Общие принципы организации модели</a></li>
<li><a class="reference internal" href="#id4">2.3. Описание программо-формирующих операторов</a><ul>
<li><a class="reference internal" href="#id5">2.3.1. Операторы интерпретации</a></li>
<li><a class="reference internal" href="#id6">2.3.2. Константный оператор</a></li>
<li><a class="reference internal" href="#id7">2.3.3. Оператор копирования</a></li>
<li><a class="reference internal" href="#id8">2.3.4. Оператор группировки в кортеж</a></li>
<li><a class="reference internal" href="#id9">2.3.5. Оператор группировки в рой</a></li>
<li><a class="reference internal" href="#id10">2.3.6. Оператор задержки</a></li>
<li><a class="reference internal" href="#id11">2.3.7. Хранилища данных</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id12">2.4. Основные типы данных</a></li>
<li><a class="reference internal" href="#id13">2.5. Описание динамики функционирования</a></li>
<li><a class="reference internal" href="#id14">2.6. Эквивалентные преобразования</a><ul>
<li><a class="reference internal" href="#id15">2.6.1. Отсутствие в СТМФППВ неявных преобразований внутри составных конструкций</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Предыдущий раздел</h4>
  <p class="topless"><a href="Introduction.html"
                        title="предыдущая глава"><span class="section-number">1. </span>Введение</a></p>
  <h4>Следующий раздел</h4>
  <p class="topless"><a href="SmileReference.html"
                        title="следующая глава"><span class="section-number">3. </span>Язык программирования Smile. Предварительное описание</a></p>
  <div role="note" aria-label="source link">
    <h3>Эта страница</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/ModelReference.rst.txt"
            rel="nofollow">Исходный текст</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Быстрый поиск</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Искать" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Навигация</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Алфавитный указатель"
             >указатель</a></li>
        <li class="right" >
          <a href="SmileReference.html" title="3. Язык программирования Smile. Предварительное описание"
             >вперёд</a> |</li>
        <li class="right" >
          <a href="Introduction.html" title="1. Введение"
             >назад</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">документация smile </a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">2. </span>Статически типизированная модель модель функционально-потоковых параллельных вычислений</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Alexander Legalov.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.5.2.
    </div>
  </body>
</html>
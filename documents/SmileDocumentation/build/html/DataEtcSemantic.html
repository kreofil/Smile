
<!DOCTYPE html>

<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Семантика хранилищ &#8212; документация smile </title>
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/translations.js"></script>
    <link rel="shortcut icon" href="_static/smile48.png"/>
    <link rel="index" title="Алфавитный указатель" href="genindex.html" />
    <link rel="search" title="Поиск" href="search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Навигация</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Алфавитный указатель"
             accesskey="I">указатель</a></li>
        <li class="nav-item nav-item-0"><a href="index.html">документация smile </a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Семантика хранилищ</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="id1">
<h1>Семантика хранилищ<a class="headerlink" href="#id1" title="Ссылка на этот заголовок">¶</a></h1>
<p>Наряду с тем, что различные типы данных используются в качестве аргументов в операторе интерпретации, они также имеют определенную структуру, которая определяет специфику представления этих данных в хранилищах. Особенностью хранилищ является то, что к ним применяется ограниченный набор функций. Этот набор ограничен чтением из хранилищ и записью в них (с соблюдением принципа единственного присваивания). Но даже описание операций чтения-записи требует определенного синтаксического сахара для их более удобного и понятного представления в языке (<em>последнее со стороны может выглядеть сомнительно</em>).</p>
<div class="section" id="id2">
<h2>Хранилища атомарных данных<a class="headerlink" href="#id2" title="Ссылка на этот заголовок">¶</a></h2>
<p>Чтение атомарных данных задается обращением к хранилищам как к аргументам по имени хранилища. То есть, здесь никаких вопросов не возникает. Обращение обычно эквивалентно к использованию переменных в традиционных языках программирования.</p>
<p>Пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">чтение</span> <span class="n">из</span> <span class="n">хранилищ</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="n">и</span> <span class="n">сложение</span>
<span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span><span class="o">+</span>
</pre></div>
</div>
<p>Запись в атомарное хранилище также осуществляется по аналогии с записью в обычные переменные. Однако особенностью в данном случае является то, что хранилище используется в качестве функции в операторе интерпретации, который принимает поступающие данные и записывает их в хранилище:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">запись</span> <span class="n">данных</span> <span class="n">в</span> <span class="n">целочисленное</span> <span class="n">хранилище</span> <span class="n">a</span>
<span class="n">a</span><span class="nd">@int</span>
<span class="mi">10</span><span class="p">:</span><span class="n">a</span>
</pre></div>
</div>
<p>Следует отметить, что тип записываемых данных должен совпадать с типом хранилища.</p>
</div>
<div class="section" id="id3">
<h2>Общие особенности хранилищ составного типа<a class="headerlink" href="#id3" title="Ссылка на этот заголовок">¶</a></h2>
<p>Независимо от типа составного хранилища, чтение и запись в них осуществляется одинаково в случае, когда каждое из таких хранилищ построено на основе именованного типа. В этом случае описание хранилища практически не отличается от описания хранилищ атомарных типов. Чтение осуществляется обращением целиком ко всем данным, а селективна выборка при этом может определяться соответствием между типом хранилища и функцией, задаваемой в операторе интерпретации. При этом допускается неявное приведение типов данных в соответствии со сформированной сигнатурой функции</p>
<p>Простейший вариант чтения заключается во взаимодействии одноименных по типу хранилищ, когда данные из одного копируются в другое:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">intPair</span> <span class="o">&lt;&lt;</span> <span class="o">@</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="n">a</span><span class="p">:</span><span class="n">intPair</span>
<span class="n">b</span><span class="p">:</span><span class="n">intPair</span>
<span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">):</span><span class="n">intPair</span><span class="p">:</span><span class="n">a</span>     <span class="o">//</span> <span class="n">явное</span> <span class="n">преобразование</span> <span class="n">типа</span> <span class="nb">tuple</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="n">a</span><span class="p">:</span><span class="n">b</span>                 <span class="o">//</span> <span class="n">запись</span> <span class="n">из</span> <span class="n">a</span> <span class="n">в</span> <span class="n">b</span> <span class="n">где</span> <span class="n">b</span> <span class="n">рассматривается</span> <span class="n">как</span> <span class="n">функция</span>
                    <span class="o">//</span> <span class="n">с</span> <span class="n">сигнатурой</span><span class="p">:</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">func</span> <span class="n">x</span><span class="nd">@Pair</span> <span class="o">-&gt;</span> <span class="n">signal</span>
</pre></div>
</div>
<p>Вместе с тем следует отметить, что специфические особенности организации каждого из хранилищ ведут к ряду особенностей, связанных с обращением к ним.</p>
</div>
<div class="section" id="id4">
<h2>Особенности хранилищ векторного типа<a class="headerlink" href="#id4" title="Ссылка на этот заголовок">¶</a></h2>
<p>Наряду с непосредственным копированием данных между векторами одинакового типа и размера возможны различные варианты организации чтения из вектора элемента по индексу. Первый вариант связан с использованием целочисленных величин в качестве индексов. Он позволяет прочитать элемент в качестве разультата:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(1, 2, 3, 4, 5):vector: 3 ⇒ 3
(1, 2, 3, 4, 5):vector: i ⇒ результат - i-й элемент вектора
</pre></div>
</div>
<p>Другой вариант связан с представлением операции обращения к вектору с использованием специального его обозначения:</p>
<p><strong>ЭлементВектора = ИмяВектора «(» Индекс «)».</strong></p>
<p>Данный вариант полностью эквивалентен предыдущему, но может использоваться только в случае, когда вектор имеет имя:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>A &lt;&lt; (1, 2, 3, 4, 5):vector
A(3) ⇒ 3
B &lt;&lt; (1, 2, 3, 4, 5):vector
B(i) ⇒ результат - i-й элемент вектора
</pre></div>
</div>
<p>В качестве индекса допускается как целочисленная константа, так и целочисленное значение, полученное в ходе вычислений. Следует отметить, что в первом случае выход за границы вектора определяется компилятором.</p>
<p>Запись в вектор возможна только в том случае, если он предварительно объявлен как незаполненное хранилище. При этом конструкция, определяющая элемент вектора используется как функция в операторе интерпретации:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="nd">@int</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="mi">7</span><span class="p">:</span><span class="n">A</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="mi">10</span><span class="p">:</span><span class="n">A</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>При попытке повторно записать в уже заполненный элемент, запрещенное принципом единственного присваивания, происходит прерывание программы</p>
</div>
<div class="section" id="id5">
<h2>Особенности хранилищ имеющих тип кортеж<a class="headerlink" href="#id5" title="Ссылка на этот заголовок">¶</a></h2>
<p>Чтение-запись с использованием кортежей во многом напоминает аналогичные операции с векторами. Однако имеются и свои особенности. Спецификой кортежей является наличие в них элементов разных типов. Поэтому основной вид доступа связан с использованием в качестве индекса целочисленной константы. В этом случае компилятор может точно определить тип результата:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(1, 2, 3, 4, 5): 3 ⇒ 3@int
(3, true, !): 2 ⇒ true@bool
</pre></div>
</div>
<p>Ошибка компиляции происходит в том случае, если в качестве индекса выступает величина вычисляемая во время выполнения программы. Однако имеется исключение. Если все элементы кортежа имеют один и тот же тип, компилятор может допустить использование вычисляемой величины, так как тип результата становится известным:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(1, 2, 3, 4, 5): i ⇒ результат - i-й элемент кортежа однотипных элементов типа int
(3, true, !): j ⇒ ошибка компиляции
</pre></div>
</div>
<p>Для организации чтения может использоваться целое число как функция оператора интерпретации или обозначение элемента кортежа, аналогичное по синтаксису элементу вектора:</p>
<p><strong>ЭлементКортежа = ИмяКортежа «(» Индекс «)».</strong></p>
<p>Запись в кортеж-хранилище осуществляет по тем же правилам, что и чтение. В общем случае она происходит, если индекс задается константой, позволяющий сопоставить типы записываемых данных и поля кортежа. Вычисляемая величина допускается в качестве индекса, если все поля кортежа однотипны.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span><span class="o">@</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">signal</span><span class="p">)</span>
<span class="n">false</span><span class="p">:</span><span class="n">X</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="mi">10</span><span class="p">:</span><span class="n">A</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h2>Особенности структурных хранилищ<a class="headerlink" href="#id6" title="Ссылка на этот заголовок">¶</a></h2>
<p>По разнотипности своих элементов структуры аналогичны кортежам. Однако для доступа к полям структуры используются внутренние имена этих полей, с каждым из которых сопоставлен тип. Поэтому чтение-запись реализованы только с использованием этих полей без каких либо вычислений. Обычный доступ осуществляется через имя хранилища, после которого через точку следует имя поля:</p>
<p><strong>ЭлементСтруктуры = ИмяХранилища «.» ИмяПоля.</strong></p>
<p>Однако возможны ситуации, когда результат структурного типа формируется в ходе вычислений. В этом случае имя поля, предваряемого точкой, может быть указано в качестве функции в операторе интерпретации:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>TS &lt;&lt; @(x@int, b@bool)
S@TS
// Здесь какие-то вычисления порождающие структуру в качестве результата
...:TS:.b  // После приведения к типу TS на выходе будет значение поля b
S.a ⇒ возвращает значение поля a структуры S
S:.a ⇒ аналогичный результат
</pre></div>
</div>
<p>Запись в структуру-хранилище осуществляется с явным использованием элемента структуры в качестве аргумента-функции оператора интерпретации:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">S</span><span class="o">@</span><span class="p">(</span><span class="n">i</span><span class="nd">@int</span><span class="p">,</span> <span class="n">b</span><span class="nd">@bool</span><span class="p">,</span> <span class="n">s</span><span class="nd">@signal</span><span class="p">)</span>
<span class="n">false</span><span class="p">:</span><span class="n">S</span><span class="o">.</span><span class="n">b</span>
<span class="mi">10</span><span class="p">:</span><span class="n">S</span><span class="o">.</span><span class="n">i</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h2>Особенности хранилищ роевого типа<a class="headerlink" href="#id7" title="Ссылка на этот заголовок">¶</a></h2>
<p>Спецификой роя является асинхронное поступление данных и, как следствие отдельная сигнализация о поступлении каждого элемента в связанный с ним оператор интерпретации. Вместе с тем обращение к рою по индексу практически аналогично обращению к вектору. При отсутствии элемента происходит ожидание его появления. Поэтому возможны те же варианты:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>[1, 2, 3, 4, 5]: 3 ⇒ 3
[1, 2, 3, 4, 5]: i ⇒ результат - i-й элемент роя
</pre></div>
</div>
<p>Другой вариант связан с представлением операции обращения к рою с использованием специального его обозначения:</p>
<p><strong>ЭлементРоя = ИмяРоя «[» Индекс «]».</strong></p>
<p>Данный вариант полностью эквивалентен предыдущему, но может использоваться только в случае, когда Рой имеет имя:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>R &lt;&lt; [1, 2, 3, 4, 5]
A[3] ⇒ 3
Q &lt;&lt; [1, 2, 3, 4, 5]
Q[i] ⇒ результат - i-й элемент роя
</pre></div>
</div>
<p>В качестве индекса допускается как целочисленная константа, так и целочисленное значение, полученное в ходе вычислений. Следует отметить, что в первом случае выход за границы роя определяется компилятором.</p>
<p>Запись в рой возможна только в том случае, если он предварительно объявлен как незаполненное хранилище. При этом конструкция, определяющая элемент роя используется как функция в операторе интерпретации:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">R</span><span class="nd">@int</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
<span class="mi">7</span><span class="p">:</span><span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="mi">10</span><span class="p">:</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>При попытке повторно записать в уже заполненный элемент, запрещенное принципом единственного присваивания, происходит прерывание программы</p>
<div class="section" id="id8">
<h3>Реагирование и доступ по мере поступления элементов в рой<a class="headerlink" href="#id8" title="Ссылка на этот заголовок">¶</a></h3>
<p>Если рой является аргументом, то оператор интерпретации реагирует на появление каждого элемента. В этом случае можно использовать функции, которые также срабатывают на каждый элемент и обрабатывают рой по мере поступления отдельных данных, не дожидаясь полной синхронизации, как это происходит в случае вектора, кортежа или структуры.</p>
<p>Для реализации дополнительных возможностей предполагается использовать ссылки, каждая из которых имеет дополнительные независимые механизмы по контролю за данными поступающими в рой.</p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p><em>Данный фрагмент нужно еще обдумать и дописать</em></p>
</div>
</div>
</div>
<div class="section" id="id9">
<h2>Особенности хранилищ - потоков<a class="headerlink" href="#id9" title="Ссылка на этот заголовок">¶</a></h2>
<p>Основной спецификой потоков является отсутствие информации о количестве поступающих данных. В результате завершение потока определяется по достижению «маркера дна». То есть, признака, указывающего на то, что данные в потоке отсутствуют и больше не появятся. В связи с этим возникает определенная специфика в формировании семантики этого артефакта.</p>
<p>В целом поведение потока во многом аналогично поведению асинхронного списка, реализованного в языке программирования Пифагор. Однако ряд специфических моментов требуют других решений при манипуляции с ним.</p>
<p>Первая особенность заключается в том, что при чтении данных может возвратиться или значение, или признак завершения данных. При использовании статической типизации это два разных вида информации, поэтому необходимо разделение возвращаемых данных, которое можно сделать реализовав две функции:</p>
<blockquote>
<div><ul class="simple">
<li><p>функцию проверку на наличие в потоке данных (<code class="docutils literal notranslate"><span class="pre">is</span></code>), которая возвращает <code class="docutils literal notranslate"><span class="pre">true</span></code>, если данные еще поступают, и <code class="docutils literal notranslate"><span class="pre">false</span></code> если данные в поток поступать перестали;</p></li>
<li><p>функцию получения элемента из потока (<code class="docutils literal notranslate"><span class="pre">get</span></code>), которая при наличии в нем данных выбирает первый элемент, тип которого определяется из описания потока, а отсутствие данных ведет к прерыванию программы.</p></li>
</ul>
</div></blockquote>
<p>Помимо этого необходимо вытолкнуть из потока прочитанный элемент, чтобы иметь доступ к следующему. Для этого можно использовать функцию <code class="docutils literal notranslate"><span class="pre">pop</span></code>.</p>
<p>Вместе с тем использование нескольких функций может привести к коллизиям, если к потоку идет одновременное обращение из нескольких точек программы. Для предотвращения коллизий необходимо использовать атомарные функции, выполняющие все необходимые действия за один раз таким образом, чтобы при каждом обращении происходила корректная обработка данных. Можно например, совместить проверку с чтением элемента, возвращая пару значений: (данные, признак наличия данных). Если признак наличия данных будет равен <code class="docutils literal notranslate"><span class="pre">true</span></code>, то прочитаны корректные данные. Их можно обрабатывать. В противном случае данные неактуальны, так как поток завершил их порождение. Однако в этом случае коллизии могут все равно возникать и быть связаны с выталкиванием данных.</p>
<p>Более надежным смотрится вариант, когда в одной атомарной функции совмещаются все три, описанные выше. То есть, когда при наличии данных происходит их выдача в виде двойки и выталкивание элемента из потока. Тогда каждая из операций чтения будет брать только свои уникальные данные и убирать их из потока. При обращении множества операций к пустому потоку все они получат значение признака наличия данных, равное <code class="docutils literal notranslate"><span class="pre">false</span></code>. При этом прерывания программы не происходит. Предполагается, что в качестве такой неделимой операции будет использоваться применением потока в качестве данных оператора интерпретации. Например:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">S</span><span class="nd">@int</span><span class="p">{}</span>
<span class="p">(</span><span class="n">S</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="n">S</span><span class="p">:</span><span class="mi">1</span><span class="p">):</span><span class="o">+</span>
</pre></div>
</div>
<p>В примере демонстрируется двойное обращение к потоку, после чего полученные числа складываются. В данной ситуации порядок выдачи данных из потока недетерминирован. То есть неясно, в какой аргумент функции сложения попадет из потока первый элемент данных. Для реализации детерминированности необходимо формировать дополнительные сигналы обеспечивающие требуемую последовательность:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">S</span><span class="nd">@int</span><span class="p">{}</span>
<span class="n">x1</span> <span class="o">&lt;&lt;</span> <span class="n">S</span><span class="p">:</span><span class="mi">1</span>
<span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">S</span><span class="p">:{</span><span class="n">x1</span><span class="p">:</span><span class="n">signal</span><span class="p">}):</span><span class="o">+</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p>Расширить возможности манипуляций с потоком, поддерживающими многократное дублирование доступа, можно через ссылки. Но это отдельная тема для анализа и реализации. Пока нет.</p>
</div>
<p>Запись в поток осуществляет за счет использования имени потока в качестве функции:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">S</span><span class="nd">@int</span><span class="p">{}</span>
<span class="mi">5</span><span class="p">:</span><span class="n">S</span>
</pre></div>
</div>
<p>Можно также осуществлять непосредственную передачу данных из одного потока в другой, которая может сочетаться с передачей независимых данных. Порядок передачи при этом также может быть недетерминированнм:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">S1</span><span class="nd">@int</span><span class="p">{}</span>
<span class="n">S2</span><span class="nd">@int</span><span class="p">{}</span>
<span class="n">S1</span><span class="p">:</span><span class="n">S2</span>
<span class="mi">5</span><span class="p">:</span><span class="n">S2</span>
<span class="mi">10</span><span class="p">:</span><span class="n">S1</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p>Более детальную проработка описания потоков предполагается сделать, когда начнется разработка и анализ реализация функций - примеров.</p>
</div>
</div>
</div>
<div class="section" id="id10">
<h1>Семантика программоформирующих операторов<a class="headerlink" href="#id10" title="Ссылка на этот заголовок">¶</a></h1>
<p>Программоформирующие операторы обеспечивают группировку данных, используя предопределенные методы. Они также могутиспользоваться в качестве данных и функций в операторе интерпретации. Основное отличие от составных типов заключается в отсутствии предварительного описания. Поэтому текущее значение формируется во время вычислений. Однако использование статической типизации позволяет вывести тип во время компиляции и использовать полученный результат для контроля взаимодействия различных артефактов.</p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p>Следует отметить, что представленные ниже функции практически дублируют их использование в опереторе групповой интерпретации. Это ведет к определенной избыточности языка, что не является хорошей манерой. Поэтому, скорее всего, использование программоформирующих операторов в качестве функций пока будет запрещено. Возможно в перспективе, если появятся отличия в реализации, этот вопрос будет снова поднят. Ниже лежащий текст подраздела пока оставлен. Может быть он будет перенесен в раздел описывающий семантику оператора групповой интерпретации.</p>
<p>Возможно, что изменения могут затронуть именно групповую интерпретацию…</p>
<p>Последнее ощущение, что в данном операторе оставлю как есть…</p>
</div>
<div class="section" id="id11">
<h2>Оператор группировки в кортеж<a class="headerlink" href="#id11" title="Ссылка на этот заголовок">¶</a></h2>
<p>Используется для объединения как однотипных, так и неоднотипных данных. Если группируются данные одного типа, то результат группировки может обрабатываться как аргумент функции, манипулирующей векторами. Основная задача данного оператора заключается в синхронизации поступающих данных перед последующим использованием. То есть, готовность к выполнению оператора интерпретации, в котором кортеж используется в качестве одного из аргументов сформируется тогда, когда будут вычислены все элементы кортежа. Кортеж может являться аргументом-данными как в предопределенных функциях, так и в функциях разрабатываемых пользователем. В этом случае особенности его выполнения связаны с особенностями  семантики аргумента-функции оператора интерпретации.</p>
<p>С другой стороны кортеж может использоваться в качестве аргумента функции одиночного оператора интерпретации. В этой ситуации каждый элемент внутри кортежа определяется как отдельная функция, которая осуществляет обработку одного и того же аргумента-данных. Результатом выполнения является кортеж, в котором собраны все вычисленные величины. Можно привести эквивалентное преобразование, определяющее одну из формул алгебры преобразования языка программирования:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>data:(f1, f2, f3, ... fn) ≡ (data:f1, data:f2, data:f3, ... data:fn)
</pre></div>
</div>
<p>Пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(10, 3):(+, -, *, /, %) ⇒ (13, 7, 30, 3, 1)
</pre></div>
</div>
</div>
<div class="section" id="id12">
<h2>Оператор группировки в рой<a class="headerlink" href="#id12" title="Ссылка на этот заголовок">¶</a></h2>
<p>Используется для асинхронной группировки, когда появление каждого элемента сопровождается передачей информации оператору интерпретации. Использование роя в качестве аргумента-данных зависит от того, какая функция над ним выполняется. Когда рой является аргументом-функцией оператора интерпретации, то его поведение во многом аналогично использованию в качестве функции кортежа. Вместе с тем, если функции вычисляются, то есть, формируются в разныем моменты времени, то обработка данных осуществляется асинхронно, также независимо на выходе появляются результаты вычислений, которые группируются в соответствующем рое. Следующая формула описывает эквивалетное преобразование роя:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>data:[f1, f2, f3, ... fn] ≡ [data:f1, data:f2, data:f3, ... data:fn]
</pre></div>
</div>
<p>Пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(10, 3):[+, -, *, /, %] ⇒ [13, 7, 30, 3, 1]
</pre></div>
</div>
<p>Следует отметит, что все элементы роя, выступающие в роли функций, по определению должны иметь одинаковую сигнатуру и порождать на выходе однотипные результаты в отличие от результатов, которые могут порождать функции, сгруппированные в кортеж.</p>
</div>
<div class="section" id="id13">
<h2>Оператор группировки в поток<a class="headerlink" href="#id13" title="Ссылка на этот заголовок">¶</a></h2>
<p>Данный оператор используется для формирования асинхронно порождаемых последовательностей. Как и другие операторы группировки он позволяет объединить несколько элементов окончательно формируемые значения которых должны быть одного типа. Спецификой данного оператора является отсутствие фиксированной длины, что позволяет использовать в качестве элементов другие операторы группировки в поток, порождающие данные того же типа, что и тип оператора группировки. Использование в качестве аргумента-данных, как и в предыдущих операторах, предполагает, что семантика определяется аргументом-функцией, обрабатывающей данный поток. Семантика при использовании оператора в качестве аргумента-функции определяется теми элементами, которые поступают в поток и применяются в порядке поступления к каждому аргументу. Следует отметить, что в связи с асинхронностью и разным временем обработки аргумента-данных расположение результатов в выходном потоке может отличаться от порядка функций в исходном потоке. Обработка данных потоком функций может быть представлена следующим образом:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>data:stream{f1, f2, f3, ... fn} ≡ stream{data:f1, data:f2, data:f3, ... data:fn}
</pre></div>
</div>
<p>Пример выполнения, демонстрирующий один из вариантов возможной недетерминированной перестановки результатов на выходе, что определяется спецификой обработки:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(10, 3):stream{+, -, *, /, %} ⇒ stream{7, 13, 1, 3, 30}
</pre></div>
</div>
</div>
<div class="section" id="id14">
<h2>Оператор задержки<a class="headerlink" href="#id14" title="Ссылка на этот заголовок">¶</a></h2>
<p>Основное назначение данного оператора заключается в задержке вычислений описанного в нем выражения независимо от того будет результат использоваться в качестве данных или функции. Оператор интерпретации раскрывает задержку, что ведет к ранее отложенному вычислению результата, тип которого определяется в зависимости от написанного выражения. Дальнейшая обработка полученной величины оператором интерпретации зависит от этого типа. Каких-либо дополнительных особенностей семантики оператора задержки нет.</p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p>Следует отметить, что в принципе возможны и другие эквивалентные способы группировки и выполнения вычислений, аналогичные описанным. Они возникают из-за возможности предварительного описания величин с последующей записью в них данных с применением принципа единственного присваивания. Также свой вклад может внести использование массового оператора интерпретации. Все эти варианты предполагается рассмотреть и сравнить в разделе примеров, описывающих технику программирования. Также обобщение вариантов предполагается сделать в разделе по алгебре эквивалентных преобразований.</p>
</div>
</div>
</div>
<div class="section" id="id15">
<h1>Использование функций с массовым оператором интерпретации<a class="headerlink" href="#id15" title="Ссылка на этот заголовок">¶</a></h1>
<p>Применение массового оператора интерпретации в первую очередь ориентирована о использование одной функции для обработки множества данных (эквивалентно стратегии ОКМД в классификации Флинна). Предполагается что данные одного типа размещаются в контейнере (вектор, рой, поток) и к ним применяется одна и та же функция, формируя на выходе контейнер результатов такого же типа. Подобные преобразования можно описать следующими выражениями:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(d1, d2, ... dn)::f ≡ (d1:f, d2:f, ... dn:f)
[d1, d2, ... dn]::f ≡ [d1:f, d2:f, ... dn:f]
stream{d1, d2, ... dn}::f ≡ stream{d1:f, d2:f, ... dn:f}
</pre></div>
</div>
<p>Следует отметить, что в случае потока результаты на выходе могут не соответствовать порядку, определяемому исходными данными, так как возможны недетерминированные перестановки, связанные с разным временем выполнения функций.</p>
<p>Помимо этого возможна ситуация, когда один элемент данных обрабатывается нескольким функциями:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>d::(f1, f2, ... fk) ≡ (d:f1, d:f2, ... d:fk)
d::[f1, f2, ... fk] ≡ [d:f1, d:f2, ... d:fk]
d::stream{f1, f2, ... fk} ≡ stream{d:f1, d:f2, ... d:fk}
</pre></div>
</div>
<p>То есть, данная ситуация эквивалентна случаю, связанному с использованием программоформирующих операторов в качестве функций.</p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p>Возможно это тот повод, который позволит отменить использование при одиночной интерпретации программоформирующие операторы в качестве функций. Зачем дублировать? Может тогда и другие проблемы и вопросы будут сняты. Надо думать…</p>
<p>Но пока хочется одиночный вариант оставить…</p>
</div>
<p>Другим фактором, определяющим специфику массового оператора интерпретации является то, что аргумент-функция может также задаваться с использованием программоформирующих операторов. Поэтому в ряде случаев возможно появление множества функций, обрабатывающих множество потоков. При этом контейнерные типы данных могут отличаться от контейнерных типов функций. То есть возможны следующие комбинации:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(d1, d2, ... dn)::(f1, f2, ... fk) ≡
    (d1:(f1, f2, ... fk), d2:(f1, f2, ... fk), ... dn:(f1, f2, ... fk)) ≡
        ((d1:f1, d1:f2, ... d1:fk), (d2:f1, d2:f2, ... d2:fk) ... (dn:f1, dn:f2, ... dn:fk))

[d1, d2, ... dn]::(f1, f2, ... fk) ≡
    [d1:(f1, f2, ... fk), d2:(f1, f2, ... fk), ... dn:(f1, f2, ... fk)] ≡
        [(d1:f1, d1:f2, ... d1:fk), (d2:f1, d2:f2, ... d2:fk) ... (dn:f1, dn:f2, ... dn:fk)]

(d1, d2, ... dn)::[f1, f2, ... fk] ≡
    (d1:[f1, f2, ... fk], d2:[f1, f2, ... fk], ... dn:[f1, f2, ... fk]) ≡
        ([d1:f1, d1:f2, ... d1:fk], [d2:f1, d2:f2, ... d2:fk] ... [dn:f1, dn:f2, ... dn:fk])

[d1, d2, ... dn]::[f1, f2, ... fk] ≡
    [d1:[f1, f2, ... fk], d2:[f1, f2, ... fk], ... dn:[f1, f2, ... fk]] ≡
        [[d1:f1, d1:f2, ... d1:fk], [d2:f1, d2:f2, ... d2:fk] ... [dn:f1, dn:f2, ... dn:fk]]

и далее все комбинации, включая потоки.
</pre></div>
</div>
<p>То есть, в этом случае в начале контейнерная функция применяется к каждому из элементов данных, после чего идет дальнейшее разложение. Как и в более простых ситуациях комбинации с потоками ведут к недетерминированным вычислениям и смене порядка следования результатов относительно порядка в исходых данных.</p>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Оглавление</a></h3>
  <ul>
<li><a class="reference internal" href="#">Семантика хранилищ</a><ul>
<li><a class="reference internal" href="#id2">Хранилища атомарных данных</a></li>
<li><a class="reference internal" href="#id3">Общие особенности хранилищ составного типа</a></li>
<li><a class="reference internal" href="#id4">Особенности хранилищ векторного типа</a></li>
<li><a class="reference internal" href="#id5">Особенности хранилищ имеющих тип кортеж</a></li>
<li><a class="reference internal" href="#id6">Особенности структурных хранилищ</a></li>
<li><a class="reference internal" href="#id7">Особенности хранилищ роевого типа</a><ul>
<li><a class="reference internal" href="#id8">Реагирование и доступ по мере поступления элементов в рой</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id9">Особенности хранилищ - потоков</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id10">Семантика программоформирующих операторов</a><ul>
<li><a class="reference internal" href="#id11">Оператор группировки в кортеж</a></li>
<li><a class="reference internal" href="#id12">Оператор группировки в рой</a></li>
<li><a class="reference internal" href="#id13">Оператор группировки в поток</a></li>
<li><a class="reference internal" href="#id14">Оператор задержки</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id15">Использование функций с массовым оператором интерпретации</a></li>
</ul>

  <div role="note" aria-label="source link">
    <h3>Эта страница</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/DataEtcSemantic.rst.txt"
            rel="nofollow">Исходный текст</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Быстрый поиск</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Искать" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Навигация</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Алфавитный указатель"
             >указатель</a></li>
        <li class="nav-item nav-item-0"><a href="index.html">документация smile </a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Семантика хранилищ</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Alexander Legalov.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.5.2.
    </div>
  </body>
</html>

<!DOCTYPE html>

<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"><meta content="Описание концепций, языковых и инструментальных средств функционально-потокового параллельного программирования." name="description" />
<meta content="парадигмы программирования, функционально-потоковое параллельное программирование" name="keywords" />

    <title>8. Размышления по поводу модуля базовых артефактов &#8212; документация smile </title>
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script src="_static/translations.js"></script>
    <link rel="shortcut icon" href="_static/smile48.png"/>
    <link rel="index" title="Алфавитный указатель" href="genindex.html" />
    <link rel="search" title="Поиск" href="search.html" />
    <link rel="next" title="9. Организация модульной структуры" href="ModuleStructure.html" />
    <link rel="prev" title="7. Семантическая модель системы программирования и языка" href="SemModel.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Навигация</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Алфавитный указатель"
             accesskey="I">указатель</a></li>
        <li class="right" >
          <a href="ModuleStructure.html" title="9. Организация модульной структуры"
             accesskey="N">вперёд</a> |</li>
        <li class="right" >
          <a href="SemModel.html" title="7. Семантическая модель системы программирования и языка"
             accesskey="P">назад</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">документация smile </a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">8. </span>Размышления по поводу модуля базовых артефактов</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="id1">
<h1><span class="section-number">8. </span>Размышления по поводу модуля базовых артефактов<a class="headerlink" href="#id1" title="Ссылка на этот заголовок">¶</a></h1>
<p>В данном тексте я пытаюсь высказать соображения по поводу аксиоматического описания набора базовых артефактов (типов, операций, может быть и констант) в некотором системном модуле или модуле System.
В данном случае речь не идет о копировании идеи из Оберона, имеющего такой модуль. Под модулем понимается репозиторий. С таким же успехом его можно обозвать пакетом или сборкой. Но в любом случае мы имеем изолированную конструкцию, которая включает в себя набор артефактов, для доступа к которым используется интерфейсный артефакт, экспортирующий описания, или интерфейс экспорта. В настоящий момент он задается файлом <code class="docutils literal notranslate"><span class="pre">export</span></code>.</p>
<p>Основной идеей модуля System является описание набора базовых типов, определяющих элементарную аксиоматику языка. Подразумевается, что за счет набора этих описаний можно ориентировать язык на различные наборы типов и базовых операций. То есть в результате мы будем иметь не конкретный язык программирования с заданными типами данных и операций над ними, а некоторую оболочку конструктивов, наполняемую в зависимости от того, в рамках какой предметной области мы собираемся использовать функционально-потоковую парадигму программирования.</p>
<p>Появляется некоторый аналог суперкласса, который не хотелось бы называть суперязыком (нужно придумать название, например, над-язык), но от которого как бы наследуют механизм конструирования алгоритмов различные дочерние языки (под языки). Это наследование или расширение проявляется в описании семантики базовых типов и операций над ними, которые фиксируются в различных описаниях экспорта экспорта.</p>
<p>На уровне компиляции, когда на выходе формируется реверсивный информационный граф (РИГ) семантика этих описаний особой роли не играет. Основной анализ корректности осуществляется на основе анализа корректного использования описанных базовых типов и базовых функций (операций над базовыми типами или простот операций). Реальная семантика конкретного подъязыка проявляется только в момент генерации кода объектной машины или в ходе интерпретации функции, задаваемой информационным графом, когда каждому базовому артефакту начинает сопоставляться конкретный набор структур данных и методов их обработки, непосредственно привязанный к соответствующему исполнителю.</p>
<p>Для чего это предполагается использовать? При обычном построении компилятора с языка Smile все базовые типы и операции их обработки нужно вводить в структуры данных, образующих списки базовых артефактов, непосредственным кодированием в программе. Расширение базовой семантики или ее модификация, а также изменение ведут к изменению соответствующего программного кода. Это в принципе не такая сложная задача. Вместе с тем, доступ ко всем этип артефактам в основном осуществляется по именам и знакам спецсимволов, что в принципе позволяет хранить сформированные программным путем описания базовых артефактов во внешнем формате, аналогичном форматам артефактов, создаваемых программистом. Поэтому можно вместо кода даже для моноязыка (еще один вариант названия для обычного языка) загружать соответствующие описания из описания базовых артфактов. Это описание можно увязать с модулем System, подгружаемым по умолчанию.</p>
<p>Развивая эту идею можно перейти к концепции полиязыка (еще один вариант названия для суперязыка), на основе которого можно создавать различные конечные языки - наследующие конструктив, но имеющие собственную семантику типов и операционную семантику, определяемую соответствующими аксиомами, корректность которой на базовом уровне можно обеспечить формальными методами.</p>
<div class="section" id="id2">
<h2><span class="section-number">8.1. </span>Фрагмент модуля систем для подъязыка с традиционной семантикой<a class="headerlink" href="#id2" title="Ссылка на этот заголовок">¶</a></h2>
<p>В качестве примера можно рассмотреть, каким образом во внешних описаниях может быть представлены базовые типы и операции для традиционного языка программирования, реализуемого в настоящий момент.</p>
<p>Пусть в модуле System (в текущей версии это соответствующий каталог) хранится описание базовых артефактов (в данный момент это файл export) в соответствии с принятым форматом.</p>
<div class="section" id="id3">
<h3><span class="section-number">8.1.1. </span>Описания артефактов в списке экспорта<a class="headerlink" href="#id3" title="Ссылка на этот заголовок">¶</a></h3>
<p><strong>Описания базовых типов данных.</strong> Следует отметить, что значения для базовых типов не задается, так как их реальные параметры определяются в семантике интерпретатора или генератора кода. Однако для обозначения базового типа используется дополнительный признак в виде минуса. Например:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="nb">int</span> <span class="o">-</span>
<span class="nb">type</span> <span class="nb">bool</span> <span class="o">-</span>
<span class="nb">type</span> <span class="n">char</span> <span class="o">-</span>
<span class="nb">type</span> <span class="n">real</span> <span class="o">-</span>
</pre></div>
</div>
<p>На основе описаний базового типа формируются производные типы, используемые для описания операций. Например, типы, определяющие группировки в целочисленные и действительные пары:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">intpair</span> <span class="n">datalist</span> <span class="mi">2</span> <span class="nb">int</span> <span class="nb">int</span>
<span class="nb">type</span> <span class="n">realpair</span> <span class="n">datalist</span> <span class="mi">2</span> <span class="n">real</span> <span class="n">real</span>
</pre></div>
</div>
<p>На основе базовых и производных от них типов можно формировать различные операции, включая и операции, обозначаемые специальными символами:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">function</span> <span class="o">+</span> <span class="n">intpair</span> <span class="nb">int</span>
<span class="n">function</span> <span class="o">+</span> <span class="n">realpair</span> <span class="n">real</span>
</pre></div>
</div>
<p>Выше определяются базовые функции заданные спецсимволом + над парой целых с выдачей целого и над парой действительных с выдачей действительного. Следует отметить, что сама семантика операций, как и структура базовых типов в этом описании не задается (то есть, знак «+» может подразумевать что угодно). Она определяется на уровне формального описания семантики, например, с использованием методов формальной верификации, а впоследствии это формальное описание реализуется в виде интерпретатора или генератора кода.</p>
</div>
<div class="section" id="id4">
<h3><span class="section-number">8.1.2. </span>Вариант ввода новых базовых описаний<a class="headerlink" href="#id4" title="Ссылка на этот заголовок">¶</a></h3>
<p>Заполнять список экспорта модуля System вручную - неблагодарное занятие. Поэтому в компилятор можно ввести режим, когда он обрабатывает артефакт из модуля System, на основании которого порождает новое описание также, как и для обычного модуля.
Тогда, например, ранее введенные примеры можно добавить в список экспорта, откомпилировав следующие артефакты в качестве отдельных единиц компиляции:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="o">&lt;&lt;</span> <span class="n">typedef</span><span class="p">;</span>
<span class="nb">bool</span> <span class="o">&lt;&lt;</span> <span class="n">typedef</span><span class="p">;</span>
<span class="n">char</span> <span class="o">&lt;&lt;</span> <span class="n">typedef</span><span class="p">;</span>
<span class="n">real</span> <span class="o">&lt;&lt;</span> <span class="n">typedef</span><span class="p">;</span>
<span class="n">intpair</span> <span class="o">&lt;&lt;</span> <span class="n">typedef</span> <span class="o">@</span><span class="p">(</span><span class="mi">2</span><span class="nd">@int</span><span class="p">);</span>
<span class="n">realpair</span> <span class="o">&lt;&lt;</span> <span class="n">typedef</span> <span class="o">@</span><span class="p">(</span><span class="mi">2</span><span class="nd">@real</span><span class="p">);</span>
<span class="o">+</span> <span class="o">&lt;&lt;</span> <span class="n">funcdef</span> <span class="nd">@intpair</span> <span class="o">-&gt;</span> <span class="nd">@int</span><span class="p">;</span>
<span class="o">+</span> <span class="o">&lt;&lt;</span> <span class="n">funcdef</span> <span class="nd">@realpair</span> <span class="o">-&gt;</span> <span class="nd">@real</span><span class="p">;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id5">
<h2><span class="section-number">8.2. </span>Возражения<a class="headerlink" href="#id5" title="Ссылка на этот заголовок">¶</a></h2>
<p>Несмотря на то, что данная концпция построения предметно-ориентированных языков на базе общего надъязыка выглядит привлекательной, существует ряд <em>очевидных</em> моментов, которые не позволяют ее реализовать без проблем. К ним можно отнести следующие.</p>
<ol class="arabic simple">
<li><p><strong>Что делать с константами?</strong> Константы и константные выражения заточены на конкретные базовые типы и операции. Они обычно реализуются с использованием кода, встроенного в компилятор, что не позволяет осуществлять безболезненную замену для них как базовых типов, так и операций обработки. Другим моментом является то, что синтаксис констант также привязан к базовому типу и операциями над ним. Поэтому введение новых типов требует и переопределения константных выражений, трудно вынимаемое из уже написанного кода. Речь не идет о проблемах выделения модулей. Речь о том, что семантика констант сама по себе изменяется на другую достаточно болезненно, так как затрагивает изменения в синтаксисе языка и семантике, определяемой этим синтаксисом.</p></li>
<li><p><strong>Как задавать внутреннее представление для базовых типов данных?</strong> В текущей реализации каждый базовый тип определяется своим классом (структурой). Для каждого из базовых типов используется свое обозначение в перечислимом типе данных. Необходимо будет унифицировать систему, введя для всех базовых типов единый класс и его признак в перечне типов. Сами же типы нужно будет идентифицировать, по всей видимости, по имени. В целом это не такая большая проблема, которая вместо сравнения и другим операци с перечислимыми типами приведет к сопоставлению строк символов.</p></li>
<li><p><strong>Вопросы написания кода, реализующие семантику расширений.</strong> Необходимо продумать, каким образом добавлять в программу код, обеспечивающий реализацию новых проблемно-ориентированных расширений, а также как убирать код, который уже не нужен. Проблема для константных выражений. Для генератора кода и интерпретатора решения вроде бы проглядываются.</p></li>
</ol>
</div>
<div class="section" id="id6">
<h2><span class="section-number">8.3. </span>Резюме<a class="headerlink" href="#id6" title="Ссылка на этот заголовок">¶</a></h2>
<p>В рамках текущего проекта остаюсь на прямой реализации, так как основной проблемой является работа с константными выражениями. О возможном более гибком решении буду думать позднее.
Для базовых операция можно добавить отдельный список со своими именами и спецсимволами, загружаемый на этапе инициализации.</p>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Оглавление</a></h3>
  <ul>
<li><a class="reference internal" href="#">8. Размышления по поводу модуля базовых артефактов</a><ul>
<li><a class="reference internal" href="#id2">8.1. Фрагмент модуля систем для подъязыка с традиционной семантикой</a><ul>
<li><a class="reference internal" href="#id3">8.1.1. Описания артефактов в списке экспорта</a></li>
<li><a class="reference internal" href="#id4">8.1.2. Вариант ввода новых базовых описаний</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id5">8.2. Возражения</a></li>
<li><a class="reference internal" href="#id6">8.3. Резюме</a></li>
</ul>
</li>
</ul>

  <h4>Предыдущий раздел</h4>
  <p class="topless"><a href="SemModel.html"
                        title="предыдущая глава"><span class="section-number">7. </span>Семантическая модель системы программирования и языка</a></p>
  <h4>Следующий раздел</h4>
  <p class="topless"><a href="ModuleStructure.html"
                        title="следующая глава"><span class="section-number">9. </span>Организация модульной структуры</a></p>
  <div role="note" aria-label="source link">
    <h3>Эта страница</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/ModuleSystem.rst.txt"
            rel="nofollow">Исходный текст</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Быстрый поиск</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Искать" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Навигация</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Алфавитный указатель"
             >указатель</a></li>
        <li class="right" >
          <a href="ModuleStructure.html" title="9. Организация модульной структуры"
             >вперёд</a> |</li>
        <li class="right" >
          <a href="SemModel.html" title="7. Семантическая модель системы программирования и языка"
             >назад</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">документация smile </a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">8. </span>Размышления по поводу модуля базовых артефактов</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Alexander Legalov.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.1.2.
    </div>
  </body>
</html>
.. |date| date:: %d.%m.%Y
.. |time| date:: %H:%M
.. |copy| unicode:: 0xA9 .. copyright sign

.. Текущая дата |date| и время |time|

.. meta::
   :description: Описание концепций, языковых и инструментальных средств функционально-потокового параллельного программирования.
   :keywords: парадигмы программирования, функционально-потоковое параллельное программирование

:Author:    Александр Легалов
:Email:     <legalov@mail.ru>
:Date:      |date|
:Version:   0.1

:Copyright: |copy| Допускается свободное использование с обязательной ссылкой на сайт автора: "Оригинальная версия размещена на сайте www.softcraft.ru".

.. .. sectnum::
    :start: 1

.. .. contents:: Содержание
    :depth: 3


==========================================================
Форматы хранимых данных
==========================================================

Исходные данные, а также результаты компиляции хранятся в соответствующих форматах.

Описание экспорта
-------------------------

Экспортируемые данные используются для представления информации о результатах компиляции различных артефактов. Эта информация используется при компиляции новых артефактов, если есть соответствующие зависимости. Данные хранятся в специальном файле экспорта. При компиляции артефактов этот файл открываются, а данные хранимые в нем считываются в соответствующую таблицу компилятора. Информация о компилируемом артефакте также добавляется к экспортируемым данным и сохраняется в обновленном файле.

Описание экспорта (вариант представления)::

    pi<<const(float,3.14)
    pi2<<const(float,3.14159)
    newBool<<type(bool)
    triangle<<type(tuple(int,int,int))
    rectangle<<type(tuple(int,int))
    tuple01<<type(tuple(bool,int,float))
    func01<<func(int,bool),func(float,bool),func(bool,float)
    func02<<func(signal,float)
    func03<<func(signal,float)
    func04<<func(tuple(int,int),int)
    add<<func(tuple(int,int),int),func(tuple(float,float),float)
    newSignal<<type(signal)
    FuncSenSignal01<<func(signal,signal)
    FuncSenSignal02<<func(signal,signal)
    FuncSenSignal03<<func(int,signal)
    FuncInc01<<func(int,int),func(tuple(int,int)int)
    FuncAdd01<<func(tuple(int,int),int)
    tuple02<<type(tuple(bool,int,float)
    pi3<<const(float,3.14159)
    pi4<<const(float,3.14)


Реверсивный информационный граф
-----------------------------------

Реверсивный информационный граф (РИГ) формируется в результате компиляции функции, написанной на язые программирования Smile. В нем собирается вся информация о функции, необходимая как для дальнейшей раздельной генерации объектного кода (кода, в который осуществляется генерация программ, написанных на Smile), так и для осуществления различных видов анализа и преобразований. В частности возможны:

    * Оптимизация РИГ;
    * Построение управляющих графов (УГ) с различной стратегией управления вычислениями;
    * Использование в качестве входного представления для формальной верификации.

Основным отличием РИГ Smile от РИГ языка программирования Пифагор является наличие для каждой вершины информации об ее типе, которая или берется непосредственно из компилируемого исходного текста или выводится с использованием системы вывода типов, что типично для большинства языков функционального программирования.



Транслятор ориентирован на обработку текстовых файлов, каждый из которых может содержать множество функций, написанных на языке Пифагор. В результате трансляции для каждой функции создается промежуточное текстовое описание РИГ, которое сохраняется в репозитории и может быть повторно использовано. 

Выбор текстового представления для описания РИГ обусловлен тем, что с одной стороны, формирование на его основе внутреннего представления в памяти компьютерной системы может быть легко выполнено с помощью простых синтаксических анализаторов,  а с другой стороны, текстовое представление РИГ позволяет разработчику читать и анализировать оттранслированные функции. Таким образом, оно может рассматриваться, как аналог языка ассемблера, который облегчает восприятие человеком структуры и особенности исполнения ФПП программ. 

В качестве примера рассмотрим трансляцию функции вычисления факториала. Текст программы на языке Пифагор выглядит следующим образом::

    fact << funcdef n@int -> int {
        (-1, 1, {(n,(n,1):-:fact):*} ):{(n,0):(<,=,>):?}:return
    }

Функция возвращает значение -1 в случае отрицательного аргумента, что сигнализирует об ошибке. В результате трансляции формируется следующее текстовое представление реверсивного информационного графа::

    const
    0   -1      ->int
    1   1       ->int
    2   1       ->int
    3   {1}5    ->int
    4   0
    type
    func
    0   fact    int->int
    code
    0   {0}     arg         ()                  ->int
    1   {1}     ()          (0,const:2)         ->(int,int)
    2   {1}     :           (1,-)               ->int
    3   {1}     :           (2,func:0)          ->int
    4   {1}     ()          (0,3)               ->(int,int)
    5   {1}     :           (4,*)               ->int
    6   {0}     ()          const:0,const:1,const:3   ->(int,int,int)
    7   {0}     ()          0,loc:4             ->(int,int)
    8   {0}     []          <,=,>               ->[func,func,func]
    9   {0}     :           7,8                 ->[bool,bool,bool]
    10  {0}     ()          9                   ->(bool,bool,bool)
    11  {0}     :           10,?                ->int
    12  {0}     []          11
    13  {0}     :           6,12
    14  {0}     ret         13                  ->int

Данное представление содержит ссылки на внешние функции и константы, внутренние констант и реверсивный информационный граф заданной функции.

Область описаний внешних ссылок начинается с ключевого слова External и содержит список строк, в каждой из которых задан дескриптор (номер) внешней ссылки и имя внешней ссылки. На нулевой позиции всегда располагается ссылка на саму функцию. Это позволяет использовать обращение к самой себе в случае рекурсивных вызовов. В связи с этим область внешних ссылок всегда имеет хотя бы один элемент.

Область локальных констант начинается с ключевого слова Local. Она содержит список констант, используемых в ходе выполнения функции. Каждой константе соответствует свой дескриптор  (номер), который при выполнении программы в СП выступает в роли индекса, определяющего доступ к соответствующим данным. Наряду с числовыми и символьными данными в этой области хранятся константы, определяющие параметры задержек. Каждая из таких констант хранит номер задержанного списка, а также дескриптор узла РИГ, возвращающего вычисленное значение из данного задержанного списка (подобный узел существует в любом задержанном списке).

Область описания РИГ содержит список вершин, и связей между ними, локальными константами и внешними ссылками. Данная область начинается с заголовка, описывающего содержание каждой строки:
id	delay	operation	links	positions

Столбец id задает дескриптор (номер) вершины РИГ. В столбце delay указывается номер задержанного списка, в котором расположена соответствующая вершина. Если вершина РИГ не находится в задержанном списке, в данный столбец заносится ноль. В столбце operation размещается операция, выполняемая в соответствующей вершине РИГ. Столбец links указывает на информационные связи вершин. В нем задается список ссылок на источники данных для текущей вершины. Источниками информации могут быть: внешние ссылки, локальные константы, предопределенные символы и узлы РИГ. Каждый из этих источников данных по-своему идентифицируется в качестве элемента списка связей. Различие в заданиях связей в дальнейшем определяет обращение к разным областям памяти в СП. 

Указание на внешнюю ссылку задается в следующем формате: func:<символическое_имя_внешней_ссылки>. Для локальной константы используется формат: loc:<значение_константы>. Предопределенные символы, обычно связанные со знаками различных операций, задаются своими значениями, например: +, -, * и т.д. В том случае если источником операндов служит другая вершина РИГ, в качестве связи задается целое число, равное дескриптору этой вершины.

В столбце type задаются типы результатов для каждого из узла РИГ.


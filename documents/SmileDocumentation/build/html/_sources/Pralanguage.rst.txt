.. |date| date:: %d.%m.%Y
.. |time| date:: %H:%M
.. |copy| unicode:: 0xA9 .. copyright sign

.. Текущая дата |date| и время |time|

.. meta::
   :description: Описание концепций, языковых и инструментальных средств функционально-потокового параллельного программирования.
   :keywords: парадигмы программирования, функционально-потоковое параллельное программирование

:Author:    Александр Легалов
:Email:     <legalov@mail.ru>
:Date:      |date|
:Version:   0.0

:Copyright: |copy| Допускается свободное прочтение без использования в связи с непроработанностью решаемых задач.

.. .. sectnum::
    :start: 1

.. .. contents:: Содержание
    :depth: 3


=============================================
Об ядре языка как о праязыке
=============================================

Введение
-------------

В данном документе представлены размышления по выделению в ЯФППП Smile некоторого ядра, которое бы являлось универсальной базовой составляющей для различных предметно-ориентированных ответвлений. Предполагается, что это ядро может описывать общие операторы и операции (базовые функции), обеспечивающие формирование основного каркаса программы. Для того, чтобы сориентироваться на конкретную предметную область, предполагается дописывать соответствующие операции и данные, которые бы реализовывали дополнительный функционал, связанный с обработкой данных в конкретной предметной области. Предполагается, что таким образом можно будет готовить различные версии в зависимости от того, что требуется в том или ином случае. В частности предполагается, что для универсальных применений требуется свой базовый набор типов данных и операций над ними. Для программирования на уровне ПЛИС необходимо сформировать набор соответствующих низкоуровневых данных (биты, байты) и операций над ними. Разделение по подъязыкам в данном случае позволяет не усложнять универсальностью единый язык и избежать коллизий, связанных с противоречивостью различных типов данных, которые в общем случае могут иметь различную семантику при одинаковом синтаксисе.

Определения
----------------

Предворительное определение рассматриваемого ядра как праязыка базируется на следующем определении из Википедии:

    *Праязы́к (калька с нем. Ursprache) — предковый язык, из которого возникли языки, относящиеся к данной семье языков или группе языков.*

Вполне понятно, что речь в данном случае идет несколько о другом варианты возникновения семейства искусственных языков, но достаточно сложно подобрать другие варианты названия для того ядра, которое предполагается выделить. По аналогии с объектно-ориентированным программированием можно было бы говорить о **суперязыке** (там имеется понятие **суперкласса**). Однако в случае языка программирования это звучит как-то нескромно. Можно также говорить о базовом языке, от которого появляются дочерние языке. Но в целом получается тоже не вполне конкретно. Вариантом на эту же тему является понятие **родительский язык**, от которого формируются дочерние языке, что уже фактически является эквивалентом праязыка.

Другой ассоциацией на название является терминология из области операционных систем. В ОС выделяется ядро, к которому прикручиваются различные модули. Поэтому в принципе можно говорить об ядре языка функционально потокового параллельного программирования. Тогда различные версии подъязвков можно рассматривать в качестве расширений ядра.

Пока останавливаюсть на термине **праязык функционально-потокового параллельного программирования (ПЯФППП)**. При переходе на тексты более официального уровня можно еще подумать о названии. Помимо этого предполагается праязык рассматривать под названием **Smile0**.

Состав праязыка
------------------

Текущий состав Smile0 формируется на основе описания языков программирования Smile и Пифагор, путем выделения операторов и операций не связанных со спецификой обработки данных, но обеспечивающих формирование общей структуры программных артефактов. В данном документе пока проводится выделение включенных артефактов. Их описание будет сформировано в ходе формирования общего описания Smile0.

Элементарные конструкции
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Практически все элементарные конструкции включаются в состоав праязыка. Это:

- разделители;
- комментарии;
- идентификаторы;
- ключевые слова.

Обозначения
~~~~~~~~~~~~~~~~~~

Обозначения также включены в состав праязыка.

Предопределенные типы данных
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Значащие величины (константы)
-----------------------------

Включены предопределенные типы данных, встречающиеся в операторах и операциях праязыка. Остальные типы данных убраны и будут добавляться в подъязыках. Эти типы данных представленны в следующей таблице:

.. table:: Предопределенные типы

    ======================= ================= ============
    Название                Обозначение типа  Организация
    ======================= ================= ============
    сигнал                  signal (nil)      атом
    целый                   int               атом
    логический              bool              атом
    спецзнаковый            spec (nil)        атом
    ошибочный               error (nil)       атом
    список данных           datalist          составной
    параллельный список     parlist           составной
    задержанный список      delaylist         составной
    асинхронный список      asynlist          составной
    базовая функция         func              атом
    функция                 func (nil)        определяемый
    тип                     type              определяемый
    ======================= ================= ============

Следует отметить отсутствие в данной таблицы символьных и действительных типов данных, так как они не используются в наборе базовых операторов и операций праязыка. То есть, они будут, при необходимости, добавляться в соответствующих подъязыках.

Значащие величины (константы)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Как и типы, в праязык включаются те константы, которые соответствуют используемым типам:

- сигнальная константа, задаваемая символом ".";
- целочисленная константа, записываемая в соответствии с принятым синтаксисом и ограниченная диапазоном используемого машинного слова;
- логическая константа принимающая значения true или false;
- константы ошибок, задаваемые соответствующими идентификаторами, образующими перечислимый тип (следует отметить, что включаются только те константы ошибок, которые соответствуют семантике праязыка);
- константы типов, существующих на уровне праязыка;
- константы спецзнаков, часть из которых определяют операции праязыка, а часть не имеют конкретной семантики и предназначены для использования на уровне подъязыков с семантикой, определяемой разработчиками подъязыков;
- константные списки, состоящие из атомарных констант праязыка и его допустимых операций для всех видов списков.

При этом допускается описание константных выражений посредство ``const`` с применением констант всех типов, допустимых в праязыке.

Описания типов
~~~~~~~~~~~~~~~~~~~~~

Описания типов, задаваемые посредством ``typedef``, должны быть реализованы в праязыке. Это касается как статических описаний, так и динамически проверяемых описаний (описаний, содержащих тело с набором операций). При этом в теле динамического описания типов допускается использовать только операторы и операции, определенные в праязыке. Предполагается, что определение в подъязыках дополнительных операций приведет, в свою очередь, к расширению возможностей как динамического описания типов, так и функций.

Описания функций
~~~~~~~~~~~~~~~~~~~~~

Описания функций, задаваемые посредством ``funcdef``, также реализуются в праязыке. На тело функции накладывается ограничение, связанное с использованием только тех операторов и операций, которые реализованы в праязыке.

Описания импорта
~~~~~~~~~~~~~~~~~~~~~

Допускается описание импорта из других репозиториев посредством ``import``.

Операторы и операции в теле функции или динамического описания типа
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Тело функции или динамического описания типа содержит операторы и операции. Ряд этих конструкций определены в праязыке.

Блок
"""""""""

Допускается использование блока. Учитывая то, что язык является статически типизированным, необходимо указывать типы аргумента и результата блока точно также как и при описании функции.

Выражение
"""""""""""

Выражение состоит из отдельных подвыражений (рекурсивно определяемых выражений), соединенных между собой операторами интерпретации. Определены и допустимы на уровне праязыка.

Предопределенные функции и данные
""""""""""""""""""""""""""""""""""""""

**Предопределенные функции и данные** формируются на основе атомов, каждый из
которых может быть в роли как аргумента, так и функции оператора интерпретации. При этом ряд
атомарных объектов могут выступать только в роли данных, другие - в роли функций, третьи - в той и другой.

Большинство специальных знаков используются как предопределенные функции. Обычно за ними закрепляются вычислительные операции, традиционные для этих значков в большинстве существующих языков программирования. Задаются допустимые аргументы и значения этих функций. При этом тип операции не связан только со знаком. Он также зависит от типа аргумента. Поэтому нельзя, например, говорить о знаке "+" как об арифметической операции, так как при булевских аргументах он используется для обозначения дизъюнкции. Исходя из специфики праязыка, следует отметить, что ряд спецзнаков, а также предопределенных функций, задаваемых именам, в нем не определе. Это, в частности, касается знака "+", семантику которого определяет разработчик подъязыка.

.. note::

    Необходимо подумать над тем, включать ли в праязык операции над предопределенными в нем типами данных. С одной стороны это расширяет семантику праязыка, которая может на деле отличаться в подъязыках. С другой стороны праязык без этой семантики будет скуден. Хотя он и не задумывается как полноценный языка. Надо думать...

Использование знака "."
++++++++++++++++++++++++++

Данный знак используется в праязыке по своему основному назначению, интерпретируясь как сигнальная величина. В качестве функции возвращает обобщенный аргумент поступивший на его вход. Аргумент может быть любого типа, что определяется его обозначением ``any``. То есть, любой тип праязыка может быть при необходимости интерпретирован как ``any``.

В качестве аргумента функции интерпретации сигнальная величина служит пустым аргументов функций, не содержащих аргумент, определяя их запуск по моменту поступления сигнала. Следовательно, значение "." сразу же обеспечивает запуск любой функции.

Использование знака "|"
++++++++++++++++++++++++++

Знак **"|"** задает функцию нахождения списка данных и определен в праязыке. 
Аргумент – список данных любой размерности и любого типа элементов (any). Результат – целое число, задающее количество
элементов в списке первого уровня вложенности.

На уровне описаний определяется следующим образом::

    anyDataList << typedef @(@any...)
    spec| << funcdef @anyDataList->@int

Предполагается, что в дальнейшем семантика данной операции может быть расширена на параллельные и задержанные списки за счет использования оператора двойной интерпретации::

    anyParList << typedef @[@any..]
    anyDelayList << typedef @{@any..}
    spec| << ::funcdef @anyParList->@int
    spec| << ::funcdef @anyDelayList->@int

Использование знака "?"
+++++++++++++++++++++++++

Используется как функция, осуществляющая вычисление номеров позиций истинных булевских констант в булевском
списке данных. В качестве результата формируется параллельный целочисленный список с
номерами тех элементов списка аргументов, чьи значения были равны true. Аргумент является булевским списком  данных::

    boolDataList << typedef @(@bool..)
    intParList << typedef @[@int..]
    spec? << funcdef @boolDataList->@intParList

Пример::

    (true, false, true, false, false, true):? ⇒ [1, 3, 6]

.. note::

    Следует обратить внимание на то, что в общем случае аргумент может быть списком, длина которого может определяться только во время выполнения. Однако во многих случаях длина списка можеть быть известна на этапе компиляции, что позволит оптимизировать его представление и обеспечить выделение памяти до момента выполнения программы. Аналогичным образом можно заранее выделить память и для результата, так как его максимальный размер не может превышать длину аргумента. В этом случае выделяемая структура должна иметь еще один параметр, задающий количество истинных значений в формируемом результате. Задача может решаться на этапе оптимизации промежуточного представления. Может быть вообще стоит ограничить язык заданием фиксированной размерности списков в базовых операторах и операциях, разрабатывая для динамических вариантов соответствующие функции. Это сделает язык более строго типизированным.

В принципе вполне возможно расширение семантики данной операции на двойную интерпретацию, когда в качестве аргумента выступает булевский параллельный список::

    boolParList << typedef @[@bool..]
    intParList << typedef @[@int..]
    spec? << ::funcdef @boolParList->@intParList

Тогда появление значений в выходном списке результатов может происходить асинхронно.

Вряд ли стоит расширять данную операцию на задержанный список, так как значения его элементов могут оказаться не вычисленными. Предполагается что оператор двойной интерпретации манипулирует только параметрами типа артефакта и не раскрывает задержанные списки.

Использование знака "#"
++++++++++++++++++++++++++

Знак **"#"** используется для задания функции транспонирования элементов списка подсписков. Транспонирование может происходить для любых списков вложенностью не менее 2. В общем случае тип аргумента и тип результата совпадают по размерности. Изменяется только значение::

    doubleDataList << typedef @(@anyDataList..))
    spec# << @doubleDataList->@doubleDataList

Использование знака "()"
+++++++++++++++++++++++++++++

Задает охват аргумента круглыми скобками. То есть, формирует из атома одноэлементный список данных. Для списков данных, асинхронных списков формируется список данных с увеличенным на единицу уровнем вложенности.

.. note::

    Нужно добавить описание типов и прототип функции.



Не используются в праязыке
"""""""""""""""""""""""""""""

Ниже представлены спецзнаки и идентифиакторы, зарезервированные, но не используемые в праязыке, которые разработчики подъязыков могут использовать в своих целях:

- знак "+";
- знак "-";
- знак "/";
- знак "%";
- знаки "=", "!=", "<", "<=", ">", ">=";
- ...



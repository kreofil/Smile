.. |date| date:: %d.%m.%Y
.. |time| date:: %H:%M
.. |copy| unicode:: 0xA9 .. copyright sign

.. Текущая дата |date| и время |time|

.. meta::
   :description: Описание концепций, языковых и инструментальных средств функционально-потокового параллельного программирования.
   :keywords: парадигмы программирования, функционально-потоковое параллельное программирование

:Author:    Александр Легалов
:Email:     <legalov@mail.ru>
:Date:      |date|
:Version:   0.1

:Copyright: |copy| Допускается свободное использование с обязательной ссылкой на сайт автора: "Оригинальная версия размещена на сайте www.softcraft.ru".

.. .. sectnum::
    :start: 1

.. .. contents:: Содержание
    :depth: 3


Статически типизированная модель модель функционально-потоковых параллельных вычислений
===================================================================================================

.. note::

    Описывается модель параллельных вычислений, ориентированная на представление динамики поведения при статической типизации. То есть речь идет о статически типизированной модели функционально-потоковых параллельных вычислений (СТМФППВ). Ее отличительной чертой является более эффективная поддержка процесса трансформации программ во время компиляции. 
    
    *Предполагается, что в данном тексте замечания могут касаться и изменений, вносимых в модель и язык. В ходе дальнейших версий эти замечания будут удаляться.*

Введение
-----------

Статически типизированная модель модель функционально-потоковых параллельных вычислений (СТМФППВ) определяет динамику поведения и базовую семантику статически типизированного языка функционально-потокового параллельного программирования (СТЯФППП) Smile. В отличие от ранее предложенной функционально-потоковой модели параллельных вычислений (ФПМПВ) данная модель ориентирована на  статическая типизацию данных и фиксацию размерностей данных, используемых в массовых операциях. Это, в свою очередь, ведет к изменению семантики программо-формирующих операторов. Изменяются также аксиомы модели и ее алгебра преобразований за счет ориентации на период компиляции. Вместе с тем основные характеристики модели, определяющие концепцию архитектурно-независимого параллельного программирования остаются практически неизменными:

- вычисления протекают внутри неограниченных ресурсов, что позволяет неявно описывать параллелизм без возникновения ресурсных конфликтов;
- управление вычислениями осуществляется по готовности данных;
- выбор операций и аксиом, определяющих базовый набор функций, ориентирован на наглядное текстовое представление информационного графа программы при его описании на языке программирования;
- модель вычислений определяет общую структуру функционально-потоковой параллельной программы без привязки к операционной семантике, которая может определяться дополнительно, определяя тем самым специфику конкретного языка (подъязыка) программирования.

Первое требование обеспечивает ресурсную независимость предлагаемой модели, что позволяет описать параллелизм, ограниченный только информационными зависимостями между функциями и данными, присущими решаемой задаче. Это сводит перенос разработанной и отлаженной функционально-потоковой параллельной программы на любую вычислительную систему к распределению ресурсов в соответствии с целевой архитектурой. Подобный подход используется также в ряде известных схем потока данных (СПД) [Алгоритмы], ориентированных на рекурсивное описание программ, обрабатывающих только один входной поток данных и не поддерживающих их конвейерное продвижение. В связи с отсутствием циклических конструкций граф данной модели является *ациклическим*.

Использование текстового описания для представления параллельных программ связано с трудностями непосредственного описания информационного графа, что привело к синтаксису языка, несколько отличающемуся от общепринятого. Кроме того, в языке отсутствуют вентили, обеспечивающие условную передачу данных в традиционных СПД [Денис, Arvind]. Эти вентили трудно структурировать при текстовом описании программ без использования дополнительной синхронизации информационных потоков.

Отличительной особенностью СТМФППВ является ориентация программо-формирующих операторов на использование статически типизированных вычислений. Это ведет к уменьшению динамических свойств операторов, что позволяет обеспечить более легкую трансформацию в структуры данных, типичные практически для всех современных статически типизированных языков программирования (как императивных, так и функциональных). Подобные модификации, в свою очередь, достаточно сильно изменяет семантику как модели вычислений, так и формируемого на ее основе СТЯФППП Smile.

.. note::

    Следует отметить, что понятие СТМФППВ не связано только со статической типизацией данных. Как и основная ФПМПВ новая модель предназначена для описания семантики вычислений и организации параллельных процессов. Вместе с тем следует отметить, что использование статической типизации накладывает определенную специфику на операторы модели, что, в свою очередь, ведет к изменению их семантики функционирования. В связи с этим поведение операторов модели и, как следствие, программы, написанной на соответствующем языке, тоже будет иным. Изменяются аксиомы модели и алгебра эквивалентных преобразований.
    
Общие принципы организации модели
--------------------------------------

Модель задается тройкой:

    M = ( G, P, S\ :sub:`0` ),

где G - ациклический ориентированный граф, определяющий информационную
структуру программы (ее информационный граф), P - набор правил, определяющих
динамику функционирования модели (механизм формирования разметки), S\ :sub:`0` - начальная
разметка.

Информационный граф

    G = ( V, A ),

где V - множество вершин определяющих программо-формирующие операторы, а A - множество дуг, задающих пути передачи информации между ними.

Вершины графа, соответствующие программо-формирующим операторам и хранилищам, обеспечивают информационные преобразования данных, их структуризацию и размножение. Существуют следующие типы операторов:

- операторы интерпретации;
- константный оператор или константа (const);
- оператор копирования;
- оператор группировки в кортеж (tuple);
- оператор группировки в рой (swarm);
- оператор задержки (delay);
- хранилище данных заданного типа.

Следует отметить, что появление хранилищ связано с возможностью задания типов данных. Это позволяет создать хранилище данных определенного типа, занесение данных в которые возможно с использованием принципа единственного присваивания. Хранимые данные можно читать по их готовности. Операции записи в хранилища и чтения из них зависят от заданного типа. 

.. note::

    В отличие от ФПМПВ появление хранилищ позволяет организовывать их использование за счет операций, распределенных в различных частях функции или даже из нескольких различных функций.
    

Операторы и хранилища являются вершинами информационного графа, определяющего функцию. Имеется одна начальная вершина V\ :sub:`0`, определяющая точку входа для аргумента, инициирующего вычисления. Существует также одна выходная вершина V\ :sub:`end`, определяющий узел выхода результата вычисления функции. Запуск вычислений в функции инициируется поступлением в нее аргумента, что фиксируется соответствующей разметкой дуги, выходящей из входной вершины. Вычисления заканчиваются, когда все дуги информационного  графа, включая и дугу, входящую в выходную вершину, окажутся размеченными. Все прочие вершины определяют программо-формирующие операторы. Из каждой вершины информационного графа (за исключением выходной вершины) может выходить несколько дуг в другие вершины. Эти дуги определяют пути перемещения вычисляемых значений.

Динамика выполнения операторов задается механизмом продвижения начальной разметки графа по дугам модели. Разметка дуги определяется типом передаваемых данных или оператором, заданным в вершине информационного графа.

Большинство операторов формируют единичную разметку (разметку кратностью 1). То есть, на выходе создается тольно одно значение определенного типа. Исключением является рой, который в асинхронном режиме может порождать и выдавать более одного значения...

.. note::

    Необходимо переработать понятие разметки с учетом изменения концепции параллельных списков. Это касается ниже расположенного текста.

.. note::

    *Данный текст нужно переработать и не забыть использовать при описании динамики роя.*
    
    "и в общем случае (при передаче роев) задается вектором:"

    M\ :sub:`i` = (N, R),

    где N - кратность роя, определяющая количество перемещаемых независимых значений,
    полученных в результате выполнения оператора, выход которого соединен с этой дугой; R - вектор данных (r\ :sub:`1`, r\ :sub:`2`, ... r\ :sub:`N`), полученный в ходе вычислений.

    Наличие разметок на всех дугах некоторой вершины графа позволяет запустить ее и получить выходную разметку. Разметку кратности большей, чем единица назовем параллельной. Набор независимых данных, соответствующий такой разметке, будем называть параллельным списком или роем. При разметке кратности 1 имеем частный случай параллельного списка, вырожденного до одноэлементного параллельного списка или просто элемента.

    Следует отметить, что поддержка разметкой дуги нескольких независимых наборов данных позволяет описывать на уровне ФПМПВ массовый параллелизм, порождаемый использованием роя (swarm). При этом передача данных роя из формирующей его вершины может начинаться до формирования полной разметки, так как обработка каждого из его элементов осуществляется независимо. То есть осуществляется асинхронное выполнение вычислений надНа его выходе сформировано значение тип которого определяется видом константы. То есть, н независимыми наборами данных по их готовности.

    Например, если вершина V\ :sub:`i` получает данные с дуги A\ :sub:`j` с кратностью разметки N, то для формирования неполной разметки на выходной дуге A\ :sub:`k` достаточно появления хотя бы одного набора данных r\ :sub:`m`. Дальнейшее формирование разметки на входной дуге позволяет пополнять разметку на выходе. Данный механизм поддерживается аксиомами языка. Необходимым условием является наличие полных разметок только при окончании вычислений функции. Назовем разметку дуги, не сформированную до конца, неполной.

    Отметим также, что произвольное поступление элементов вектора значений R на обработку не приводит к неоднозначности, так как каждый элемент идентифицирован уникальным порядковым номером от 1 до N.

Описание программо-формирующих операторов
------------------------------------------

Для графического представления операторов используются специальные обозначения,
приведенные на рис. 1.1 - 1.6. Наряду с графическими обозначениями применяется и текстовое описание элементов модели, аналогичное принятому в разработанном языке программирования.

**Операторы интерпретации** предназначены для описания функциональных преобразования аргументов. Каждый такой оператор имеет два входа, на один из которых поступает значение интерпретируемое как функция F (функциональный вход), а на другой величина, являющаяся аргументом (вход данных) X, обрабатываемым данной функцией. Существует два вида операторов интерпретации: одноаргументный и массовый.

Одноаргументный оператор интерпретации применяется к своим входам как обычная функция. То есть считается, что одна функция обрабатывает аргумент как единое целое, формируя на выходе результат функционального преобразования (рис. 1.1).

.. figure:: _static/ModelReference/f1_1.png
       :scale: 50 %
       :align: center
       :alt: Оператор интерпретации

       Рис. 1.1. Оператор интерпретации 
       с входами аргумента **X** и функцией **F**.

При текстовом описании одноаргументный оператор интерпретации имеет две формы: постфиксную, обозначаемую
знаком **":"**, и префиксную, при которой функция отделяется от аргумента знаком **"^"**.
Наличие двух способов записи одного оператора позволяет в дальнейшем комбинировать их
с целью получения более наглядного текста программы. Следовательно, традиционное обозначение функции **F(X)** оператор интерпретации позволяет задать одной из форм::

    X:F или F^X .

Массовый оператор интерпретации предназначен для описания параллельных вычислений (рис. 1.2), когда аргумент и/или функция являются контейнерными типам, к которым относятся кортежи, векторы, рои, потоки. В этом случае функцией осуществляется обработка каждого элемента контейнера как отдельного аргумента. На выходе данной операции интерпретации формируется результат, являющийся контейнером такого же типа, что и контейнер аргумента, а элементы этого контейнера образуются результатами вычислений для каждого аргумента. Особенности семантики массового оператора интерпретации для различных вариантов описываются алгеброй эквивалентных преобразований.

.. figure:: _static/ModelReference/f1_2.png
       :scale: 50 %
       :align: center
       :alt: Оператор интерпретации

       Рис. 1.2. Оператор интерпретации 
       с входами аргумента **X** и функцией **F**.

При текстовом описании одноаргументный оператор интерпретации имеет две формы: постфиксную, обозначаемую
знаком **"::"**, и префиксную, при которой функция отделяется от аргумента знаком **"^^"**.
Следовательно, традиционное обозначение функции **F(X)** оператор интерпретации позволяет задать одной из форм::

    X::F или F^^X .

Как аргумент, так и функция могут являться результатами предшествующих вычислений. Это обуславливается тем, что семантика оператора допускает использование в качестве функции различные типы данных (что определяется на уровне семантики языка). Однако типы функционального аргумента и аргумента данных должны быть известны во время компиляции, что обеспечивает прозрачную трансформацию в другие статически типизированные языки программирования.

Операторы интерпретации запускаются по готовности функции и аргумента, что определяется появлением
разметки на входных дугах. Получение результата задается разметкой выходной дуги. 

**Константный оператор** или **константа** определяет вершину информационного графа, хранящую постоянную величину и всегда готовую к выполнению.Он не имеет входов (рис. 1.3). Данный оператор не имеет входа. На выходе изначально устанавливается разметка, определяющая предписанное значение. Множество константных операторов информационного графа формируют внутреннюю начальную разметку модели вычислений. В языковом представлении константный оператор задается значением соответствующего типа. Тип константы должен быть известен во время компиляции функции

.. figure:: _static/ModelReference/f1_3.png
       :scale: 50 %
       :align: center
       :alt: Константный оператор

       Рис. 1.3. Константный оператор

**Оператор копирования** (рис. 1.4) осуществляет передачу данных с одного своего
входа на множество выходов. В графическом представлении данная передача фиксируется
установкой разметки на дугах, связанных с выходами вершины при размеченной входной
дуге. 

.. figure:: _static/ModelReference/f1_4.png
       :scale: 50 %
       :align: center
       :alt: Оператор копирования данных

       Рис. 1.4. Оператор копирования данных

По сути оператор копирования представляет источник данных к которому осуществляется доступ из различных точек функции. Поэтому представленное отдельное графическое обозначение не означает реально выделенного отдельного оператора. В общем случае оператор копирования может объединяться с предшествующим оператором, из которого выходит его выходная дуга. Также возможна цепочка операторов копирования, которая может восприниматься как один оператор.

В текстовой форме он определяется через именование передаваемой величины и дальнейшее использование введенного обозначения в требуемых точках функции. Используются как постфиксное именование размножаемого объекта в форме::

    величина >> имя ,

так и его префиксный эквивалент, имеющий вид::

    имя << величина .

Например::

    y << F^x;
    (x,y):+ >> c;

При этом тип обозначения совпадает с типом результата предшествующих вычислений и определяется во время компиляции.

**Оператор группировки в кортеж** (рис. 1.5) имеет несколько входов и один выход. Он
обеспечивает структуризацию, упорядочение и синхронизацию разнотипных данных, поступающих по дугам из различных источников. Типы поступающих элементов должны быть известны во время компиляции. Данная структура является неименованной, то есть доступ к ее элементам осуществляется по порядковому номеру (индексу). Порядок элементов определяется номерами входов, каждому из которых
соответствует натуральное число в диапазоне от 1 до N, где N - длина вектора. В текстовом виде оператор задается ограничением элементов списка круглыми скобками "(" и ")". Например::

    (x1, x2, x3, x4).

.. note::

    Насчет нумерации нужно подумать. Стоит ли сводить индексации к диапазону 0 ... N-1? При этом естественно нужно будет убрать операции удаления элементов из списков. Возможно, что в статически типизированной версии они не очень-то и нужны.

Нумерация элементов вектора в данном случае задается неявно в соответствии с
порядком их следования слева направо (это же соглашение предполагается и в графическом
представлении при отсутствии явной нумерации входов).

.. figure:: _static/ModelReference/f1_5.png
       :scale: 50 %
       :align: center
       :alt: Оператор группировки в вектор

       Рис. 1.5.  Оператор группировки в вектор

Количество элементов в сформированном списке равно сумме всех входных дуг.

**Оператор создания роя** (рис. 1.6), как и оператор группировки в кортеж обеспечивает формирование набора данных. Основное отличие роя от кортежа заключается в том, что группируемые данные являются независимыми друг от друга. Поступление в рой каждого элемента данных сопровождается выдачей управляющих сигналов, информирующих об этом событии, что позволяет оперативно реагировать на изменение состояния роя.

.. note::

    В данном случае, несмотря на то, что изменяется алгебра преобразований, на выходе кратность разметки определяется общим числом всех входных дуг вложенных роев, образующих начальный уровень вложенности. Как и ранее, вложенные рои не раскрываются

.. figure:: _static/ModelReference/f1_6.png
       :scale: 50 %
       :align: center
       :alt: Оператор группировки в рой

       Рис. 1.6.  Оператор группировки в рой

В текстовом виде группировка в рой задается ограничением его элементов квадратными скобками **"["** и **"]"**. Например::

    [x1, x2, x3, x4 ] .
    
Каждый элемент роя формируется независимо и по его появлению готов к выполнению. Это позволяет выполнять массовую операцию интерпретации по мере поступления элементов в рой, реализуя по сути следующие эквивалентные преобразования::

    [x1, x2, x3,x4]::f ≡ [x1:f, x2:f, x3:f, x4:f] .

Если же рой определяет набор функций, то все они выполняются одновременно над одним и тем же аргументом. Таким образом, данная конструкция обеспечивает организацию массового параллелизма::

    x::[f1, f2, f3, f4] ≡ [x:f1, x2:f2, x3:f3, x4:f4] .

При этом осуществляется сквозная перенумерация всех элементов сформированного роя слева направо. Все элементы роя должны быть одного типа, что обуславливается однородностью данных при массовом параллелизме. Это касается роя, выступающего в роли как данных, так и функции. Для функций все элементы роя должны иметь одинаковую сигнатуру и одинаковый тип результата.

**Оператор задержки** или **задержка** (рис. 1.7) задается вершиной, содержащей допустимый информационный подграф, в который входят несколько входных дуг и выходит одна выходная дуга. Входные дуги определяют поступление аргументов, а выход задает выдаваемый из подграфа результат. Специфической особенностью такой группировки является то, что ограниченные оператором задержки вершины (на графе ограничение задается контуром формируемой мультивершины), представляющие другие программо-формирующие операторы, не могут выполняться, даже при наличии на входах всех аргументов. Их активизация возможна только при снятии задержки (раскрытии контура), когда ограниченный подграф становится частью всего вычисляемого графа.

.. figure:: _static/ModelReference/f1_7.png
       :scale: 50 %
       :align: center
       :alt: Оператор задержки

       Рис. 1.7.  Оператор задержки

Первоначально задержанный подграф создает на своем единственном выходе константную разметку,
которая является образом (иконкой) данного подграфа. Эта разметка распространяется по
дугам графа от одного программо-формирующего оператора к другому, размножаясь, входя
в различные списки и выделяясь из них до тех пор, пока не поступит на один из входов оператора интерпретации. Как только оператор задержки становится одним из аргументов оператора интерпретации, вместо иконки происходит подстановка ранее определенного задержанного подграфа с сохранением входных связей. Опоясывающий подграф контур оператора задержки при этом «убирается», и происходит выполнение активированных операторов. В результате на выходной дуге раскрытого подграфа вновь формируется результирующая разметка, которая
и является одним из аргументов оператора интерпретации, раскрывшего задержанный
подграф. Данная процедура называется раскрытием задержанного подграфа. 

В текстовом виде оператор задержки задается охватом других операторов фигурными
скобками **"{"** и **"}"**. Например::

    {(a,b):+} .

Если внутри задержки необходимо сформировать несколько независимых аргументов, то они группируются в рой, который инициируется при раскрытии::

    {[x1, x2, x3, x4]} .

Наличие этой конструкции позволяет откладывать момент начала некоторых вычислений или вообще не начинать их, что необходимо при организации выборочной обработки данных. Помимо этого данный оператор, при необходимости, может использоваться в качестве скобок, меняющих приоритет выполнения операторов. Для этого он может быть непосредственно представлен как один из аргументов оператора интерпретации.

**Хранилища данных** определяют дополнительный тип верши информационного графа. 

Описание динамики функционирования
-----------------------------------

Правила распространения разметки по графу складываются из общих правил
межоператорных переходов, правил срабатывания программо-формирующих операторов,
правил выполнения оператора интерпретации над предопределенными функциями модели (а
далее и языка), правил эквивалентных преобразований операторов и связей допустимого
графа (алгебры преобразований, связанной с исполнением отдельных операторов и
описанной выше).

**Правила межоператорных переходов** задают распространение разметки по графу:

1. Если входные дуги вершины имеют разметку, то на выходных дугах происходит формирование разметки в соответствии с правилами срабатывания вершины, определяющий программо-формирующий оператор.

2. Рой может формировать разметку кратность которой превышает единицу и зависит от числа его элементов. Это обуславливается асинхронностью формирования в нем данных, которые сразу же могут поступать на дальнейшую обработку независимо друг от друга. В данной ситуации обработка элементов определяется правилами эквивалентных преобразований, сводящих обработку роя к массовым параллельным операциям над отдельными его элементами.

3. В процессе распространения разметка не убирается и не замещается. Каждая дуга графа может получить разметку только один раз. Из требования о недопустимости повторной разметки вытекает требование ацикличности графа.

4. Процесс распространения разметки заканчивается, когда все дуги графа имеют полную разметку в соответствии с предписанной кратностью или при невозможности распространения разметки.

**Правила срабатывания программо-формирующих операторов** конкретизируют формирование разметок на выходных дугах для каждого из ранее введенных операторов. *Оператор интерпретации* обеспечивает преобразование входного набора данных X, выступающего в качестве аргумента, в выходной набор Y, играющего роль результата, используя при этом входной набор F в качестве функции, определяющей алгоритм преобразования. В постфиксной нотации, выбранной для дальнейших иллюстраций, данное преобразование можно записать следующим образом::

    X:F ⇒ Y .

Можно рассмотреть множество унарных функций F, разделив его при этом на два подмножества::

    F = {f1, f2},

где **f1** - множество предопределенных функций языка, для каждой из которых аксиоматически задается области определения и изменения; **f2** - множество функций, порождаемых при программировании. Необходимо отметить, что областью определения любой функции из **F** является множество одноэлементных наборов данных. Обработка же роя определяется с помощью правил эквивалентных преобразований.

Поступающий на вход оператора интерпретации аргумент должен иметь тип, совпадающий с типом аргумента функции. Эта специфика определяется статической типизацией, введенной в модель. Исходя из типа аргумента и сигнатуры функции на этапе компиляции обеспечивается определение типа результата и его сопоставление с типом результата, возвращаемого функцией. В общем случае используется структурная эквивалентность типов.

Результатом выполнения функции может быть люой тип данных, включая рой произвольной размерности. При этом типы аргумента и результата определяются из описания функции во время компиляции. Следует отметить, что выбор базового набора предопределенных функций осуществляется в некоторой степени субъективно, исходя из соображений удобства пользования разрабатываемым языком. Вводятся аксиоматически определенные арифметические функции, функции сравнения и прочие, аналогично тому, как это сделано и в других языках программирования. Например, функция сложения двух чисел
**x1**, **x2**, порождающая в качестве разметки число **y**, задается следующим образом::

    (x1, x2):+ ⇒ y,

где первый аргумент оператора интерпретации является двухэлементным списком заданного типа, описанного для данной функции при описании языка. Аналогично описан и тип результата. Второй аргумент оператора
интерпретации является функцией сложения, обозначенной значком "**+**". Результат
функции сложения, значение y, является атомарным элементом.
Наряду с определением функций, присущих всем языкам программирования, целесообразно определить множество функций, нестандартных в традиционном понимании. Например, целое число может непосредственно интерпретироваться как функция выбора элемента списка::

    (x1, x2, ... xi, ... xn):i ⇒ xi ,

где i - натуральное число, xi – элемент списка. Данная функция выделяет из списка
данных i-й элемент, который и определяет разметку выходной дуги.
Другой полезной предопределенной функцией является::

    (b1, b2, b3, ... bn):? ⇒ [i1, i2, ... ik] ,

где (b1,...bn) - список булевских величин; [i1,... ik] - параллельный список
натуральных чисел, определяющих номера тех компонент булевского списка, которые
имеют истинные значения. Наличие данной функции позволяет формировать условия,
обеспечивающие выполнение нескольких альтернативных ветвей программы.

Наряду с определением операции интерпретации для аксиоматически определенных
функций, она также определяется и для уже существующих программо-формирующих
операторов. Так, в частности, определены следующие правила раскрытия оператора задержки::

    {X}:f ⇒ X:f                       (1.1)
    x:{F} ⇒ x:F                       (1.2)
    {X}:{F} ⇒ X:F                     (1.3)

Выражение (1.1) показывает, что, независимо от наличия разметки на дуге, определяющей вход f, задержка данных ``{X}`` раскрывается. Далее, если X является допустимым подграфом, следует получение его значения, после чего осуществляется выполнение заданного оператора интерпретации. Следует также отметить, что задержка раскрывается сразу же по поступлению на один из входов оператора интерпретации не дожидаясь готовности второго аргумента.

Выражение (1.2) описывает аналогичное раскрытие задержки функции F независимо от появления разметки на входе, определяющем x. Если же оба аргумента оператора интерпретации являются операторами задержки (1.3), то они воспринимаются, как константные значения, что определяет их немедленное раскрытие. После этого каждоеиз выражений вычисляется, что приводит к разметке входных дуг описанного оператора интерпретации окончательными значениями и его последующему выполнению. 

Эквивалентные преобразования
------------------------------

Правила эквивалентных преобразований операторов и связей допустимого графа определяют алгебру модели и языка программирования. Они позволяют осуществить трансформацию графа, обеспечивающую сведение сложных структурированных операций к набору более элементарных действий над предопределенными компонентами. Возможна также обратная структуризация элементарных действий, полезная при адаптации полученной функционально-потоковой параллельной программы к архитектуре конкретной ВС. Эквивалентные преобразования определены на множестве программо-формирующих операций и отражают общие алгебраические свойства модели.

Проведение этих преобразований может происходить как перед началом вычислений, когда они применяются к исходному информационному графу, так и непосредственно в ходе выполнения программы. В этом случае преобразования проходят на уже частично размеченном графе.

Для описания правил эквивалентных преобразований введем ряд обозначений.
Отдельные значения элементов будем
обозначать малыми латинскими буквами: ``a``, ``b``, ``c``, ``d``, ``e``, ``x``, ``y``, ``z`` для данных и ``f``, ``g``, ``h`` для функций. Значения роев данных и функций обозначим соответствующими заглавными латинскими буквами. Аналогично для еще не вычисленных
элементов будем использовать малые латинские буквы: ``q``, ``r``, ``s``, ``t``, ``v``, ``w``. Еще не
вычисленные выражения внутри роев обозначим через эти же, но
заглавные буквы. Для описания порядкового расположения элементов списков будем
использовать индексы, задаваемые натуральными числами и буквами ``i``, ``j``, ``k``, ``l``, ``m``, ``n``.

Например::

    X = x1, x2,...,xi,...,xn ;
    F = f1, f2, f3  ;
    W = w 1,...,wk .

Перед выполнением любой операции интерпретации выполняются (в случае необходимости) следующие эквивалентные преобразования.

.. note::

    Следует отметить, что представленные эквивалентные преобразования отличаются от тех, которые имеются в ФПМПВ, реализуемой я ЯФППП Пифагор. Это связано со спецификой статической типизации, ограничивающей возможности динамических трансформаций.

Отсутствие в СТМФППВ неявных преобразований внутри составных конструкций
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Формируемые в ходе вычислений составные конструкции могут содержать другие составные конструкции. При этом в статически типизированной модели отсутствуют их неявные преобразования по умолчанию. Поэтому внутри структур могут содержаться рои, сигналы, что в ФПМПВ приводилось к более простому виду. Поэтому такие структуры как::

    (x1,x2,[x3],[x4,[x5]],x6)

остаются неизменными. Также не подлежит преобразованию структура, содержащая сигналы, которые не воспринимаются в данном случае как пустые элементы. Например, ``(x1,x2,.,x3, x4,x5,.,.,x6)`` или ``[x1,x2,.,x3,x4,x5,.,.,x6]`` далее не изменяются. Предполагается, что при необходимости дополнительной трансформации этих структур к другой форме будут использоваться специальные функции.


.. |date| date:: %d.%m.%Y
.. |time| date:: %H:%M
.. |copy| unicode:: 0xA9 .. copyright sign

.. Текущая дата |date| и время |time|

.. meta::
   :description: Описание концепций, языковых и инструментальных средств функционально-потокового параллельного программирования.
   :keywords: парадигмы программирования, функционально-потоковое параллельное программирование

:Author:    Александр Легалов
:Email:     <legalov@mail.ru>
:Date:      |date|
:Version:   0.1

:Copyright: |copy| Допускается свободное использование с обязательной ссылкой на сайт автора: "Оригинальная версия размещена на сайте www.softcraft.ru".

.. .. sectnum::
    :start: 1

.. .. contents:: Содержание
    :depth: 3


==========================================================
Семантика операторов интрепретации
==========================================================

Появление статической типизации привело к пересмотру семантики операций над контейнерными данными. В честности этому содействовало то, что у вектора, роя и потока все данные однотипные, а тип данных известен. Это позволяет выполнять над ними без дополнительной проверки типов не только массовые функции над всеми элементами, но и рассматривать каждый контейнер как единое целое.

Использование статической типизации также привело к разделению оператора интерпретации на два разных вида: одиночный (одноаргументный) и групповой (массовый, поэлементный). Одиночный оператор интерпретации, обозначаемый через «:» (постфиксная форма) или «^» (префиксная форма) предназначен для задания обычных функций, воспринимающих аргумент в качестве единого целого. Массовый оператор интерпретации используется для задания вычислений над каждым однотипным элементом контейнера, порождая на выходе контейнер с элементами тип которых соответствует типу результата выполняемой функции. Обозначается двойным значком «::» для постфиксной или «^^» для префиксной форм соответственно.

Использование разных обозначений позволяет однозначно применять функцию с одним и тем же именем в разных контекстах. Например, функция вычитания «-» над аргументом (10, -3), воспринимаемом как вектор, состоящий из двух целых чисел, порождает следующие значения::

    // двуместная функция вычитания над одним аргументом
    (10, -3):- => 13

    // функция смены знака, массово применяемая
    // к двум однотипным аргументам
    (10, -3)::- => (-10, 3)

Разделение оператора интерпретации на массовый и одноаргументный позволяет ввести более гибкий одноаргументный набор дополнительных функций для потока и роя, обеспечивающих обработку асинхронно поступающих данных.

Одиночный оператор интерпретации обрабатывает как функции, определенные семантикой языка (предопределенные функции), так и функции, разрабатываемые программистом. В отличие от него семантика массового оператора интерпретации ориентирована только на предопределенные функции, обрабатывающие композиции данных.

Использование функций с одинарным оператором интерпретации
------------------------------------------------------------------------------

Одиночный оператор интрепретации по сути является ключевым, так как не ведет к последующей декомпозиции данных, а рассматривает свои аргументы как единое целое, для каждой пары которых определена семантика выполнения. Эта семантика четко определяет соответствие между функцией и данными. Данный оператор интерпретации изначально отслеживает, чтобы аргумент-данные соответствовал сигнатуре аргумента-функции, после чего обеспечивает запуск функции на обработку данных. При отсутствии этого соответствие результатом является ошибка и прерывание программы.

Предопределенные функции
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Существует большое число предопределенных фунций, сигнатура которых и семантика вычислений определены изначально. Эти функции используются как для выполнения базовых арифметических и логических операций, так и для обеспечения различных композиций и декомпозиций данных, что осуществляется в дополнение к программоформирующим операторам языка.

Предопределенные функции и данные формируются на основе атомов, каждый из которых может быть в роли как аргумента, так и функции оператора интерпретации. При этом ряд атомарных артефактов могут выступать только в роли данных, другие - в роли функций, третьи - в той и другой.

Для идентификации предопределенных функций в основном используются специальные символы. Обычно за ними закрепляются вычислительные операции, традиционные для этих символов в большинстве существующих языков программирования. Задаются допустимые аргументы и значения этих функций. При этом типы аргумента и результата являются именованными типами и определяется аксиоматически при описании функции. Допускается перегрузка предопределенных функций.

.. note::

    *В данный момент я пытаюсь выделить подмножество предопределенных функций, предназначенных для формирования каркаса ФПП программы, характерного для Праязыка. В таком виде программа вряд ли может создаваться, так как минимальный набор манипуляций с данными (сравнения и т.д.) необходим даже для самого базового языка.*

    *В рассматриваемой версии не все спецзнаки имеют определенную семантику. Предполагается, что в дальнейшем она будет разрабатываться и уточняться. Наряду со специальными знаками в качестве предопределенных функций могут выступать и идентификаторы, которые, как и ключевые слова, запрещены для других применений.*

Ниже приводится описание семантики предопределенных функций, используемых в текущей версии. Следует отметить, что для аргументов, тип которых при описании не задан результатом будет ошибка: «неправильное использование функции».

Предопределенные функции общего назначения
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Предопределенные функции общего назначения обеспечивают универсальные преобразования данных независимо от их типа и структуры. Они позволяют работать с разными артефактами.

Использование знака "|"
"""""""""""""""""""""""""""""

Знак **"|"** задает функцию нахождения длины контейнерного типа. Аргументом может быть вектор, кортеж, рой. Результат – целое число, задающее количество элементов на первом уровне вложенности.

Данная функция имеет следующие сигнатуры::

    :| << funcdef any(*) -> int
    :| << funcdef any(*) -> int
    :| << funcdef (*) -> int

Если аргумент не является одним из указанных контейнерных типов, то результатом является ошибка операции интерпретации **BASEFUNCERROR**. Использование функции позволяет проверить размер аргумента перед обработкой, а лишь затем начать выделение его элементов. Следует при этом отметить, что выделение элементов для кортежа, в соответствии с описанным выше, можеть осуществляться только если тип этих элементов определен на этапе компиляции или если есть возможность приведения к векторному типу.

Примеры::

    (a, n, (q, w), s):| ⇒ 4
    [1, 2, 3, 4, 5]:| ⇒ 5
    ((1, 2, (f, d), x)):| ⇒ 1

Использование знака "?"
"""""""""""""""""""""""

Функция **"?"**, осуществляет вычисление номеров позиций истинных булевских констант в булевском векторе данных. В качестве результата формируется целочисленный вектор с
номерами тех элементов булевского вектора, чьи значения были равны true. Функция
полезна для организации выборочного продолжения дальнейших вычислений с использованием целочисленного селектора. Полученные целочисленные значения используются для выбора элементов из контейнерных данных
данных. Например::

    (true, false, true, false, false, true):? ⇒ (1, 3, 6)
    
Данная функция имеет следующие сигнатуры::

    :? << func bool(*) -> int(*)
    :? << func bool[*] -> int[*]

Если список состоит только из ложных значений, на выходе формируется вектор, не содержащий элементов, автоматически преобразуемый в ошибку базовой функции::

    (false, false, false):? ⇒ () ⇒ BASEFUNCERROR

.. note::

    **Использование знака "#"**
    
    *Данную функцию я пока не вижу в контексте статической типизации.*

Использование знака "()"
"""""""""""""""""""""""""

Задает функцию охвата аргумента круглыми скобками, то есть, приведению к вектору. Аргумент может быть базовым элементарным типом. В этом случае он становится одноэлементным вектором. Также эта функция может использоваться с роями, преобразуя их в вектор. Это позволяет синхронизировать поступающие данные перед последующей обработкой.::

    атом:() ⇒ (атом)
    [элемент, ... элемент]:() ⇒ (элемент, ... элемент)

Функция также может применяться к потоку, который в этом случае преобразуется к вектору. Тем самым поэлементный вывод из потока трансформируется в формирование вектора, число элементов в котором определяется количеством элементов, порождаемых потоком (что не всегда хорошо).

Данная функция имеет следующие сигнатуры::

    :() << funcdef any -> (any)
    :() << funcdef any[*] -> any(*)
    :() << funcdef any{*} -> any(*)

Если аргумент не соответствует сигнатуре, то результатом является ошибка операции интерпретации **BASEFUNCERROR**. 

Использование знака "[]"
""""""""""""""""""""""""""""

Задает функцию охвата аргумента квадратными скобками, то есть, приведению к рою. Аргумент может быть базовым элементарным типом. В этом случае он становится одноэлементным роем. Также эта функция может использоваться с векторами, преобразуя их в рой. Это позволяет сделать поступающие данные асинхронными, так как компилятор подобные преобразования может учесть в момент анализа программы. То есть преобразование может осуществиться до окончательного вычисления вектора или вообще до начала его вычисления.::

    атом:[] ⇒ [атом]
    (элемент, ... элемент):[] ⇒ [элемент, ... элемент]

Функция также может применяться к потоку, который в этом случае преобразуется к рою. Тем самым поэлементный вывод из потока трансформируется в формирование роя, число элементов в котором определяется количеством элементов, порождаемых потоком.

Данная функция имеет следующие сигнатуры::

    :[] << funcdef any -> [any]
    :[] << funcdef any(*) -> any[*]
    :[] << funcdef any{*} -> any[*]

Если аргумент не соответствует сигнатуре, то результатом является ошибка операции интерпретации **BASEFUNCERROR**. 

Использование знака "{}"
"""""""""""""""""""""""""

Задает функцию охвата аргумента фигурными скобками, то есть, приведению к потоку. Аргумент может быть базовым элементарным типом. В этом случае он становится потоком, порождающим один элемент. Также эта функция может использоваться с векторами, преобразуя их в поток. Это позволяет сделать данные последовательно асинхронными, поступающими в произвольном порядке, так как компилятор подобные преобразования может учесть в момент анализа программы. То есть преобразование может осуществиться до окончательного вычисления вектора или вообще до начала его вычисления.::

    атом:{} ⇒ атом (???)
    (элемент, ... элемент):{} ⇒ элемент, ... элемент (???)

Аналогично вектору функция также может применяться к рою.

Данная функция имеет следующие сигнатуры::

    :{} << funcdef any -> any{*}
    :{} << funcdef any(*) -> any{*}
    :{} << funcdef any{*} -> any{*}

Если аргумент не соответствует сигнатуре, то результатом является ошибка операции интерпретации **BASEFUNCERROR**. 

Использование знака ".."
"""""""""""""""""""""""""

Знак **".."** используется в качестве функции, формирующей вектор или рой из числовых атомов. В качестве аргумента может выступать трехэлементный вектор или рой, в котором первое число задает начало интервала, второе - его конец, а третье - шаг. Числа могут быть как целые, так и действительные, но одного типа, а шаг принимать как положительные, так и отрицательные значения. Необходимо отсутствие расхождений между значением шага и границами интервала.

Кроме этого аргумент функции может быть целочисленный двухэлементным вектором или роем. В этом случае первый элемент определяет нижнюю целочисленную границу интервала, а второй верхнюю. При этом нижняя граница должна быть меньше или равной верхней границе, а шаг по умолчания принимается равным единице. 

При некорректном задании границ интервала, идентифицированном во время выполнения, данная функция возвращает ошибку **BOUNDERROR**. Если некорректно задана структура контейнера или тип его элементов, то возвращается ошибка периода компиляции.

Данная функция имеет следующие сигнатуры::

    :.. << funcdef int(2) -> int(*)
    :.. << funcdef float(2) -> float(*)
    :.. << funcdef int(3) -> int(*)
    :.. << funcdef float(3) -> float(*)
    :.. << funcdef int[2] -> int[*]
    :.. << funcdef float[2] -> float[*]
    :.. << funcdef int[3] -> int[*]
    :.. << funcdef float[3] -> float[*]

Примеры::

    (-3.5, 2.0, 1.5):.. ⇒ (-3.5, -2.0, -0.5, 1.0)
    [1, 5]:.. ⇒ [1, 2, 3, 4, 5]
    (2, 1):.. ⇒ BOUNDERROR


.. note::

    *В дальнейшем предполагается введение интервальных констант, задающих необходимый диапазон.*

Использование функции "dup"
""""""""""""""""""""""""""""

Функция обеспечивает создания вектора из одинаковых элементов путем дублирования. Аргумент – кортеж, первый элемент которого – значение некоторого предопределенного именованного типа, а второй – положительная целочисленная константа. Результат – вектор, элементами которого являются копии первого элемента аргумента, а количество элементов равно значению второго элемента аргумента.

Пример::

    (10, 5):dup ⇒ (10, 10, 10, 10, 10)

Функция **dup** в качестве аргумента имеет тип **func**.

Данная функция имеет следующую сигнатуру::

    dup << funcdef (any, int) -> any(*)

Использование данных
~~~~~~~~~~~~~~~~~~~~~

Многие данные тоже могут допускать различное толкование в зависимости от того, в
какой части операции интерпретации они встретились.

Использование в качестве функции сигнальной константы "**!**"
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Использование сигнальной константы в качестве функции ориентировано на отображение в качестве результата аргумента, поступившего на вход данных функции одиночной интерпретации.

Функция имеет следующую сигнатуру::

    :! << func any -> any

При использовании в качестве функции знак "**!**" интерпретируется как пустая операция, осуществляющая пропуск значения аргумента в качестве результата. То есть данном знаку можно сопоставить следующее определение функции::

    :! << func x@any -> any { 
        x:return 
    }

То есть, если аргумент является вектором, группой или атомом, то происходит его выдача в качестве результата.  Если же аргумент определен как задержка, то предварительно оператор интерпретации осуществляет ее раскрытие, ведущее к вычислению задержанного выражения. Полученное значение передается функции, которая и возвращает его уже без дополнительных изменений.

Пример::

    {(2,3):+}:! ⇒ 5

Сигнальная константа также может использовать как аргумент-данные. В этом случае она интерпретируюется как отсутствие аргумента.  Обычно используется с теми функциями, которые не получают аргументов. То есть она воспринимается как сигнал, запускающий функцию в требуемый момент времени. Например, пусть будет задана функция::

    sin_pi_div_4 << funcdef -> float {
        (3.14, 4.0):/:sin >>return
    }

Тогда ее вызов будет оформлен следующим образом::

    !:sin_pi_div_4

Использование целых чисел в качестве функции
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Целые положительные числа могут использоваться для выбора элементов из векторов. То есть они по сути могут выступать в качестве индексов. Целые отрицательные числа обеспечивают удаления из векторов элементов с индексом равным абсолютному значению индексирующего числа. То есть, после этой операции размер вектора уменьшается на единицу. Например::

    (10, 9, 8, 7, 6, 5, 4, 3, 2, 1):5 ⇒ 6
    (10, 9, 8, 7, 6, 5, 4, 3, 2, 1):-5 ⇒ (10, 9, 8, 7, 5, 4, 3, 2, 1)

Данная функция имеет следующую сигнатуру::

    :@int << func any(*) -> any

Знак типа "@" указывает на то что в данном случае подразумевается неименованное значение указанного типа. Возврат значения из вектора происходит тогда, когда данный вектор полностью сформируется и будет готов к использованию в операторе интерпретации.

Следует также отметить, что целые числа могут использоваться в качестве селекторов не только с векторами, но также с роями и кортежами. При использовании с кортежом необходимо, чтобы все его данные были одного типа, что позволяет получить на выходе предопределенный тип данных неявно сводимый к вектору. Кроме этого возможна ситуация когда разные типы элементов кортежа известны во время компиляции, а значением селектора является константное выражение, что позволяет вывести тип результата. Несоответствие этому определяется во время компиляции. Если в качестве данных выступает рой, то оператор интерпретации запускается на выполнения не дожидаясь поступления всех элементов роя. Достаточно наличия функции, определяющей селекцию в виде значения и прихода в рой элемента с указанным индексом. То есть в данной ситуации осуществляется асинхронный выбор элемента, что может ускорить вычисления, но ведет к дополнительным расходам при реализации механизма. В этом случае используется функция имеющая следующую сигнатуру::

    :@int << func any[*] -> any

В случае нулевого значения или значения, не входящего в диапазон, порождается ошибка **BOUNDERROR**, сигнализирующая о неправильном индексе. 

Использование булевских значений в качестве функций
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Функция, определяемая булевским значением, осуществляет выбор первого или второго элемента двухэлементного вектора в зависимости от значения. Значение ``true`` обеспечивает выбор первого элемента вектора, а значение ``false`` - второго. Оба значения должны принадлежать одному и тому же типу. По сути это селектор значения, реализующий простейшее условие выбора. В качестве аргумента могут выступать двухлементные: вектор, рой, кортеж с элементами одного типа, сводимый к двухэлементному вектору (или булевский селектор является константным выражением). Отличие между вектором (кортежом) и роем определяется в подходе к синхронизации вычислений, как и в случае использования в качестве функций целочисленных селекторов.

Функция, определяемая булевским значением, имеет следующие сигнатуры::

    :@bool << func (any, any) -> any
    :@bool << func [any, any] -> any

Примеры::

    (10, 20):true  ⇒ 10
    (10, 20):false ⇒ 20
    [10, 20]:true  ⇒ 10
    [10, 20]:false ⇒ 20

В случае вектора меньшей или большей размерности порождается ошибка **BOUNDERROR**, сигнализирующая о неправильном обращении. Следует также отметить, что порядок выбора не связан с числовыми значениями, используемыми для представления ``true`` и ``false``.

Функции, выполняющие вычисления
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Сложение "**+**"
""""""""""""""""""""""""""""""

Знак "**+**" используется для задания бинарных и унарных операций. Его аргументом является двухэлементный кортеж. Интерпретация знака **"+"** в качестве функции зависит от типов элементов кортежа. Если аргумент является двухэлементным списком числовых атомов (целых или действительных), то выполняется арифметическое сложение. При сложении двух целых чисел результат всегда является целым числом. В этом случае автоматическое преобразование к действительному числу не происходит даже при переполнении. Сложение действительных чисел осуществляется, когда аргументом функции является двухэлементный кортеж действительных чисел. Результатом в этом случае является действительное число. Следует отметить отсутствие неявных преобразований при выполнении сложения. Исключением является преобразование целочисленного нуля "0" в действительный нуль "0.0".

Если аргумент является числовым атомом, то он выдается в качестве результата без
каких-либо преобразований.

Аргумент функции **"+"** может также быть булевским вектором длиной, равной 2. Результатом интерпретации в этом случае является дизъюнкция (логическое «или»). Допускается одноэлементный булевский список или булевский атом, порождающий в качестве результата значение этого же элемента. 

Во всех остальных случаях результатом является ошибка операции интерпретации **BASEFUNCERROR**.

Функция, имеет следующие сигнатуры::

    :+ << func (int, int) -> int
    :+ << func (float, float) -> float
    :+ << func (bool, bool) -> bool
    :+ << func int -> int
    :+ << func float -> float
    :+ << func bool -> bool

Примеры сложения::

    (3, 5):+ ⇒ 8
    (3.0, 5.0):+ ⇒ 8.0
    (3, 5.0):+ ⇒ BASEFUNCERROR
    (5):+ ⇒ BASEFUNCERROR
    5:+ ⇒ 5
    (max_integer, 1):+ ⇒ 0
    (true, false):+ ⇒ true
    true:+ ⇒ true
    false:+ ⇒ false
    (true):+ ⇒ BASEFUNCERROR

.. note::

    *Следует отметить, что арифметические операции над действительными числами на уровне праязыка пока не реализуются*

Использование знака "\-"
""""""""""""""""""""""""

Знак "**-**" используется для задания бинарных и унарных операций. Его аргументом является двухэлементный кортеж. Интерпретация знака "**-**" в качестве функции зависит от типов элементов кортежа. Если аргумент является двухэлементным списком числовых атомов (целых или действительных), то выполняется арифметическое вычитание. При вычитании двух целых чисел результат всегда является целым числом. В этом случае автоматическое преобразование к действительному числу не происходит даже при переполнении. Вычитание действительных чисел осуществляется, когда аргументом функции является двухэлементный кортеж действительных чисел. Результатом в этом случае является действительное число. Следует отметить отсутствие неявных преобразований при выполнении вычитания. Исключением является преобразование целочисленного нуля "0" в действительный нуль "0.0".

Если аргумент является числовым атомом, то в качестве результата осуществляется смена знака числа (унарный минус).

Аргумент функции "**-**" может также быть булевским вектором длиной, равной 2. Результатом интерпретации в этом случае является исключающее или. Допускается одноэлементный булевский атом, порождающий в качестве результата инверсное значение. 

Во всех остальных случаях результатом является ошибка операции интерпретации **BASEFUNCERROR**.

Функция, имеет следующие сигнатуры::

    :- << func (int, int) -> int
    :- << func (float, float) -> float
    :- << func (bool, bool) -> bool
    :- << func int -> int
    :- << func float -> float
    :- << func bool -> bool

Примеры::

    (3,5):- ⇒ -2
    (3.0, -5.0):- ⇒ -2.0
    (3, 5.0):- ⇒ BASEFUNCERROR
    (5):- ⇒ BASEFUNCERROR
    5:- ⇒ -5
    (min_integer,-1):- ⇒ 0
    (true,false,true):- ⇒ false
    true:- ⇒ false
    false:- ⇒ true
    (true):- ⇒ false

.. note::

    *Возможно, имеет смысл использовать для булевских операций другой символ или идентификатор. Например, xor или «~».*
    
    *Хотя при использовании статической типизации не вижу смысла в подобных заменах*

Использование знака "*"
""""""""""""""""""""""""

Знак "**\***" используется для задания бинарной функции умножения. Его аргументом является двухэлементный кортеж. Интерпретация знака "**\***" в качестве функции зависит от типов элементов кортежа. Если аргумент является двухэлементным списком числовых атомов (целых или действительных), то выполняется арифметическое умножение. При умножении двух целых чисел результат всегда является целым числом. В этом случае автоматическое преобразование к действительному числу не происходит даже при переполнении. Умножение действительных чисел осуществляется, когда аргументом функции является двухэлементный кортеж действительных чисел. Результатом в этом случае является действительное число. Следует отметить отсутствие неявных преобразований при выполнении умножения. Исключением является преобразование целочисленного нуля "0" в действительный нуль "0.0".

Аргумент функции "**\***" может также быть булевским вектором длиной, равной 2. Результатом интерпретации в этом случае является коньюнкция (логическое произведение). 

Во всех остальных случаях результатом является ошибка операции интерпретации **BASEFUNCERROR**.

Функция, имеет следующие сигнатуры::

    :* << func (int, int) -> int
    :* << func (float, float) -> float
    :* << func (bool, bool) -> bool

Примеры::

    (3, 5):* ⇒ 15
    (3, 5.0):* ⇒ BASEFUNCERROR
    (3.0, 5.0):* ⇒ 15
    (5):* ⇒ BASEFUNCERROR
    5:* ⇒ BASEFUNCERROR
    (max_integer, 2):* ⇒ New value
    (true, false):* ⇒ false
    (true, true):* ⇒ true
    true:* ⇒ BASEFUNCERROR
    (true):* ⇒ BASEFUNCERROR

.. note::

    *Возможно, имеет смысл использовать для булевских операций другой символ или идентификатор. Например, and или «&».*

Использование знака "/"
""""""""""""""""""""""""

Знак "**/**" используется для задания бинарной операции деления. Его аргументом является двухэлементный кортеж. Интерпретация знака "**/**" в качестве функции зависит от типов элементов кортежа. Аргумент должен является двухэлементным списком числовых атомов (целых или действительных), что определяет операцию деления. При делении двух целых чисел результат всегда является целым числом. В этом случае автоматическое преобразование к действительному числу не происходит даже при наличии остатка. Деление действительных чисел осуществляется, когда аргументом функции является двухэлементный кортеж действительных чисел. Результатом в этом случае является действительное число. Следует отметить отсутствие неявных преобразований при выполнении деления. Исключением является преобразование целочисленного нуля "0" в действительный нуль "0.0".

При делении на ноль выдается ошибка **ZERODIVERROR**. Во всех остальных случаях результатом является ошибка операции интерпретации **BASEFUNCERROR**.

Функция, имеет следующие сигнатуры::

    :* << func (int, int) -> int
    :* << func (float, float) -> float
    :* << func (bool, bool) -> bool


Примеры::

    (3, 5):/ ⇒ 0
    (3.0, 5.0):/ ⇒ 0.66667
    (3, 5.0):/ ⇒ BASEFUNCERROR
    (3.0, 0):/ ⇒ ZERODIVERROR
    (5):/ ⇒ BASEFUNCERROR
    5:/ ⇒ BASEFUNCERROR

Использование знака "%"
""""""""""""""""""""""""

Знак "**%**" используется для задания бинарной функции вычисления остатка от целочисленного деления. Его аргументом является двухэлементный целочисленный кортеж. Результат всегда является целым числом.

При втором аргументе, равном нулю, выдается ошибка **ZERODIVERROR**. Во всех остальных случаях результатом является ошибка операции интерпретации **BASEFUNCERROR**.

Функция, имеет следующие сигнатуры::

    :% << func (int, int) -> int

Примеры с формированием остатка::

    (13,5): % ⇒ 3)
    (13,-5): % ⇒ 3)
    (-13,5): % ⇒ -3
    (-13,-5): % ⇒ -3

Использование знака "/%"
""""""""""""""""""""""""

Знак "**%**" используется для одновременнного выполнения двух бинарных функций: целочисленного деления и  вычисления остатка. Его аргументом является двухэлементный целочисленный кортеж. Результат является двухэлементным целочисленным кортежом, первый элемент которого содержит частное от деления, а второй - остаток.

При втором аргументе, равном нулю, выдается ошибка **ZERODIVERROR**. Во всех остальных случаях результатом является ошибка операции интерпретации **BASEFUNCERROR**.

Функция, имеет следующие сигнатуры::

    :/% << func (int, int) -> (int, int)

Используется «компьютерная» интерпретация результатов, при которой частное округляется
к нулю, а знак остатка равен знаку делимого. Операции связаны между собой следующими
выражениями::

    x = (x DIV y) * y + (x MOD y)
    0 <= (x MOD y) < y, если x > 0 или
    0 >= (x MOD y) > y, если x < 0

Примеры целочисленного деления с формированием остатка::

    (13,5): /% ⇒ (2, 3)
    (13,-5): /% ⇒ (-2, 3)
    (-13,5): /% ⇒ (-2, -3)
    (-13,-5): /% ⇒ (2, -3)

Подобная трактовка отличается от математической, рассматриваемой, например в
первом томе книги Дональда Кнута::

    x = (x DIV y) * y + (x MOD y)
    0 <= (x MOD y) < y, если y > 0 или
    0 >= (x MOD y) > y, если y < 0

Кстати, Кнут и не называет операцию MOD остатком. Получить математические
версии функции, использую предопределенную операцию можно следующим образом::

    // функция целочисленного деления:
    div << func x@(int, int) -> int 
    {
        dm << x:%:1;
        [((dm,0):[>=,<]):?]^
        (
            dm,
            {(dm,1):-}
        ):return
    }
    
    // функция выделения остатка от целочисленного деления:
    mod << funcdef x@(int, int) -> int 
    {
        dm<<x:%;
        [((dm:1,0):[>=,<]):?]^
        (
            dm:2,
            [((dm:2,0):[>=,<]):?]^
            (
                {(dm:2,1):-:-},
                {(dm:2,1):+:-}
            )
        ):return
    }

.. note::

    *Функции нужно внимательно проверить, так как написал их без контроля.*

Использование знаков: "=", "!=", "<", "<=", ">", ">="
""""""""""""""""""""""""""""""""""""""""""""""""""""""

Данные знаки используется для задания бинарных операции сравнения. Аргументом любого из них является двухэлементный кортеж, данные которого имеют одинаковый тип. Неявное автоматическое преобразование данных к одному типу внутри кортежа не происходит. Допускается сравнение между собой:

    * Целочисленных данных (все операции);
    * Действительных данных (все операции);
    * Символов (все операции);
    * Булевских данных (все операции);
    * Спецсимволов (на равенство и неравенство);
    * Типов (на равенство и неравенство);
    * Функций (на равенство и неравенство).

Результатом является булевское значение.

Во всех остальных случаях результатом является ошибка операции интерпретации **BASEFUNCERROR**.

Пусть cmp означает один из представленных выше знаков операции сравнения. Тогда функции имею следующие обобщенны сигнатуры::

    :cmp << func (int, int) -> bool
    :cmp << func (float, float) -> bool
    :cmp << func (char, char) -> bool
    :cmp << func (bool, bool) -> bool
    :cmp << func (spec, spec) -> bool
    :cmp << func (type, type) -> bool
    :cmp << func (func, func) -> bool

При этом необходимо учесть что не каждый из представленных типов имеет все реализации

Использование в качестве функций предопределенных типов
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Использование статической типизации позволяет в большинстве случаев знать типы артефактов во время компиляции. Также во время компиляции многи типы выводимы из функций и других типов. Вместе с тем в случае обобщений или при использовании типа ``any`` необходимо определять тип артефакта во время выполнения. Поэтому наличие функций, обеспечивающих анализ типов в целом необходимо.

Непосредственно типы в определяются как перечисления. При этом предопределенные типы заданы изначально. Пользовательские типы добавляются в процессе написания программы. Все они относятся к типу типов ``type``. Однако в непосредственно в функциях типы являются частью обрабатывамых значений, каждое из которых определяется в виде двойки::

    Значение = (тип, величина).

Наряду с обработкой данных, осуществляемой неявно, допускается выделять тип любого элемента данных. Для этого используется предопределенная операция type. Формируемая при этом величина принадлежит к «типовым» и имеет точно такую же организацию, как и любой другой аргумент. Ее специфика проявляется лишь в том, что типом аргумента является type.

    Структура типового элемента = (type, значение типа).

Поэтому для выделения типа ключевое слов type используется в качестве функции в операторе интерпретации. В результате возвращается значение типа, принадлежащее множеству допустимых типов артефактов. Функция получение типа значения имеет следующую сигнатуру::

    type << func any -> type

Например::

    10:type ⇒ int
    3.14:type ⇒ float
    (1, 2, 4, 7) :type ⇒ vector
    [1, 2, 3, 3, 4] :type ⇒ swarm

Применение функции **type** к «типовому» элементу невозможно и ведет к ошибке интерпретации **TYPEERROR**, например::

    int : type ⇒ TYPEERROR

Предопределенные типы могут в качестве значений использоваться для различных операций преобразования типов, определяемых в языке. Исходя из этого их имена задействованы в соответствующих функциях, связанных с предопределенными величинами.

Использование типа int
""""""""""""""""""""""""""""""""""""""""""

Функция осуществляет преобразование аргумента к целочисленному типу. Эти преобразования возможны для действительных чисел, символов, булевских величин. Действительные числа преобразуются к целым путем отсечения дробной части независимо от знака числа.

Функция имеет следующие сигнатуры::

    int << func bool -> int
    int << func float -> int
    int << func char -> int

Примеры::

    13.8:int  ⇒ 13
    -13.2:int  ⇒ -13
    -13.8:int  ⇒ -13
    '0':int ⇒ 48
    true:int ⇒ 1
    false:int ⇒ 0

Использование типа bool
""""""""""""""""""""""""""""""""""""""""""

Функция осуществляет преобразование аргумента к булевскому типу. Эти преобразования возможны для целых чисел. Если число равно нулю, то резульатом является ``false``. В противном случае результат равен ``true``.

Функция имеет следующую сигнатуру::

    bool << func int -> bool

Примеры::

    1:bool  ⇒ true
    -10:bool  ⇒ true
    100:bool ⇒ true
    0:bool ⇒ false

Использование типа signal
""""""""""""""""""""""""""""""""""""""""""

Функция осуществляет преобразование аргумента любого типа к сигнальному значению. То есть идет потеря величины аргумента. 

Функция имеет следующую сигнатуру::

    signal << func any -> signal

Примеры::

    1:signal  ⇒ !
    !:signal  ⇒ !

Использование типа error
""""""""""""""""""""""""""""""""""""""""""

Функция осуществляет формирование общей ошибки и прерывание программы. Может применяться к любому аргументу.

Функция имеет следующую сигнатуру::

    error << func any -> ERROR

Примеры::

    1:error  ⇒ ERROR
    !:error  ⇒ ERROR

Использование в качестве функций составных типов
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Формируемые пользователем типы в основном базируются на составных типах, позволяющих конструировать разнообразные конфигурации данных, которым присваивются соответствующие имена. Эти имена пользовательских типов также могут использоваться для задания пользовательских функций. Однако ряде преобразований как уже сформированных пользовательских типов, так и программоформирующих операторов может осуществляться путем использования имен, определяющих составные типы. К этим именам относятся: vector, tuple, struct, swarm, stream, union.

Для некоторых пар этих составных типов возможны неявные преобразования, определяемые семантикой языка. В частности допускается неявное преобразование вектора в кортеж. Данное преобразование позволяет автоматически согласовывать формируемые значения с аргументом функции, если все элементы аргумента имеют одинаковый тип. В принципе при необходимости такое преобразование можно описывать и явно, что позволяет говорить о наличии следующей сигнатуры::

    tuple << func any(*) -> (any...)

Другим аналогично используемым неявным преобразованием является преобразование в кортеж структуры. В этом случае именованный доступ к полученному результату заменяется на позиционный. Порядок следования типов данных в кортеже совпадает с порядком их следования в исходной структуре. Преобразование описывается следующей сигнатурой::

    tuple << func (a1:t1, a2:t2, ...) -> (t1, t2, ...)

Помимо этого ряд преобразований можно задавать явно, если они возможны во время компиляции. В частности допускается преобразовывать структуру, состоящую из элементов одного типа в вектор. Аналогичное преобразование в вектор возможно и для кортежа, все элементы которого имеют один тип. Для этих преобразований имеются соответствующие функции::

    vector << func (any...) -> any(*)
    vector << func ([...]:any -> any(*)

Ряд дополнительных преобразований составных типов можно осуществлять, используя выше описанные функции, задаваемые специальными знаками.

Использование в качестве функций пользовательских типов
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Разработчик программного обеспечения может создавать свои описания типов на основе уже существующих предопределенные типов и ранее разработанных именованных пользовательских типов. Как и предопределенные типы, именованные пользовательские типы могут использоваться в качестве функций. Однако алгоритмы, выполняемые этими функциями, а также их сигнатуры определяются явно разработчиками ПО.

Такой подход говорит о том, что в принципе пользователь может связать с такой функцией какие угодно вычисления, тем самым обеспечивая гибкость в использовании имен типов в качестве функций. Поэтому невозможно заранее предугадать их поведение.

Использование в качестве функции обобщенного типа any
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Обобщенный тип any в качестве признака фиксирует имя включаемого в него типа. Функция с именем ``any``, формирует вокруг конкретного типа оболочку, включающу признак (тэг) и ссылку на охватываемый артефакт. В качестве охватываемого типа может использоваться любой именованный тип за исключением самого ``any``. Таким образом, преобразование типа заключается в его охвате, как и в случае с пользовательским обобщением.

Использование в качестве функции описывается следующей сигнатурой::

    any << func named -> any

Для выделения конкретного артефакта из глобального обобщения any необходимо проверить признак, после чего выделить значения используя имя полученного типа в качестве функции, осуществляя тем самым явное приведение вложенного артефакта к его типу. 

То есть, если тип вложенного артефакта совпадает с типом, используемым в качестве функции, то результатом является артефакт указанного типа. В противном случае генерируется ошибка **TYPEERROR** и происходит прерывание программы.

Проверка признака осуществляется функцией ``tag``, которая применима ко всем обобщениям.


Использование функций с массовым оператором интерпретации
---------------------------------------------------------------------




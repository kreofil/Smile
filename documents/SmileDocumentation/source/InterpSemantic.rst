.. |date| date:: %d.%m.%Y
.. |time| date:: %H:%M
.. |copy| unicode:: 0xA9 .. copyright sign

.. Текущая дата |date| и время |time|

.. meta::
   :description: Описание концепций, языковых и инструментальных средств функционально-потокового параллельного программирования.
   :keywords: парадигмы программирования, функционально-потоковое параллельное программирование

:Author:    Александр Легалов
:Email:     <legalov@mail.ru>
:Date:      |date|
:Version:   0.1

:Copyright: |copy| Допускается свободное использование с обязательной ссылкой на сайт автора: "Оригинальная версия размещена на сайте www.softcraft.ru".

.. .. sectnum::
    :start: 1

.. .. contents:: Содержание
    :depth: 3


==========================================================
Семантика оператора интерпретации
==========================================================

Появление статической типизации привело к пересмотру семантики операций над контейнерными данными. В честности этому содействовало то, что у вектора, роя и потока все данные однотипные, а тип данных известен. Это позволяет выполнять над ними без дополнительной проверки типов не только массовые функции над всеми элементами, но и рассматривать каждый контейнер как единое целое.

Использование статической типизации также привело к разделению оператора интерпретации на два разных вида: одиночный (одноаргументный) и групповой (массовый, поэлементный). Одиночный оператор интерпретации, обозначаемый через ":" (постфиксная форма) или "^" (префиксная форма) предназначен для задания обычных функций, воспринимающих аргумент в качестве единого целого. Массовый оператор интерпретации используется для задания вычислений над каждым однотипным элементом контейнера, порождая на выходе контейнер с элементами тип которых соответствует типу результата выполняемой функции. Обозначается двойным значком "::" для постфиксной или "^^" для префиксной форм соответственно.

Использование разных обозначений позволяет однозначно применять функцию с одним и тем же именем в разных контекстах. Например, функция вычитания "-" над аргументом (10, -3), воспринимаемом как вектор, состоящий из двух целых чисел, порождает следующие значения::

    // двуместная функция вычитания над одним аргументом
    (10, -3):- ⇒ 13

    // функция смены знака, массово применяемая
    // к двум однотипным аргументам
    (10, -3)::- ⇒ (-10, 3)

Разделение оператора интерпретации на массовый и одноаргументный позволяет ввести более гибкий одноаргументный набор дополнительных функций для потока и роя, обеспечивающих обработку асинхронно поступающих данных.

Одиночный оператор интерпретации обрабатывает как функции, определенные семантикой языка (предопределенные функции), так и функции, разрабатываемые программистом. В отличие от него семантика массового оператора интерпретации ориентирована только на предопределенные функции, обрабатывающие композиции данных.

Использование функций с одиночным оператором интерпретации
------------------------------------------------------------------------------

Одиночный оператор интрепретации по сути является ключевым, так как не ведет к последующей декомпозиции данных, а рассматривает свои аргументы как единое целое, для каждой пары которых определена семантика выполнения. Эта семантика четко определяет соответствие между функцией и данными. Оператор изначально отслеживает, чтобы аргумент-данные соответствовал сигнатуре аргумента-функции, после чего обеспечивает выполнение функции на обработку данных. При отсутствии этого соответствие результатом является ошибка и прерывание программы.

Предопределенные функции
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Существует большое число предопределенных функций, сигнатура которых и семантика вычислений определены изначально. Эти функции используются как для выполнения базовых арифметических и логических операций, так и для обеспечения различных композиций и декомпозиций данных, что осуществляется в дополнение к программоформирующим операторам языка.

Предопределенные функции и данные формируются на основе атомов, каждый из которых может быть в роли как аргумента, так и функции оператора интерпретации. При этом ряд атомарных артефактов могут выступать только в роли данных, другие - в роли функций, третьи - в той и другой.

Для идентификации предопределенных функций в основном используются специальные символы. Обычно за ними закрепляются вычислительные операции, традиционные для этих символов в большинстве существующих языков программирования. Задаются допустимые аргументы и значения этих функций. При этом типы аргумента и результата являются именованными типами и определяется аксиоматически при описании функции. Допускается перегрузка предопределенных функций, при которой формируются новые сигнатуры.

.. note::

    *В данный момент я пытаюсь выделить подмножество предопределенных функций, предназначенных для формирования каркаса ФПП программы, характерного для Праязыка. В таком виде программа вряд ли может создаваться, так как минимальный набор манипуляций с данными (сравнения и т.д.) необходим даже для самого базового языка.*

    *В рассматриваемой версии не все спецзнаки имеют определенную семантику. Предполагается, что в дальнейшем она будет разрабатываться и уточняться. Наряду со специальными знаками в качестве предопределенных функций могут выступать и идентификаторы, которые, как и ключевые слова, запрещены для других применений.*

Ниже приводится описание семантики предопределенных функций, используемых в текущей версии. Следует отметить, что для аргументов, тип которых при описании не задан результатом будет ошибка: «неправильное использование функции».

Предопределенные функции общего назначения
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Предопределенные функции общего назначения обеспечивают универсальные преобразования данных независимо от их типа и структуры. Они позволяют работать с разными артефактами.

Использование знака "|"
"""""""""""""""""""""""""""""

Знак **"|"** задает функцию нахождения длины контейнерного типа. Аргументом-данными могут быть вектор, кортеж, рой. Результат – целое число, задающее количество элементов.

Данная функция имеет следующие сигнатуры::

    :| << func any(*) -> int
    :| << func any[*] -> int
    :| << func (...) -> int

Если аргумент не является одним из указанных контейнерных типов, то результатом является ошибка операции интерпретации **BASEFUNCERROR**. Использование функции позволяет проверить размер аргумента перед обработкой, а лишь затем начать выделение его элементов. Следует при этом отметить, что выделение элементов для кортежа, в соответствии с описанным выше, может осуществляться только если тип этих элементов определен на этапе компиляции или если есть возможность приведения к векторному типу.

Примеры::

    (a, n, (q, w), s):| ⇒ 4
    [1, 2, 3, 4, 5]:| ⇒ 5
    ((1, 2, (f, d), x)):| ⇒ 1

Использование знака "?"
""""""""""""""""""""""""""""

Функция **"?"** осуществляет единичную селекцию, то есть, ищет в булевском векторе данных позицию единственного истинного значения и выводит его целочисленный номер. Функция полезна для организации единичного выбора. Например::

    (false, true, false, false):? ⇒ 1
    
Данная функция имеет следующие сигнатуры::

    :? << func bool(*) -> int
    :? << func bool[*] -> int

Если список булевских величин состоит только из ложных значений, или в том случае, когда в нем имеется несколько истинных значений формируется ошибка базовой функции::

    (false, false, false):? ⇒ BASEFUNCERROR
    (true, false, true, false):? ⇒ BASEFUNCERROR

Использование знака "??"
""""""""""""""""""""""""""""""""

Функция **"??"**, осуществляет вычисление номеров позиций истинных булевских констант в булевском векторе данных. То есть, используется как селектор множества позиций. В качестве результата формируется целочисленный вектор с номерами тех элементов булевского вектора, чьи значения были равны true. Функция полезна для организации выборочного продолжения дальнейших вычислений с использованием множественного селектора. Полученные целочисленные значения используются для выбора элементов из контейнерных данных. Например::

    (true, false, true, false, false, true):?? ⇒ (0, 2, 5)
    
Данная функция имеет следующие сигнатуры::

    :?? << func bool(*) -> int(*)
    :?? << func bool[*] -> int[*]

Если список состоит только из ложных значений, на выходе формируется вектор, не содержащий элементов, автоматически преобразуемый в ошибку базовой функции::

    (false, false, false):? ⇒ () ⇒ BASEFUNCERROR

Использование знака ".."
"""""""""""""""""""""""""

Знак **".."** используется в качестве функции, формирующей вектор или рой из числовых атомов. В качестве аргумента может выступать трехэлементный вектор или рой, в котором первое число задает начало интервала, второе - его конец, а третье - шаг. Числа могут быть как целые, так и действительные, но одного типа, а шаг принимать как положительные, так и отрицательные значения. Необходимо отсутствие расхождений между значением шага и границами интервала.

Кроме этого аргумент функции может быть целочисленным двухэлементным вектором или роем. В этом случае первый элемент определяет нижнюю целочисленную границу интервала, а второй верхнюю. При этом нижняя граница должна быть меньше или равной верхней границе, а шаг по умолчания принимается равным единице. 

При некорректном задании границ интервала, идентифицированном во время выполнения, данная функция возвращает ошибку **BOUNDERROR**. Если некорректно задана структура контейнера или тип его элементов, то возвращается ошибка периода компиляции.

Данная функция имеет следующие сигнатуры::

    :.. << func int(2) -> int(*)
    :.. << func float(2) -> float(*)
    :.. << func int(3) -> int(*)
    :.. << func float(3) -> float(*)
    :.. << func int[2] -> int[*]
    :.. << func float[2] -> float[*]
    :.. << func int[3] -> int[*]
    :.. << func float[3] -> float[*]

Примеры::

    (-3.5, 2.0, 1.5):.. ⇒ (-3.5, -2.0, -0.5, 1.0)
    [1, 5]:.. ⇒ [1, 2, 3, 4, 5]
    (2, 1):.. ⇒ BOUNDERROR


.. note::

    *В дальнейшем предполагается введение интервальных констант, задающих необходимый диапазон.*

Использование функции "dup"
""""""""""""""""""""""""""""

Функция обеспечивает создания вектора из одинаковых элементов путем дублирования. Аргумент – кортеж, первый элемент которого – значение некоторого предопределенного именованного типа, а второй – положительная целочисленная константа. Результат – вектор, элементами которого являются копии первого элемента аргумента, а количество элементов равно значению второго элемента аргумента.

Пример::

    (10, 5):dup ⇒ (10, 10, 10, 10, 10)

Данная функция имеет следующую сигнатуру::

    dup << func (any, int) -> any(*)

При некорректном задании количества дубликатов, идентифицированном во время выполнения, данная функция возвращает ошибку **BOUNDERROR**.

Использование знака "#"
"""""""""""""""""""""""""

Данный знак предполагает преобразование двух кортежей одинаковой длины, размещенных в кортеже в кортеж, состоящий из множества двоек. В качестве исходных аргументов могут выступать как атомарные элементы, так и составные конструкции различного типа. Форируемые пары являются кортежами. Например::

    ((1,2,3),(4,5,6)):# ⇒ ((1,4),(2,5),(3,6))
    (((1,4),(2,5),(3,6)), (+,-,*)):# ⇒ (((1,4),+),((2,5),-),((3,6),*))

Данная функция может использоваться в дальнейшем для реализации различных групповых операций над данными. Она имеет следующую сигнатуру::

    :# << func tuple(tuple(t10, t11,...), tuple(t20, t21...)) 
            -> tuple(tuple(t10,t20), tuple(t11,t21),...)

При некорректном задании аргументов, идентифицированном во время выполнения, данная функция возвращает ошибку **BOUNDERROR**. При несовпадении размеров кортежей функция возвращает ошибку **SIZEERROR**.

Использование данных
~~~~~~~~~~~~~~~~~~~~~

Данные тоже могут допускать различное толкование в зависимости от того, в
какой части операции интерпретации они встретились.

Использование в качестве функции сигнальной константы "**!**"
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Использование сигнальной константы в качестве функции ориентировано на отображение аргумента, поступившего на вход данных в качестве результата.

Функция имеет следующую сигнатуру::

    :! << func any -> any

То есть, в качестве функции знак "**!**" интерпретируется как пустая операция, осуществляющая пропуск значения аргумента в качестве результата. Данном знаку можно сопоставить следующее определение функции::

    :! << func x@any -> any { 
        x:return 
    }

Если аргумент является вектором, группой или атомом, то происходит его выдача в качестве результата.  Если же аргумент определен как задержка, то предварительно оператор интерпретации осуществляет ее раскрытие, ведущее к вычислению задержанного выражения. Полученное значение передается функции, которая и возвращает его уже без дополнительных изменений.

Пример::

    {(2,3):+}:! ⇒ 5

Сигнальная константа также может использовать как аргумент-данные. В этом случае она интерпретируется как отсутствие аргумента.  Обычно используется с теми функциями, которые не получают аргументов. То есть она воспринимается как сигнал, запускающий функцию в требуемый момент времени. Например, пусть будет задана функция::

    sin_pi_div_4 << func -> float {
        (3.14, 4.0):/:sin >>return
    }

Тогда ее вызов будет оформлен следующим образом::

    !:sin_pi_div_4

Использование целых чисел в качестве функции
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Целые положительные числа могут использоваться для выбора элементов из векторов, кортежей и роев. То есть они по сути могут выступать в качестве индексов. Получение элемента из кортежа можно показать на следующем примере::

    (10, 9, 8, 7, 6, 5, 4, 3, 2, 1):5 ⇒ 6

.. note::

    *Вариант с отрицательными индексами убран, так как он ведет к неоднозначному типу результата. Поэтому корректным считается только положительный индекс.*

    Целые отрицательные числа обеспечивают удаления из из контейнеров элементов с индексом равным абсолютному значению индексирующего числа. Например, после этой операции размер кортежа уменьшается на единицу::

        (10, 9, 8, 7, 6, 5, 4, 3, 2, 1):-5 ⇒ (10, 9, 8, 7, 5, 4, 3, 2, 1)

Данная функция имеет следующую сигнатуры::

    :@int << func any(*) -> any
    :@int << func (...) -> any
    :@int << func any[*] -> any

Знак типа "@" указывает на то что в данном случае подразумевается неименованное значение целочисленного типа. То есть, любая константа. Возврат значения из вектора происходит тогда, когда данный вектор полностью сформируется и будет готов к использованию в операторе интерпретации.

При использовании с кортежем необходимо, чтобы все его данные были одного типа, что позволяет получить на выходе предопределенный тип данных неявно сводимый к вектору. Кроме этого возможна ситуация когда разные типы элементов кортежа известны во время компиляции, а значением селектора является константное выражение, что позволяет вывести тип результата. Несоответствие этому условию определяется во время компиляции. Если в качестве данных выступает рой, то оператор интерпретации запускается на выполнения не дожидаясь поступления всех элементов роя. Достаточно наличия целочисленного значения, определяющего функцию селекцию и прихода в рой элемента с указанным индексом. То есть в данной ситуации осуществляется асинхронный выбор элемента, что может ускорить вычисления, но ведет к дополнительным расходам при реализации механизма.

В случае нулевого или отрицательного значения порождается ошибка **BOUNDERROR**, сигнализирующая о неправильном индексе. 

Использование булевских значений в качестве функций
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Функция, определяемая булевским значением, осуществляет выбор первого или второго элемента двухэлементного вектора в зависимости от значения. Значение ``true`` обеспечивает выбор первого элемента вектора, а значение ``false`` - второго. Оба значения должны принадлежать одному и тому же типу. По сути это селектор значения, реализующий простейшее условие выбора. В качестве аргумента могут выступать двухэлементные: вектор, рой, кортеж с элементами одного типа, сводимый к двухэлементному вектору (или булевский селектор является константным выражением). Отличие между вектором (кортежем) и роем определяется в подходе к синхронизации вычислений, как и в случае использования в качестве функций целочисленных селекторов.

Функция, определяемая булевским значением, имеет следующие сигнатуры::

    :@bool << func (any, any) -> any
    :@bool << func any(2) -> any
    :@bool << func any[2] -> any

Примеры::

    (10, 20):true  ⇒ 10
    (10, 20):false ⇒ 20
    [10, 20]:true  ⇒ 10
    [10, 20]:false ⇒ 20

В случае вектора меньшей или большей размерности порождается ошибка **BOUNDERROR**, сигнализирующая о неправильном обращении. Следует также отметить, что порядок выбора не связан с числовыми значениями, используемыми для представления ``true`` и ``false``, а определяется в соответствии с общепринятой логикой функционирования условного оператора ``if...then...else`` традиционных языков программирования.

Функции, выполняющие вычисления
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Ряд знаков зарезервированы для выполнения функции, свойственных их традиционному применению во многих языках программирования. Следует отметить, что в ряде случаев они изначально перегружены в большей степени, чем соответствующие знаки в ряде других языков. Это обусловлено отсутствием преобразований типов по умолчанию, что обеспечивает большую однозначность и понимание того, в каком контексте используется тот или иной знак. Практически все эти знаки имеют тип **none:func**.

.. note::

    *Следует обратить внимание на присутствие в тексте действительных чисел, которые пока реализовывать не планируется. Но они ведь все равно появятся...*

Сложение "**+**"
""""""""""""""""""""""""""""""

Знак "**+**" используется для задания бинарных и унарных операций. В случае бинарных операций его аргументом является двухэлементный кортеж. Интерпретация знака **"+"** в качестве функции зависит от типов элементов кортежа. Если аргумент является двухэлементным кортежем числовых атомов (целых или действительных), то выполняется арифметическое сложение. При сложении двух целых чисел результат всегда является целым числом. В этом случае автоматическое преобразование к действительному числу не происходит даже при переполнении. Сложение действительных чисел осуществляется, когда аргументом функции является двухэлементный кортеж действительных чисел. Результатом в этом случае является действительное число. Следует отметить отсутствие неявных преобразований при выполнении сложения. Исключением является преобразование целочисленной константы "0" в действительный нуль "0.0".

Если аргумент является числовым атомом, то он выдается в качестве результата без
каких-либо преобразований.

Аргумент функции **"+"** может также быть булевским вектором длиной, равной 2. Результатом в этом случае является дизъюнкция (логическое «или»). Допускается одноэлементный булевский атом, порождающий в качестве результата значение этого же элемента. 

Во всех остальных случаях результатом является ошибка операции интерпретации **BASEFUNCERROR**.

Функция, имеет следующие сигнатуры::

    :+ << func (int, int) -> int
    :+ << func (float, float) -> float
    :+ << func (bool, bool) -> bool
    :+ << func int -> int
    :+ << func float -> float
    :+ << func bool -> bool

Примеры сложения::

    (3, 5):+ ⇒ 8
    (3.0, 5.0):+ ⇒ 8.0
    (3, 5.0):+ ⇒ BASEFUNCERROR
    (5):+ ⇒ BASEFUNCERROR
    5:+ ⇒ 5
    (max_integer, 1):+ ⇒ 0
    (true, false):+ ⇒ true
    true:+ ⇒ true
    false:+ ⇒ false
    (true):+ ⇒ BASEFUNCERROR

.. note::

    *Арифметические операции над действительными числами пока не реализуются*

Использование знака "\-"
""""""""""""""""""""""""

Знак "**-**" используется для задания бинарных и унарных операций. В случае бинарных операций его аргументом является двухэлементный кортеж. Интерпретация знака "**-**" в качестве функции зависит от типов элементов кортежа. Если аргумент является двухэлементным кортежем числовых атомов (целых или действительных), то выполняется арифметическое вычитание. При вычитании двух целых чисел результат всегда является целым числом. В этом случае автоматическое преобразование к действительному числу не происходит даже при переполнении. Вычитание действительных чисел осуществляется, когда аргументом функции является двухэлементный кортеж действительных чисел. Результатом в этом случае является действительное число. Следует отметить отсутствие неявных преобразований при выполнении вычитания. Исключением является преобразование целочисленной константы "0" в действительный нуль "0.0".

Если аргумент является числовым атомом, то в качестве результата осуществляется смена знака числа (унарный минус).

Аргумент функции "**-**" может также быть булевским кортежем длиной, равной 2. Результатом в этом случае является исключающее или. Допускается одноэлементный булевский атом, порождающий в качестве результата инверсное значение. 

Во всех остальных случаях результатом является ошибка операции интерпретации **BASEFUNCERROR**.

Функция, имеет следующие сигнатуры::

    :- << func (int, int) -> int
    :- << func (float, float) -> float
    :- << func (bool, bool) -> bool
    :- << func int -> int
    :- << func float -> float
    :- << func bool -> bool

Примеры::

    (3,5):- ⇒ -2
    (3.0, -5.0):- ⇒ -2.0
    (3, 5.0):- ⇒ BASEFUNCERROR
    (5):- ⇒ BASEFUNCERROR
    5:- ⇒ -5
    (min_integer,-1):- ⇒ 0
    (true,false,true):- ⇒ false
    true:- ⇒ false
    false:- ⇒ true
    (true):- ⇒ false

Использование знака "*"
""""""""""""""""""""""""

Знак "**\***" используется для задания бинарной функции умножения. Его аргументом является двухэлементный кортеж. Интерпретация знака "**\***" в качестве функции зависит от типов элементов кортежа. Если аргумент является двухэлементным кортежем числовых атомов (целых или действительных), то выполняется арифметическое умножение. При умножении двух целых чисел результат всегда является целым числом. В этом случае автоматическое преобразование к действительному числу не происходит даже при переполнении. Умножение действительных чисел осуществляется, когда аргументом функции является двухэлементный кортеж действительных чисел. Результатом в этом случае является действительное число. Следует отметить отсутствие неявных преобразований при выполнении умножения. Исключением является преобразование целочисленной константы "0" в действительный нуль "0.0".

Аргумент функции "**\***" может также быть булевским кортежем длиной, равной 2. Результатом в этом случае является конъюнкция (логическое произведение). 

Во всех остальных случаях результатом является ошибка операции интерпретации **BASEFUNCERROR**.

Функция, имеет следующие сигнатуры::

    :* << func (int, int) -> int
    :* << func (float, float) -> float
    :* << func (bool, bool) -> bool

Примеры::

    (3, 5):* ⇒ 15
    (3, 5.0):* ⇒ BASEFUNCERROR
    (3.0, 5.0):* ⇒ 15
    (5):* ⇒ BASEFUNCERROR
    5:* ⇒ BASEFUNCERROR
    (true, false):* ⇒ false
    (true, true):* ⇒ true
    true:* ⇒ BASEFUNCERROR
    (true):* ⇒ BASEFUNCERROR

Использование знака "/"
""""""""""""""""""""""""

Знак "**/**" используется для задания бинарной операции деления. Его аргументом является двухэлементный кортеж. Интерпретация знака "**/**" в качестве функции зависит от типов элементов кортежа. Аргумент должен является двухэлементным кортежем числовых атомов (целых или действительных), что определяет операцию деления. При делении двух целых чисел результат всегда является целым числом. В этом случае автоматическое преобразование к действительному числу не происходит даже при наличии остатка. Деление действительных чисел осуществляется, когда аргументом функции является двухэлементный кортеж действительных чисел. Результатом в этом случае является действительное число. Следует отметить отсутствие неявных преобразований при выполнении деления. Исключением является преобразование целочисленной константы "0" в действительный нуль "0.0".

При делении на ноль выдается ошибка **ZERODIVERROR**. Во всех остальных случаях результатом является ошибка операции интерпретации **BASEFUNCERROR**.

Функция, имеет следующие сигнатуры::

    :/ << func (int, int) -> int
    :/ << func (float, float) -> float

Примеры::

    (3, 5):/ ⇒ 0
    (3.0, 5.0):/ ⇒ 0.66667
    (3, 5.0):/ ⇒ BASEFUNCERROR
    (3.0, 0):/ ⇒ ZERODIVERROR
    (5):/ ⇒ BASEFUNCERROR
    5:/ ⇒ BASEFUNCERROR

Использование знака "%"
""""""""""""""""""""""""

Знак "**%**" используется для задания бинарной функции вычисления остатка от целочисленного деления. Его аргументом является двухэлементный целочисленный кортеж. Результат всегда является целым числом.

При втором аргументе, равном нулю, выдается ошибка **ZERODIVERROR**. Во всех остальных случаях результатом является ошибка операции интерпретации **BASEFUNCERROR**.

Функция, имеет следующие сигнатуры::

    :% << func (int, int) -> int

Примеры с формированием остатка::

    (13,5): % ⇒ 3
    (13,-5): % ⇒ 3
    (-13,5): % ⇒ -3
    (-13,-5): % ⇒ -3

Использование знака "/%"
""""""""""""""""""""""""

Знак "**/%**" используется для одновременного выполнения двух бинарных функций: целочисленного деления и  вычисления остатка. Его аргументом является двухэлементный целочисленный кортеж. Результат является двухэлементным целочисленным кортежем, первый элемент которого содержит частное от деления, а второй - остаток.

При втором аргументе, равном нулю, выдается ошибка **ZERODIVERROR**. Во всех остальных случаях результатом является ошибка операции интерпретации **BASEFUNCERROR**.

Функция, имеет следующие сигнатуры::

    :/% << func (int, int) -> (int, int)

Используется «компьютерная» интерпретация результатов, при которой частное округляется
к нулю, а знак остатка равен знаку делимого. Операции связаны между собой следующими
выражениями::

    x = (x DIV y) * y + (x MOD y)
    0 <= (x MOD y) < y, если x > 0 или
    0 >= (x MOD y) > y, если x < 0

Примеры целочисленного деления с формированием остатка::

    (13,5): /% ⇒ (2, 3)
    (13,-5): /% ⇒ (-2, 3)
    (-13,5): /% ⇒ (-2, -3)
    (-13,-5): /% ⇒ (2, -3)

Подобная трактовка отличается от математической, рассматриваемой, например в
первом томе книги Дональда Кнута::

    x = (x DIV y) * y + (x MOD y)
    0 <= (x MOD y) < y, если y > 0 или
    0 >= (x MOD y) > y, если y < 0

Кстати, Кнут и не называет операцию MOD остатком. Получить математические
версии функции, использую предопределенную операцию можно следующим образом::

    // функция целочисленного деления:
    div << func x@(int, int) -> int 
    {
        dm << x:%:1;
        {(dm,0):(>=,<):?}^
        (
            dm,
            {(dm,1):-}
        ):return
    }
    
    // функция выделения остатка от целочисленного деления:
    mod << func x@(int, int) -> int 
    {
        dm<<x:%;
        {(dm:1,0):(>=,<):?}^
        (
            dm:2,
            {(dm:2,0):(>=,<):?}^
            (
                {(dm:2,1):-:-},
                {(dm:2,1):+:-}
            )
        ):return
    }

.. note::

    *Функции нужно внимательно проверить, так как написал их без особого контроля.*

Использование знаков: "=", "!=", "<", "<=", ">", ">="
""""""""""""""""""""""""""""""""""""""""""""""""""""""

Данные знаки используется для задания бинарных операции сравнения. Аргументом любого из них является двухэлементный кортеж, данные которого имеют одинаковый тип. Неявное автоматическое преобразование данных к одному типу внутри кортежа не происходит. Допускается сравнение между собой:

    * Целочисленных данных  - все операции;
    * Действительных данных -все операции;
    * Символов - все операции;
    * Булевских данных - все операции;
    * Данных, для которых тип не определен (пустой тип) -на равенство и неравенство;
    * Типов - на равенство и неравенство;
    * Функций - на равенство и неравенство.

Результатом является булевское значение.

Во всех остальных случаях результатом является ошибка операции интерпретации **BASEFUNCERROR**.

Пусть cmp означает один из представленных выше знаков операции сравнения. Тогда функции имеют следующие обобщенны сигнатуры::

    :cmp << func (int, int) -> bool
    :cmp << func (float, float) -> bool
    :cmp << func (char, char) -> bool
    :cmp << func (bool, bool) -> bool
    :cmp << func (empty, empty) -> bool
    :cmp << func (type, type) -> bool
    :cmp << func (func, func) -> bool

При этом необходимо учесть что не для каждого из представленных типов имеются все реализации операций сравнения.

Использование в качестве функций предопределенных типов
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Применение статической типизации позволяет в большинстве случаев знать типы артефактов во время компиляции. Также во время компиляции многие типы выводимы из функций и других типов. Вместе с тем, в случае обобщений (при использовании типа ``union``) необходимо определять тип артефакта во время выполнения. Поэтому наличие функций, обеспечивающих анализ типов в целом необходимо.

Непосредственно типы определяются как перечисления. При этом предопределенные типы заданы изначально. Пользовательские типы добавляются в процессе написания программы. Все они относятся к типу типов ``type``. Непосредственно в функциях типы являются частью обрабатываемых значений, каждое из которых определяется в виде двойки::

    Значение = (тип, величина).

Наряду с обработкой данных, осуществляемой неявно, допускается выделять тип любого элемента данных. Для этого используется предопределенная операция type. Формируемая при этом величина принадлежит к «типовым» и имеет точно такую же организацию, как и любой другой аргумент. Ее специфика проявляется лишь в том, что типом аргумента является type.

    **Структура типового элемента = (type, значение типа).**

Поэтому для выделения типа ключевое слов type используется в качестве функции в операторе интерпретации. В результате возвращается значение типа, принадлежащее множеству допустимых типов артефактов. Функция получение типа значения имеет следующую сигнатуру::

    type << func any -> type

Например::

    10:type ⇒ int
    3.14:type ⇒ float
    (1, 2, 4, 7): type ⇒ tuple
    [1, 2, 3, 3, 4]: type ⇒ swarm

Применение функции **type** к «типовому» элементу невозможно и ведет к ошибке интерпретации **TYPEERROR**, например::

    int : type ⇒ TYPEERROR

Предопределенные типы в качестве функций могут использоваться для различных операций преобразования типов, определяемых в языке. При этом можно считать, что выступая в качестве функций они имеют определенные сигнатуры, в которых аргументы-данные, принадлежащие входному типу, преобразуются в значения, тип которого определяется результатом. 

Существует также возможность, за счет использования пользовательской перегрузки, формировать собственные преобразователи как для предопределенных, так и порожденных именованных типов. В роли такого преобразователя выступает специальный оператор ``transform``. По сути это некоторая функция-конструктор, синтаксис которой отличается от обычной функции в связи со спецификой использования. Синтаксис преобразователь задается следующим образом:

**преобразователь = "transform" имя_аргумента " "@" "имя_типа" "->" "имя_типа"**

                    **[тело_преобразованиеля ].**

**тело_преобразователя = [ "{" [ Элемент {";" Элемент }] "}" ].**

Практически тело преобразователя совпадает с телом функции. В результате при компиляции формируется описание сигнатуры (прототипа), которое полностью совпадает с описанием функции, имя которой совпадает с именем типа, что позволяет компилятору работать с преобразователями также как и с функциями.

.. note::

    В данной ситуации при в общем-то понятной и достаточно прозрачной семантике встал вопрос, каким образом должен выглядеть синтаксис преобразователя типа. Рассматривались следующие варианты.
    
    1) Описание всех преобразователей в виде специальной функции трансформации, перегружаемой на все возможные ситуации. Ее схематичный вид должен был выглядеть следующим образом:
    
    ``transform << func имя_аргумента@имя_входного_типа -> имя_выходного_типа тело``
    
    Например:
    
    ``transform << func x@float -> int {...}``
    
    Не понравилось: появляются одинаковы сигнатуры аргументов для разных выходных типов, что не соответствует данному ранее условию использования перегружаемых функций. Смотрится не очень логично и красиво. При выводе типов нужно учитывать имя функции в коде, а затем проверять, что на выходе.
    
    2) Другой вариант связан с непосредственной перегрузкой имени типа в качестве имени функции. Например:
    
    ``int << func x@float -> int {...}``
    
    В этой ситуации логика использования сохраняется. Однако подобная реализация допускает при написании использовать разные имена функции и типа возвращаемого значения. Теоретически это возможно, но концептуально выглядит не очень хорошо. Можно для типов ввести дополнительных контроль на этапе компиляции, но в целом все это выглядит не очень красиво. Дважды повторяется имя типа. 
    
    3) Поэтому выбран вариант с вводом специального оператора ``transform``, что позволяет избавиться от избыточности и акцентировать внимание не на сигнатуре, а на выходном параметре. Также видна логика преобразователя, как конструктора с аргументом на входе. Для внутреннего представления и формируемого экспорта сохранено описание преобразователя как прототипа функции, определяющего имя, аргумент и результат.

Использование типа int
""""""""""""""""""""""""""""""""""""""""""

Функция осуществляет преобразование аргумента к целочисленному типу. Эти преобразования возможны для действительных чисел, символов, булевских величин. Действительные числа преобразуются к целым путем отсечения дробной части независимо от знака числа.

Функция для экспорта имеет следующие сигнатуры::

    int << func bool -> int
    int << func float -> int
    int << func char -> int

Примеры::

    13.8:int  ⇒ 13
    -13.2:int  ⇒ -13
    -13.8:int  ⇒ -13
    '0':int ⇒ 48
    true:int ⇒ 1
    false:int ⇒ 0

Использование типа bool
""""""""""""""""""""""""""""""""""""""""""

Функция осуществляет преобразование аргумента к булевскому типу. Эти преобразования возможны для целых чисел. Если число равно нулю, то результатом является ``false``. В противном случае результат равен ``true``.

Функция имеет следующую сигнатуру::

    bool << func int -> bool

Примеры::

    1:bool  ⇒ true
    -10:bool  ⇒ true
    100:bool ⇒ true
    0:bool ⇒ false

Использование типа signal
""""""""""""""""""""""""""""""""""""""""""

Функция осуществляет преобразование аргумента любого типа к сигнальному значению. То есть идет потеря величины аргумента. 

Функция имеет следующую сигнатуру::

    signal << func any -> signal

Примеры::

    1:signal  ⇒ !
    !:signal  ⇒ !

Использование типа error
""""""""""""""""""""""""""""""""""""""""""

Функция осуществляет формирование общей ошибки и прерывание программы. Может применяться к любому аргументу.

Функция имеет следующую сигнатуру::

    error << func any -> ERROR

Примеры::

    1:error  ⇒ ERROR
    !:error  ⇒ ERROR

Использование в качестве функций имен составных типов
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Формируемые пользователем типы в основном базируются на составных типах, позволяющих конструировать разнообразные конфигурации данных, которым присваиваются соответствующие имена. Эти имена пользовательских типов также могут использоваться для задания пользовательских функций. Однако в ряде преобразований как уже сформированных пользовательских типов, так и программоформирующих операторов может осуществляться путем использования имен, определяющих составные типы. К этим именам относятся: vector, tuple, struct, swarm, queue, union.

Для поддержки строгой типизации в языке запрещены неявные преобразования. С одной стороны это ведет к дополнительным проблемам для программиста. Но с другой стороны повышается надежность кода за счет дополнительного контроля над типами. 

Использование типа vector
""""""""""""""""""""""""""""""""

Задает преобразование аргумента в вектор. Аргумент может быть базовым элементарным типом. В этом случае он становится одноэлементным вектором. Также эта функция может использоваться с роями, преобразуя их в вектор. Это позволяет синхронизировать поступающие данные перед последующей обработкой.
::

    атом:vector ⇒ (атом)
    [элемент, ... элемент]:vector ⇒ vector(элемент, ... элемент)

Функция также может применяться к потоку, который в этом случае преобразуется к вектору. Тем самым поэлементный вывод из потока трансформируется в формирование вектора, число элементов в котором определяется количеством элементов, порождаемых потоком (что не всегда хорошо).
::

    queue{}:vector ⇒ vector(элемент, ... элемент)

Данная функция имеет следующие сигнатуры::

    vector << func any -> any(*)
    vector << func any[*] -> any(*)
    vector << func any{*} -> any(*)

Помимо этого можно задавать ряд преобразований, если они возможны во время компиляции. В частности допускается преобразовывать структуру, состоящую из элементов одного типа в вектор. Аналогичное преобразование в вектор возможно и для кортежа, все элементы которого имеют один тип. Для этих преобразований имеются соответствующие функции::

    vector << func tuple([n]@any) -> any(*)
    vector << func struct([...]@any) -> any(*)

Через ``[n]@any`` обозначено наличие в кортеже n элементов одного любого типа. Обозначение ``[...]@any`` используется для указание на то, что все именованные элементы структуры имеют один тип.
Если аргумент не соответствует сигнатуре, то результатом является ошибка операции интерпретации **BASEFUNCERROR**. 

Использование типа tuple
""""""""""""""""""""""""""""""""

Задает преобразование аргумента в кортеж. Аргумент может быть базовым элементарным типом. В этом случае он становится одноэлементным кортежем. Также эта функция может использоваться с роями, преобразуя их в tuple. Это позволяет синхронизировать поступающие данные перед последующей обработкой.
::

    атом:tuple ⇒ tuple(атом)
    [элемент, ... элемент]:tuple ⇒ tuple(элемент, ... элемент)

Функция также может применяться к потоку, который в этом случае преобразуется к кортежу. Тем самым поэлементный вывод из потока трансформируется в формирование кортежа, число элементов в котором определяется количеством элементов, порождаемых потоком (что не всегда хорошо).
::

    queue{}:tuple ⇒ tuple(элемент, ... элемент)

Данная функция имеет следующие сигнатуры::

    tuple << func any -> tuple(any)
    tuple << func any(*) -> tuple([n]@any)
    tuple << func any[*] -> tuple([n]@any)

Другим аналогичным преобразованием является преобразование в кортеж структуры. В этом случае именованный доступ к полученному результату заменяется на позиционный. Порядок следования типов данных в кортеже совпадает с порядком их следования в исходной структуре. Преобразование описывается следующей прототипом::

    tuple << func struct(a1:t1, a2:t2, ...) -> tuple(t1, t2, ...)

Если аргумент не соответствует сигнатуре, то результатом является ошибка операции интерпретации **BASEFUNCERROR**. 

Использование типа swarm
""""""""""""""""""""""""""""

Задает преобразование к рою. Аргумент может быть базовым элементарным типом. В этом случае он становится одноэлементным роем. Также эта функция может использоваться с векторами, преобразуя их в рой. Это позволяет сделать поступающие данные асинхронными, так как компилятор подобные преобразования может учесть в момент анализа программы. То есть преобразование может осуществиться до окончательного вычисления вектора или вообще до начала его вычисления.
::

    атом:swarm ⇒ [атом]
    vector(элемент, ... элемент):swarm ⇒ [элемент, ... элемент]

Функция также может применяться к потоку, который в этом случае преобразуется к рою. Тем самым поэлементный вывод из потока трансформируется в формирование роя, число элементов в котором определяется количеством элементов, порождаемых потоком. Порядок элементов в рое совпадает с последовательностью их порождения потоком. Информация о каждом элементе поступает в оператор интерпретации асинхронно.
::

    queue{}:swarm ⇒ [элемент, ... элемент]

Данная функция имеет следующие сигнатуры::

    swarm << func any -> [any]
    swarm << func any(*) -> any[*]
    swarm << func any{*} -> any[*]

Если аргумент не соответствует сигнатуре, то результатом является ошибка операции интерпретации **BASEFUNCERROR**. 

Использование типа queue
""""""""""""""""""""""""""""""

Задает преобразование к потоку. Аргумент может быть базовым элементарным типом. В этом случае он становится потоком, порождающим один элемент. Также эта функция может использоваться с векторами, преобразуя их в поток. Это позволяет сделать данные последовательно асинхронными, поступающими в произвольном порядке, так как компилятор подобные преобразования может учесть в момент анализа программы. То есть преобразование может осуществиться до окончательного вычисления вектора или вообще до начала его вычисления.::

    атом:queue ⇒ queue{атом}
    vector(элемент, ... элемент):queue ⇒ queue{элемент, ... элемент}

Аналогично вектору функция также может применяться и к рою.

Данная функция имеет следующие сигнатуры::

    queue << func any -> any{*}
    queue << func any(*) -> any{*}
    queue << func any{*} -> any{*}

Если аргумент не соответствует сигнатуре, то результатом является ошибка операции интерпретации **BASEFUNCERROR**. 

Использование в качестве функций пользовательских типов
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Разработчик программного обеспечения может создавать свои описания типов на основе уже существующих предопределенные типов и ранее разработанных именованных пользовательских типов. Как и предопределенные типы, именованные пользовательские типы могут использоваться в качестве функций. Однако алгоритмы, выполняемые этими функциями, а также их сигнатуры определяются явно разработчиками ПО с использованием преобразователя ``transform``.

Такой подход говорит о том, что в принципе пользователь может связать с такой функцией какие угодно вычисления, тем самым обеспечивая гибкость в использовании имен типов в качестве функций. Поэтому невозможно заранее предугадать их поведение.

Использование в качестве функции обобщенного типа union
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Обобщенный глобальный тип ``union`` в качестве признака фиксирует имя включаемого в него типа. Функция с именем ``union``, формирует вокруг конкретного типа оболочку, включающую признак (тэг) и ссылку на охватываемый артефакт. В качестве охватываемого типа может использоваться любой именованный тип за исключением самого ``union``. Таким образом, преобразование типа заключается в его охвате, как и в случае с пользовательским обобщением.

Использование в качестве функции описывается следующим прототипом::

    union << func имя_типа -> union

Для выделения конкретного артефакта из глобального обобщения any необходимо проверить признак, после чего выделить значения используя имя полученного типа в качестве функции, осуществляя тем самым явное приведение вложенного артефакта к его типу. 

То есть, если тип вложенного артефакта совпадает с типом, используемым в качестве функции, то результатом является артефакт указанного типа. В противном случае генерируется ошибка **TYPEERROR** и происходит прерывание программы.

Проверка признака осуществляется функцией ``tag``, которая применима ко всем обобщениям.

.. note::

    Нужен пример

.. include:: DataEtcSemantic.rst


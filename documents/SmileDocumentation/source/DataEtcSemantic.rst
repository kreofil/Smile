.. |date| date:: %d.%m.%Y
.. |time| date:: %H:%M
.. |copy| unicode:: 0xA9 .. copyright sign

.. Текущая дата |date| и время |time|

.. meta::
   :description: Описание концепций, языковых и инструментальных средств функционально-потокового параллельного программирования.
   :keywords: парадигмы программирования, функционально-потоковое параллельное программирование

:Author:    Александр Легалов
:Email:     <legalov@mail.ru>
:Date:      |date|
:Version:   0.1

:Copyright: |copy| Допускается свободное использование с обязательной ссылкой на сайт автора: "Оригинальная версия размещена на сайте www.softcraft.ru".

.. .. sectnum::
    :start: 1

.. .. contents:: Содержание
    :depth: 3


≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡
Семантика хранилищ и программоформирующих операторов
≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡

Наряду с тем, что различные типы данных используются в качестве аргументов в операторе интерпретации, они также имеют определенную структуру, которая определяет специфику представления этих данных в хранилищах. Аналогичной спецификой обладают и программоформирующие операторы. Как и все другие артефакты данные конструкции могут использваться в операторе интерпретации на месте аргумента-данных и в качестве аргумента-фукнции.

Семантика хранилищ
----------------------------------------------------

Особенностью хрнаилищ является то, что к ним применяется ограниченный набор функций. Этот набор ограничен чтением из хранилищ и записью в них (с соблюдением принципа единственного присваивания). Но даже описание операций чтения-записи требует определенного синтаксического сахара для их более удобного и понятного представления в языке (*последнее со стороны может выглядеть сомнительно*).

Хранилища атомарных данных
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Чтение атомарных данных задается обращением к хранилищам как к аргументам по имени хранилища. То есть, здесь никаких вопросов не возникает. Обращение обычно эквивалентно к использованию переменных в традиционных языках программирования.

Пример::

    // чтение из хранилищ a, b и сложение
    (a, b):+

Запись в атомарное хранилище также осуществляется по аналогии с записью в обычные переменные. Однако особенностью в данном случае является то, что хранилище используется в качестве функции в операторе интерпретации, который принимает поступающие данные и записывает их в хранилище::

    // запись данных в целочисленное хранилище a
    a@int
    10:a

Следует отметить, что тип записываемых данных должен совпадать с типом хранилища.

Общие особенности хранилищ составного типа
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Независимо от типа составного хранилища, чтение и запись в них осуществляется одинаково в случае, когда каждое из таких хранилищ построено на основе именованного типа. В этом случае описание хранилища практически не отличается от описания хранилищ атомарных типов. Чтение осуществляется обращением целиком ко всем данным, а селективна выборка при этом может определяться соответствием между типом хранилища и функцией, задаваемой в операторе интерпретации. При этом допускается неявное приведение типов данных в соответствии со сформированной сигнатурой функции

Простейший вариант чтения заключается во взаимодействии одноименных по типу хранилищ, когда данные из одного копируются в другое::

    intPair << type (int, int)
    a:intPair
    b:intPair
    (3,4):a     // неявное использование типа tuple (int, int)
    a:b         // запись из a в b где b рассматривается как функция
                // с сигнатурой: b << func x@Pair -> signal

Вместе с тем следует отметить, что специфические особенности организации каждого хранилища ведут к ряду особенностей, связанных с обращением к ним.

Особенности хранилищ векторного типа
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Наряду с непосредственным копированием данных между векторами одинакового типа и размера возможны различные варианты организации чтения из вектора элемента по индексу. Первый вариант связан с использованием целочисленных величин в качестве индексов. Он позволяет прочитать элемент в качестве разультата::

    (1, 2, 3, 4, 5): 3 ⇒ 3
    (1, 2, 3, 4, 5): i ⇒ результат - i-й элемент вектора

.. note::

    Нужно убрать из семантики отрицательные числа, так как имеется противоречие по типу результата

Другой вариант связан с представлением операции обращения к вектору с использованием специального его обозначения:

**ЭлементВектора = ИмяВектора "(" Индекс ")".**

Данный вариант полностью эквивалентен предыдущему, но может использоваться только в случае, когда вектор имеет имя::

    A << (1, 2, 3, 4, 5)
    A(3) ⇒ 3
    B << (1, 2, 3, 4, 5)
    B(i) ⇒ результат - i-й элемент вектора

В качестве индекса допускается как целочисленная константа, так и целочисленное значение, полученное в ходе вычислений. Следует отметить, что в первом случае выход за границы вектора определяется компилятором.

Запись в вектор возможна только в том случае, если он предварительно объявлен как незаполненное хранилище. При этом конструкция, определяющая элемент вектора используется как функция в операторе интерпретации::

    A@int(5)
    7:A(i)
    10:A(1)

При попытке повторно записать в уже заполненный элемент, запрещенное принципом единственного присваивания, происходит прерывание программы

Особенности хранилищ имеющих тип кортеж
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Чтение-запись с использованием кортежей во многом напоминает аналогичные операции с векторами. Однако имеются и свои особенности. Спецификой кортежей является наличие в них элементов разных типов. Поэтому основной вид доступа связан с использованием в качестве индекса целочисленной константы. В этом случае компилятор может точно определить тип результата::

    (1, 2, 3, 4, 5): 3 ⇒ 3
    (3, true, !): 2 ⇒ true

Ошибка компиляции происходит в том случае, если в качестве индекса выступает величина вычисляемая во время выполнения программы. Однако имеется исключение. Если все элементы кортежа имеют один и тот же тип, компилятор может допустить использование вычисляемой величины, так как тип результата становится известным::

    (1, 2, 3, 4, 5): i ⇒ результат - i-й элемент кортежа однотипных элементов
    (3, true, !): j ⇒ ошибка компиляции 

Для организации чтения может использоваться целое число как функция оператора интерпретации или обозначение элемента кортежа, аналогичное по синтаксису элементу вектора:

**ЭлементКортежа = ИмяКортежа "(" Индекс ")".**

Запись в кортеж-хранилище осуществляет по тем же правилам, что и чтение. В общем случае она происходит, если индекс задается константой, позволяющий сопоставить типы записываемых данных и поля кортежа. Вычисляемая величина допускается в качестве индекса, если все поля кортежа однотипны.
::

    X@(int, bool, signal)
    false:X(2)
    10:A(1)

Особенности структурных хранилищ
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

По разнотипности элементов структуры аналогичны кортежам. Однако для доступа к полям их используются внутренние имена этих полей, с каждым из которых сопоставлен тип. Поэтому чтение-запись реализованы только с использованием этих полей без каких либо вычислений. Обычный доступ осуществляется через имя хранилища, после которого через точку следует имя поля:

**ЭлементСтруктуры = ИмяХранилища "." ИмяПоля.**

Однако возможны ситуации, когда результат структурного типа формируется в ходе вычислений. В этом случае имя поля, предваряемого точкой, может быть указано в качестве функции в операторе интерпретации::

    S@(x@int, b@bool)
    // Здесь какие-то вычисления порождающие структуру в качестве результата
    ...:.b  // На выходе будет значение поля b
    S.a ⇒ порождает значение поля a структуры S
    
Запись в структуру-хранилище осуществляется с явным использованием элемента структуры в качестве функции оператора интерпретации::

    S@(i@int, b@bool, s@signal)
    false:S.b
    10:S.i

Особенности хранилищ роевого типа
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Спецификой роя является асинхронное поступление данных и, как следствие отдельная сигнализация о поступлении каждого элемента в связанный с ним оператор интерпретации. Вместе с тем обращение к рою по индексу практически аналогично обращению к вектору. При отсутствии элемента происходит ожидание его появления. Поэтому возможны те же варианты::

    [1, 2, 3, 4, 5]: 3 ⇒ 3
    [1, 2, 3, 4, 5]: i ⇒ результат - i-й элемент вектора

.. note::

    Нужно убрать из семантики отрицательные числа, так как имеется противоречие по типу результата

Другой вариант связан с представлением операции обращения к рою с использованием специального его обозначения:

**ЭлементРоя = ИмяРоя "[" Индекс "]".**

Данный вариант полностью эквивалентен предыдущему, но может использоваться только в случае, когда Рой имеет имя::

    R << [1, 2, 3, 4, 5]
    A[3] ⇒ 3
    Q << [1, 2, 3, 4, 5]
    Q[i] ⇒ результат - i-й элемент роя

В качестве индекса допускается как целочисленная константа, так и целочисленное значение, полученное в ходе вычислений. Следует отметить, что в первом случае выход за границы роя определяется компилятором.

Запись в рой возможна только в том случае, если он предварительно объявлен как незаполненное хранилище. При этом конструкция, определяющая элемент роя используется как функция в операторе интерпретации::

    R@int[5]
    7:R[i]
    10:R[1]

При попытке повторно записать в уже заполненный элемент, запрещенное принципом единственного присваивания, происходит прерывание программы

Реагирование и доступ по мере поступления элементов в рой
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Если рой является аргументом, то оператор интерпретации реагирует на появление каждого элемента. В этом случае можно использовать функции, которые также срабатывают на каждый элемент и обрабатывают рой по мере поступления отдельных данных, не дожидаясь полной синхронизации, как это происходит в случае вектора, кортежа или структуры.

Для реализации дополнительных возможностей предполагается использовать ссылки, каждая из которых имеет дополнительные независимые механизмы по контролю за данными поступающими в рой.

.. note::

    *Данный фрагмент нужно еще обдумать и дописать*

Особенности хранилищ - потоков
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Основной спецификой потоков является отсутствие информации о количестве поступающих данных. В результате завершение потока определяется по достижению "маркера дна". То есть, признака, указывающего на то, что данные в потоке отсутствуют и больше не появятся. В связи с этим возникает определенная специфика в формировании семантики этого артефакта.

В целом поведение потока во многом аналогично поведению асинхронного списка, реализованного в языке программирования Пифагор. Однако ряд специфических моментов требуют других решений при манипуляции с ним. 

Первая особенность заключается в том, что при чтении данных может возвратиться или значение, или признак завершения данных. При использовании статической типизации это два разных вида информации, поэтому необходимо разделение возвращаемых данных, которое можно сделать реализовав две функции:

    * функцию проверку на наличие в потоке данных (``is``), которая возвращает ``true``, если данные еще поступают, и ``false`` если данные в поток поступать перестали;
    * функцию получения элемента из потока (``get``), которая при наличии в нем данных выбирает первый элемент, тип которого определяется из описания потока, а отсутствие данных ведет к прерыванию программы.

Помимо этого необходимо вытолкнуть из потока прочитанный элемент, чтобы иметь доступ к следующему. Для этого можно использовать функцию ``pop``.

Вместе с тем использование нескольких функций может привести к коллизиям, если к потоку идет одновременное обращение из нескольких точек программы. Для предотвращения коллизий необходимо использовать атомарные функции, выполняющие все необходимые действия за один раз таким образом, чтобы при каждом обращении происходила корректная обработка данных. Можно например, совместить проверку с чтением элемента, возвращая пару значений: (данные, признак наличия данных). Если признак наличия данных будет равен ``true``, то прочитаны корректные данные. Их можно обрабатывать. В противном случае данные неактуальны, так как поток завершил их порождение. Однако в этом случае коллизии могут все равно возникать и быть связаны с выталкиванием данных.

Более надежным смотрится вариант, когда в одной атомарной функции совмещаются все три, описанные выше. То есть, когда при наличии данных происходит их выдача в виде двойки и выталкивание элемента из потока. Тогда каждая из операций чтения будет брать только свои уникальные данные и убирать их из потока. При обращении множества операций к пустому потоку все они получат значение признака наличия данных, равное ``false``. При этом прерывания программы не происходит. Предполагается, что в качестве такой неделимой операции будет использоваться применением потока в качестве данных оператора интерпретации. Например::

    S@int{}
    (S:!, S:!):+

В примере демонстрируется двойное обращение к потоку, после чего полученные числа складываются. В данной ситуации порядок выдачи данных из потока недетерминирован. То есть неясно, в какой аргумент функции сложения попадет из потока первый элемент данных. Для реализации детерминированности необходимо формировать дополнительные сигналы обеспечивающие требуемую последовательность::

    S@int{}
    x1 << S:!
    (x1, S:{x1:signal}):+

.. note::

    Расширить возможности манипуляций с потоком, поддерживающими многократное дублирование доступа, можно через ссылки. Но это отдельная тема для анализа и реализации. Пока нет.

Запись в поток осуществляет за счет использования имени потока в качестве функции::

    S@int{}
    5:S

Можно также осуществлять непосредственную передачу данных из одного потока в другой, которая может сочетаться с передачей независимых данных. Порядок передачи при этом также может быть недетерминированнм::

    S1@int{}
    S2@int{}
    S1:S2
    5:S2
    10:S1


Семантика программоформирующих операторов
-----------------------------------------------

Программоформирующие операторы обеспечивают группировку данных, используя предопределенные методы. Они также могутиспользоваться в качестве данных и функций в операторе интерпретации. Основное отличие от составных типов заключается в отсутствии предварительного описания. Поэтому текущее значение формируется во время вычислений. Однако использование статической типизации позволяет вывести тип во время компиляции и использовать полученный результат для контроля взаимодействия различных артефактов.

Оператор группировки в кортеж
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Используется для объединения как однотипных, так и неоднотипных данных. Если группируются данные одного типа, то результат группировки может обрабатываться как аргумент функции, манипулирующей векторами. Основная задача данного оператора заключается в синхронизации поступающих данных перед последующим использованием. То есть, готовность к выполнению оператора интерпретации, в котором кортеж используется в качестве одного из аргументов сформируется тогда, когда будут вычислены все элементы кортежа. Кортеж может являться аргументом-данными как в предопределенных функциях, так и в функциях разрабатываемых пользователем. В этом случае особенности его выполнения связаны с особенностями  семантики аргумента-функции оператора интерпретации.

С другой стороны кортеж может использоваться в качестве аргумента функции одиночного оператора интерпретации. В этой ситуации каждый элемент внутри кортежа определяется как отдельная функция, которая осуществляет обработку одного и того же аргумента-данных. Результатом выполнения является кортеж, в котором собраны все вычисленные величины. Можно привести эквивалентное преобразование, определяющее одну из формул алгебры преобразования языка программирования::

    data:(f1, f2, f3, ... fn) ≡ (data:f1, data:f2, data:f3, ... data:fn)

Пример::

    (10, 3):(+, -, *, /, %) ⇒ (13, 7, 30, 3, 1)

.. note::

    *Возможно, что такое поведение может вступать в противоречие с ранее описанной семантикой для объявлений векторов и кортежей. Когда их расположение в качестве функции ведет к записи элемента. Может там придется ввести специальные функции записи? Или пересмотреть поведение здесь? Может каким-то образом это повлияет на оператор массовый интерпретации? Хотя, при записи используется другое обозначение кортежа (роя, структуры). Поэтому в принципе все м.б. ОК.*

Оператор группировки в рой
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Используется для асинхронной группировки, когда появление каждого элемента сопровождается передачей информации оператору интерпретации. Использование роя в качестве аргумента-данных зависит от того, какая функция над ним выполняется. Когда рой является аргументом-функцией оператора интерпретации, то его поведение во многом аналогично использованию в качестве функции кортежа. Вместе с тем, если функции вычисляются, то есть, формируются в разныем моменты времени, то обработка данных осуществляется асинхронно, также независимо на выходе появляются результаты вычислений, которые группируются в соответствующем рое. Следующая формула описывает эквивалетное преобразование роя::

    data:[f1, f2, f3, ... fn] ≡ [data:f1, data:f2, data:f3, ... data:fn]

Пример::

    (10, 3):[+, -, *, /, %] ⇒ [13, 7, 30, 3, 1]

Следует отметит, что все элементы роя, выступающие в роли функций, по определению должны иметь одинаковую сигнатуру и порождать на выходе однотипные результаты в отличие от результатов, которые могут порождать функции, сгруппированные в кортеж.

Оператор группировки в поток
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Данный оператор используется для формирования асинхронно порождаемых последовательностей. Как и другие операторы группировки он позволяет объединить несколько элементов окончательно формируемые значения которых должны быть одного типа. Спецификой данного оператора является отсутствие фиксированной длины, что позволяет использовать в качестве элементов другие операторы группировки в поток, порождающие данные того же типа, что и тип оператора группировки. Использование в качестве аргумента-данных, как и в предыдущих операторах, предполагает, что семантика определяется аргументом-функцией, обрабатывающей данный поток. Семантика при использовании оператора в качестве аргумента-функции определяется теми элементами, которые поступают в поток и применяются в порядке поступления к каждому аргументу. Следует отметить, что в связи с асинхронностью и разным временем обработки аргумента-данных расположение результатов в выходном потоке может отличаться от порядка функций в исходном потоке. Обработка данных потоком функций может быть представлена следующим образом::

    data:stream{f1, f2, f3, ... fn} ≡ stream{data:f1, data:f2, data:f3, ... data:fn}

Пример выполнения, демонстрирующий один из вариантов возможной недетерминированной перестановки результатов на выходе, что определяется спецификой обработки::

    (10, 3):stream{+, -, *, /, %} ⇒ stream{7, 13, 1, 3, 30}

Оператор задержки
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Основное назначение данного оператора заключается в задержке вычислений описанного в нем выражения независимо от того будет результат использоваться в качестве данных или функции. Оператор интерпретации раскрывает задержку, что ведет к ранее отложенному вычислению результата, тип которого определяется в зависимости от написанного выражения. Дальнейшая обработка полученной величины оператором интерпретации зависит от этого типа. Каких-либо дополнительных особенностей семантики оператора задержки нет.

.. note::

    Следует отметить, что в принципе возможны и другие эквивалентные способы группировки и выполнения вычислений, аналогичные описанным. Они возникают из-за возможности предварительного описания величин с последующей записью в них данных с применением принципа единственного присваивания. Также свой вклад может внести использование массового оператора интерпретации. Все эти варианты предполагается рассмотреть и сравнить в разделе примеров, описывающих технику программирования. Также обобщение вариантов предполагается сделать в разделе по алгебре эквивалентных преобразований.

Использование функций с массовым оператором интерпретации
---------------------------------------------------------------------

Применение массового оператора интерпретации в первую очередь ориентирована о использование одной функции для обработки множества данных (эквивалентно стратегии ОКМД в классификации Флинна). Предполагается что данные одного типа размещаются в контейнере (вектор, рой, поток) и к ним применяется одна и та же функция, формируя на выходе контейнер результатов такого же типа. Подобные преобразования можно описать следующими выражениями::

    (d1, d2, ... dn)::f ≡ (d1:f, d2:f, ... dn:f)
    [d1, d2, ... dn]::f ≡ [d1:f, d2:f, ... dn:f]
    stream{d1, d2, ... dn}::f ≡ stream{d1:f, d2:f, ... dn:f}

Следует отметить, что в случае потока результаты на выходе могут не соответствовать порядку, определяемому исходными данными, так как возможны недетерминированные перестановки, связанные с разным временем выполнения функций.

Помимо этого возможна ситуация, когда один элемент данных обрабатывается нескольким функциями::

    d::(f1, f2, ... fk) ≡ (d:f1, d:f2, ... d:fk)
    d::[f1, f2, ... fk] ≡ [d:f1, d:f2, ... d:fk]
    d::stream{f1, f2, ... fk} ≡ stream{d:f1, d:f2, ... d:fk}

То есть, данная ситуация эквивалентна случаю, связанному с использованием программоформирующих операторов в качестве функций.

.. note::
    Возможно это тот повод, который позволит отменить использование при одиночной интерпретации программоформирующие операторы в качестве функций. Зачем дублировать? Может тогда и другие проблемы и вопросы будут сняты. Надо думать...

Другим фактором, определяющим специфику массового оператора интерпретации является то, что аргумент-функция может также задаваться с использованием программоформирующих операторов. Поэтому в ряде случаев возможно появление множества функций, обрабатывающих множество потоков. При этом контейнерные типы данных могут отличаться от контейнерных типов функций. То есть возможны следующие комбинации::

    (d1, d2, ... dn)::(f1, f2, ... fk) ≡ 
        (d1:(f1, f2, ... fk), d2:(f1, f2, ... fk), ... dn:(f1, f2, ... fk)) ≡
            ((d1:f1, d1:f2, ... d1:fk), (d2:f1, d2:f2, ... d2:fk) ... (dn:f1, dn:f2, ... dn:fk))

    [d1, d2, ... dn]::(f1, f2, ... fk) ≡ 
        [d1:(f1, f2, ... fk), d2:(f1, f2, ... fk), ... dn:(f1, f2, ... fk)] ≡
            [(d1:f1, d1:f2, ... d1:fk), (d2:f1, d2:f2, ... d2:fk) ... (dn:f1, dn:f2, ... dn:fk)]

    (d1, d2, ... dn)::[f1, f2, ... fk] ≡ 
        (d1:[f1, f2, ... fk], d2:[f1, f2, ... fk], ... dn:[f1, f2, ... fk]) ≡
            ([d1:f1, d1:f2, ... d1:fk], [d2:f1, d2:f2, ... d2:fk] ... [dn:f1, dn:f2, ... dn:fk])

    [d1, d2, ... dn]::[f1, f2, ... fk] ≡ 
        [d1:[f1, f2, ... fk], d2:[f1, f2, ... fk], ... dn:[f1, f2, ... fk]] ≡
            [[d1:f1, d1:f2, ... d1:fk], [d2:f1, d2:f2, ... d2:fk] ... [dn:f1, dn:f2, ... dn:fk]]

    и далее все комбинации, включая потоки.

То есть, в этом случае в начале контейнерная функция применяется к каждому из элементов данных, после чего идет дальнейшее разложение. Как и в более простых ситуациях комбинации с потоками ведут к недетерминированным вычислениям и смене порядка следования результатов относительно порядка в исходых данных.


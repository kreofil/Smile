.. |date| date:: %d.%m.%Y
.. |time| date:: %H:%M
.. |copy| unicode:: 0xA9 .. copyright sign

.. Текущая дата |date| и время |time|

.. meta::
   :description: Описание концепций, языковых и инструментальных средств функционально-потокового параллельного программирования.
   :keywords: парадигмы программирования, функционально-потоковое параллельное программирование

:Author:    Александр Легалов
:Email:     <legalov@mail.ru>
:Date:      |date|
:Version:   0.0

:Copyright: |copy| Допускается свободное использование с обязательной ссылкой на сайт автора: "Оригинальная версия размещена на сайте www.softcraft.ru".

.. .. sectnum::
    :start: 1

.. .. contents:: Содержание
    :depth: 4


=============================================
Организация семантической модели Smile
=============================================

В данном драфте представлены основные соображения по семантической модели языка программирования Smile. Как и все другое, данное описание будет уточняться по мере появления новых идей и их воплощении в реализации.

Архитектура семантической модели
-----------------------------------


Организация таблицы экспорта
-------------------------------

Назначение таблицы экспорта
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В таблице экспорта хранятся все описания (декларации), полученные в результате компиляции артефактов, размещенных в текущем репозитории. Она используется в качестве внутреннего списка описаний, предоставляемого компилятору для определения ранее объявленных имен, которые могут быть встречены им при компиляции текущего артефакта. Помимо этого в первоначальной версии, пока не будет оговорена система защиты (локализации) создаваемых артефактов, эта же таблица экспорта будет использована для передачи описаний в другие репозитории, импортирующие из данного репозитория. Впоследствии предполагается, что в ней будут храниться только описания артефактов, разрешенных к экспорту, а все артефакты, предназначенные только для внутреннего персонального и группового использования, будут размещены в отдельных таблицах. Скорее всего эти таблицы не будут дублировать описания, а при использовании владельцем будут совместно загружаться с проверкой на непротиворечивость. Пр организации доступа к репозиторию членов группы предполагается загрузка таблицы описаний для группы и таблицы внешнего экспорта.

Содержание таблицы экспорта
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

На текущий момент предполагается, что таблица экспорта будет содержать следующие описания.

#. **Описания констант**. Описания констант формируется на основе компиляции констатных выражений и содержат вычисленные константные значения в соответствии с заданными синтаксическими правилами. Дальнейшее вычисление констант невозможно. Поэтому они экспортируются в использующие их артефакты как есть.
#. **Прототипы функций**. Прототипы функций формируются либо на основе компиляции определения функций, либо за счет компиляции предварительных объявлени (то есть, начальных определений прототипов). Они предназначены для передачи компилируемым артефактам необходимой информации о сигнатурах уже откомпилированных или предварительно определенных функций. Следует отметить, что предварительное объявление впоследствии может быть переписано на ее определение, так как имена этих определений одинаковы, а в дальнейшем для выполнение нужно реальное определение функции. При этом в ходе компиляции переписывается и прототип на такое же значение, так как сигнатура не меняется. Возможно, правда, изменение типа результата.
#. **Описания типов**. Описания типов формируются в ходе компиляции определений типов и содержат информацию, необходимую для использования типов в других определениях артефактов. В большинстве случаев, например, для статически определенных типов, эта информация совпадает с той, что имеется в определениях. Для динамически определяемых типов процедура их обработки в описании не указывается, так как она используется во время вычислений как обычная функция.
#. **Описание импорта**. Задает ссылку на таблицы экспорта, импортируемые из других репозиториев. В описании эта ссылка фиксируется в самом имени, а в отдельном подкаталоге (в текущем исполнении) под этим именем хранится импортируемая таблица. Данное описание формируется из определения импорта, в котором задается имя и адрес репозитория, из которого осуществляется импорт. Адрес указывается в виде URL. Для репозиториев в текущей файловой системе возможно сокращенное указания этого адреса в виде абсолютного или относительного имени соответствующего файла экспорта.
#. **Описание трансформеров**. Пока не описываю. Вставил чтобы не забыть про них в дальнейшем.

Форматы описаний, хранимых в таблице экспорта
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Каждое описание в таблице экспорта хранится в отдельной строке. Формат описания зависит от его назначения и описывается соответствующими синтаксическими правилами. Синтаксис описаний предполагается уточнять в ходе разработок. В настоящий момент используется специализированный формат экспортируемых описаний.

.. note::
    *В ходе предварительных размышлений обдумывалось использование стандартных форматов тип XML или json. Однако для такого уровня описаний получались нагромаждения, которые даже с использованием стандартных средств обрабатывать было бы трудозатратно. Поэтому на текущий момент кажется более простым сделать свой элементарный распознаватель.*

Синтаксическое описание таблицы экспорта выглядит следующим образом::

    ТаблицаЭкспорта = { Описание }.
    Описание = ОписаниеКонстанты
             | ОписаниеПрототипа
             | ОписаниеТипа
             | ОписаниеИмпорта
             | ОписаниеТрансформера.

Описание каждого типа состоит из отдельных лексем, разделяемых пробелами. В конце описания ставится перенос строки. Описание формируются автоматически в ходе компиляции артефактов. Для тестирования или предварительного заполнения можно создавать описания вручную, но при этом важно соблюдать формат, так как описание в свободном формате отсутствует.

Описание константы
``````````````````````

Описание константы задается следующим синтаксическим правилом::

    ОписаниеКонстанты = const Имя ЗначениеКонстанты.
    ЗначениеКонстанты = ТипКонстанты Величина.
    ТипКонстанты = БазовыйТип | СоставнойТип.
    БазовыйТип = int | real | bool | signal | spec | type | error.
    СоставнойТип = datalist | parlist | string.

Имя константы должно быть уникальным, то есть, встречаться в репозитории (а следовательно и в таблице экспорта) только один раз. Это объясняется тем, что других параметров кроме имени для идентификации константы не существует::

    Имя = Идентификатор {"." Идентификатор}.

Величина константы определяется в зависимости от его типа:

- для целочисленной константы это целое число с необязательным знаком + или -;
- для действительной константы это число с фиксированной и (или) плавающей точкой перед которым также возможен знак;
- булевская константа задается цифрой 0 или 1 (зачем мудрить?);
- сигнал может не иметь значения, так как оно одно;
- спец. тип задается соответствующим допустимым знаком;
- тип определяется значением базового типа (может и не стоит, нужно подумать);
- ошибка определяется значением ошибки (может и не стоит, нужно подумать).

Величины, задаваемые для структурных типов имеют свои особенности. Простейшим видом является строка символов, которая задается своим значением, то есть, в нее входят все символы, идущие после пробела, отделяющего имя от значения строки до символа конца строки (получается, что в строку не входят переносы строки). Может вообще строки запретить? Или использовать трансформацию в строки, задаваемые в кавычках как в языке? Нужно подумать...

Величина для списка данных и параллельного списка определяется следующим правилом::

    ВеличинаСписка = ДлинаСписка {ЗначениеКонстанты}.

То есть, количество значений определяется длиной списки. Любое из значений тоже может быть списком, что позволяет определять списки, вложенные друг в друга.

*На этом пока описание заканчиваю. Необходимо реализовать таблицу для основных констант.*

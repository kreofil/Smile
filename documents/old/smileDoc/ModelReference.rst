.. |date| date:: %d.%m.%Y
.. |time| date:: %H:%M
.. |copy| unicode:: 0xA9 .. copyright sign

.. Текущая дата |date| и время |time|

.. meta::
   :description: Описание концепций, языковых и инструментальных средств функционально-потокового параллельного программирования.
   :keywords: парадигмы программирования, функционально-потоковое параллельное программирование

:Author:    Александр Легалов
:Email:     <legalov@mail.ru>
:Date:      |date|
:Version:   0.1

:Copyright: |copy| Допускается свободное использование с обязательной ссылкой на сайт автора: "Оригинальная версия размещена на сайте www.softcraft.ru".

.. sectnum::
    :start: 1

.. contents:: Содержание
    :depth: 3

==========================================================
Функционально-потоковая модель параллельных вычислений
==========================================================

Функционально-потоковая модель параллельных вычислений (ФПМПВ), определяющая динамические свойства языка функционально-потокового параллельного программирования ЯФППП, имеет
следующие основные характеристики (предполагается любой язык, не только Пифагор):

- вычисления протекают внутри неограниченных ресурсов, что позволяет неявно описывать параллелизм без ресурсных конфликтов;
- управление вычислениями осуществляется по готовности данных;
- выбор операций и аксиом, определяющих базовый набор функций, ориентирован на наглядное текстовое представление информационного графа программы при его описании на языке программирования;
- модель вычислений определяет общую структуру функционально-потоковой параллельной программы без привязки к операционной семантике, которая может определяться дополнительно, определяя тем самым специфику конкретного языка (подъязыка) программирования.

Первое требование обеспечивает ресурсную независимость предлагаемой модели, что
позволяет описать параллелизм, ограниченный только информационными
связями, присущими данной задаче. Это сводит перенос написанной программы на любую
вычислительную систему к распределению ресурсов в соответствии с архитектурой.
Подобный подход используется также в ряде известных схем потока данных (СПД)
[Алгоритмы], ориентированных на рекурсивное описание программ, обрабатывающих
только один входной поток данных и не поддерживающих их конвейерное продвижение. В
связи с отсутствием циклических конструкций граф данной модели является ациклическим.

Использование текстового описания для представления параллельных программ связано с трудностями описания информационного графа, что привело к синтаксису языка, несколько отличающемуся от
общепринятого. Кроме того, в языке отсутствуют вентили, обеспечивающие условную
передачу данных в традиционных СПД [Денис, Arvind]. Эти вентили трудно
структурировать при текстовом описании программ без использования дополнительной
синхронизации информационных потоков.

Общие принципы организации модели
--------------------------------------

Модель задается тройкой:

    M = ( G, P, S\ :sub:`0` ),

где G - ациклический ориентированный граф, определяющий информационную
структуру программы (ее информационный граф), P - набор правил, определяющих
динамику функционирования модели (механизм формирования разметки), S\ :sub:`0` - начальная
разметка.

Информационный граф

    G = ( V, A ),

где V - множество вершин определяющих программо-формирующие операторы, а A - множество дуг, задающих пути передачи информации между ними.

Вершины графа, соответствующие программо-формирующим операторам, обеспечивают информационные преобразования данных, их структуризацию и размножение. Существуют следующие типы операторов:

- оператор интерпретации;
- константный оператор;
- оператор копирования данных;
- оператор группировки в список;
- оператор группировки в параллельный список;
- оператор группировки в список задержанных вычислений.

Операторы используются для построения информационного графа, определяющего
функцию (процедуру), являющуюся независимым программным модулем. Этот граф имеет
множество входных информационных дуг A\ :sub:`0`, на которые поступают аргументы, задающие
исходные данные, необходимые для организации вычислений. Поступление этих аргументов
фиксируется в начальной разметке графа. Существует также один выход, определяющий
результат. Граф с несколькими входными дугами и одной выходной дугой назовем
допустимым графом. Вычисления заканчиваются, когда все дуги допустимого графа,
включая и выходную дугу, окажутся размеченными.

Динамика выполнения операторов задается механизмом продвижения начальной
разметки графа по дугам модели. Разметка дуги задается вектором:

M\ :sub:`i` = (N, R),

где N - кратность дуги, определяющая количество независимых наборов данных,
полученных в результате выполнения оператора, выход которого соединен с этой дугой; R - вектор данных (r\ :sub:`1`, r\ :sub:`2`, ... r\ :sub:`N`), полученный в ходе вычислений.

Наличие разметок на всех дугах некоторой вершины графа позволяет запустить ее и получить выходную разметку. Разметку кратности большей, чем единица назовем параллельной. Набор независимых данных, соответствующий такой разметке, будем называть параллельным списком. При разметке кратности 1 имеем частный случай параллельного списка, вырожденного до одноэлементного параллельного списка или просто элемента.

Следует отметить, что поддержка разметкой дуги нескольких независимых наборов
данных позволяет описывать на уровне ФПМПВ массовый параллелизм. При этом
инициализация вычислений в вершине может начинаться до формирования полной разметки,
так как обработка каждого из входных наборов осуществляется независимо.

Например, если вершина V\ :sub:`i` получает данные с дуги A\ :sub:`j` с кратностью разметки N, то для формирования неполной разметки на выходной дуге A\ :sub:`k` достаточно появления хотя бы
одного набора данных r\ :sub:`m`. Дальнейшее формирование разметки на входной дуге позволяет
пополнять разметку на выходе. Данный механизм поддерживается аксиомами языка.
Необходимым условием является наличие полных разметок только при окончании
вычислений функции. Назовем разметку дуги, не сформированную до конца, неполной.

Отметим также, что произвольное поступление элементов вектора значений R на
обработку не приводит к неоднозначности, так как каждый элемент идентифицирован
уникальным порядковым номером от 1 до N.

Описание программо-формирующих операторов
------------------------------------------

Для графического представления операторов используются специальные обозначения,
приведенные на рис. 1.1 - 1.6. Наряду с графическими обозначениями применяется и текстовое описание элементов модели, аналогичное принятому в разработанном языке программирования.

**Оператор интерпретации** описывает функциональные преобразования аргумента. Он
имеет два входа, на которые, через информационные дуги, поступают функция F и аргумент
X (рис. 1.1).

.. figure:: img/f1_1.png
       :scale: 300 %
       :align: center
       :alt: Оператор интерпретации

       Рис. 1.1. Оператор интерпретации 
       с входами аргумента **X** и функцией **F**.

Аргумент и функция могут являться результатами предшествующих вычислений.
Оператор интерпретации запускается по готовности данных, что фиксируется появлением
разметки на входных дугах. Получение результата задается разметкой выходной дуги. При
текстовом описании оператор интерпретации имеет две формы: постфиксную, обозначаемую
знаком **":"**, и префиксную, при которой функция отделяется от аргумента знаком **"^"**.
Наличие двух способов записи одного оператора позволяет в дальнейшем комбинировать их
с целью получения более наглядного текста программы. Следовательно, выражение **F(X)**
оператор интерпретации позволяет задать одной из форм::

    X:F или F^X .

**Константный оператор** не имеет входов (рис. 1.2). У него есть только один выход, на
котором постоянно находится разметка, определяющая предписанное значение. Множество
константных операторов информационного графа определяют внутреннюю начальную
разметку МВ. В языковом представлении константный программо-формирующий оператор
задается значением соответствующего типа.

.. figure:: img/f1_2.png
       :scale: 300 %
       :align: center
       :alt: Константный оператор

       Рис. 1.2. Константный оператор

**Оператор копирования** (рис. 1.3) осуществляет передачу данных с одного своего
входа на множество выходов. В графическом представлении данная передача фиксируется
установкой разметки на дугах, связанных с выходами вершины при размеченной входной
дуге. В текстовой форме операция копирования определяется через именование
передаваемое величины и дальнейшее использование введенного обозначения в требуемых
точках в качестве одной и той же связи.

.. figure:: img/f1_3.png
       :scale: 300 %
       :align: center
       :alt: Оператор копирования данных

       Рис. 1.3. Оператор копирования данных

Используется постфиксное именование размножаемого объекта в форме::

    величина >> имя ,

и его префиксный эквивалент, имеющий вид::

    имя << величина .

Например::

    y << F^x; (x,y):+ >> c;

**Оператор группировки в список данных** (рис. 1.4) имеет несколько входов и один выход. Он
обеспечивает структуризацию и упорядочение данных, поступающих по дугам из различных
источников. Порядок элементов определяется номерами входов, каждому из которых
соответствует натуральное число в диапазоне от 1 до N. В текстовом виде оператор задается
ограничением элементов списка круглыми скобками "(" и ")". Например::

    (x1, x2, x3, x4).

Нумерация элементов списка в данном случае задается неявно в соответствии с
порядком их следования слева направо (это же соглашение предполагается и в графическом
представлении при отсутствии явной нумерации входов).

.. figure:: img/f1_4.png
       :scale: 300 %
       :align: center
       :alt: Оператор группировки в список данных

       Рис. 1.4.  Оператор группировки в список данных

Выполняясь над дугами с разметкой любой кратности, оператор группировки в список
на выходе всегда формирует разметку кратности 1. Количество элементов в сформированном
списке равно сумме кратностей разметок всех входных дуг.

Наряду с группировкой в список данных предполагается возможность создания
параллельных списков. **Оператор создания параллельного списка** (рис. 1.5) обеспечивает
группирование элементов, аналогичное списку данных. Однако, кратность разметки,
определяющая выходной набор данных равна сумме кратностей разметок всех входных дуг.

.. figure:: img/f1_5.png
       :scale: 300 %
       :align: center
       :alt: Оператор группировки в параллельный список

       Рис. 1.5.  Оператор группировки в параллельный список

Сформированная структура при выполнении оператора интерпретации рассматривается в
другом контексте. В соответствии с ниже описанной алгеброй преобразований языка
считается, что задаваемая функция использует каждый элемент данного списка как
независимый аргумент. Если же параллельный список определяет набор функций, то все они
выполняются одновременно над одним и тем же аргументом. Таким образом, данная
конструкция обеспечивает организацию массового параллелизма. В текстовом виде
группировка в параллельный список задается ограничением его элементов квадратными
скобками **"["** и **"]"**. Например::

    [x1, x2, x3, x4 ] .

При этом осуществляется сквозная перенумерация всех элементов сформированного
списка слева направо с учетом суммарной кратности.

**Оператор группировки в задержанный список** (рис. 1.6) задается вершиной,
содержащей допустимый вычисляемый подграф, в котором возможно несколько входов и выходов. Входы связаны с дугами, определяющими поступление аргументов, а выход определяет выдаваемый из подграфа результат. Специфической особенностью такой группировки является то, что ограниченные оператором задержки вершины (на графе ограничение задается контуром формируемой мультивершины), представляющие другие программо-формирующие операторы, не могут выполняться, даже при наличии всех аргументов. Их активизация возможна только при снятии задержки (раскрытии контура),
когда ограниченный подграф становится частью всего вычисляемого графа.

.. figure:: img/f1_6.png
       :scale: 300 %
       :align: center
       :alt: Список задержанных вычислений

       Рис. 1.6.  Список задержанных вычислений

Задержанный подграф создает на своем единственном выходе константную разметку,
которая является образом (иконкой) данного подграфа. Эта разметка распространяется по
дугам графа от одного программо-формирующего оператора к другому, размножаясь, входя
в различные списки и выделяясь из них до тех пор, пока не поступит на один из входов не
задержанного оператора интерпретации. При наличии на его обоих входах готовых данных
происходит подстановка, вместо иконки, ранее определенного задержанного графа с
сохранением входных связей. Опоясывающий подграф контур оператора задержки при этом
«убирается», и происходит выполнение активированных операторов. В результате на
выходной дуге раскрытого подграфа вновь формируется результирующая разметка, которая
и является одним из аргументов оператора интерпретации, раскрывшего задержанный
подграф. Данная процедура называется раскрытием задержанного подграфа. В текстовом
виде группирование в список задержанных вычислений (для краткости будем называть
также задержанный список) задается охватом соответствующих операторов фигурными
скобками **"{"** и **"}"**. Например::

    {x1, x2, x3, x4} или {(a,b):+} .

Наличие этой конструкции позволяет откладывать момент начала некоторых
вычислений или вообще не начинать их, что необходимо при организации выборочной
обработки данных.

Описание динамики функционирования
-----------------------------------

Правила распространения разметки по графу складываются из общих правил
межоператорных переходов, правил срабатывания программо-формирующих операторов,
правил выполнения оператора интерпретации над предопределенными функциями модели (а
далее и языка), правил эквивалентных преобразований операторов и связей допустимого
графа (алгебры преобразований, связанной с исполнением отдельных операторов и
описанной выше).

**Правила межоператорных переходов** задают распространение разметки по графу:

1. Если входные дуги вершины имеют разметку, то на выходных дугах происходит формирование разметки в соответствии с правилами срабатывания вершины, определяющий программо-формирующий оператор.

2. Если входные разметки имеют кратность, превышающую единицу, то для заданной вершины формирование выходной разметки может начинаться при неполной входной разметке независимо для каждого из сформированных наборов входных данных, и осуществляется в соответствии аксиомами срабатывания программо-формирующих операторов.

3. В процессе распространения разметка не убирается и не замещается. Каждая дуга графа может получить разметку только один раз. Из требования о недопустимости повторной разметки вытекает требование ацикличности графа.

4. Процесс распространения разметки заканчивается, когда все дуги графа имеют полную разметку в соответствии с предписанной кратностью или при невозможности распространения разметки.

**Правила срабатывания программо-формирующих операторов** конкретизируют
формирование разметок на выходных дугах для каждого из ранее введенных операторов.
Оператор интерпретации обеспечивает преобразование входного набора данных X,
выступающего в качестве аргумента, в выходной набор Y, играющего роль результата,
используя при этом входной набор F в качестве функции, определяющей алгоритм
преобразования. В постфиксной нотации, выбранной для дальнейших иллюстраций, данное
преобразование можно записать следующим образом::

    X:F ⇒ Y .

Можно рассмотреть множество унарных функций F, разделив его при этом на два подмножества::

    F = {f1, f2},

где **f1** - множество предопределенных функций языка, для каждой из которых аксиоматически задается области определения и изменения; **f2** - множество функций, порождаемых при программировании. Необходимо отметить, что областью определения любой функции из **F** является множество одноэлементных наборов данных. Обработка же параллельного списка определяется с помощью правил эквивалентных преобразований.

Результатом выполнения функции может быть любой тип данных, включая параллельный
список произвольной кратности. Следует отметить, что выбор базового набора
предопределенных функций осуществляется в некоторой степени субъективно, исходя из
соображений удобства пользования разрабатываемым языком. Вводятся аксиоматически
определенные арифметические функции, функции сравнения и прочие, аналогично тому, как
это сделано и в других языках программирования. Например, функция сложения двух чисел
**x1**, **x2**, порождающая в качестве разметки число **y**, задается следующим образом::

    (x1, x2):+ ⇒ y,

где первый аргумент оператора интерпретации является двухэлементным списком
данных. Каждый элемент этого списка должен быть числом. Второй аргумент оператора
интерпретации является функцией сложения, обозначенной значком "**+**". Результат
функции сложения, значение y, является атомарным элементом.
Наряду с определением функций, присущих всем языкам программирования, целесообразно определить множество функций, нестандартных в традиционном понимании. Например, целое число может непосредственно интерпретироваться как функция выбора элемента списка::

(x1, x2, ... xi, ... xn):i ⇒ xi ,

где i - натуральное число, xi – элемент списка. Данная функция выделяет из списка
данных i-й элемент, который и определяет разметку выходной дуги.
Другой полезной предопределенной функцией является::

    (b1, b2, b3, ... bn):? ⇒ [i1, i2, ... ik] ,

где (b1,...bn) - список булевских величин; [i1,... ik] - параллельный список
натуральных чисел, определяющих номера тех компонент булевского списка, которые
имеют истинные значения. Наличие данной функции позволяет формировать условия,
обеспечивающие выполнение нескольких альтернативных ветвей программы.

Наряду с определением операции интерпретации для аксиоматически определенных
функций, она также определяется и для уже существующих программо-формирующих
операторов. Так, в частности, определены следующие правила раскрытия задержанного
списка::

    {x1,...,xn}:f ⇒ [x1,...,xn]:f                       (1.1)
    x:{f1,...,fk} ⇒ x:[f1 ,...,fk]                      (1.2)
    {x1,...,xn}:{f1,...,fk} ⇒ [x1,...,xn]:[f1,...,fk]   (1.3)

Выражение (1.1) показывает, что, при наличии разметки на дуге, определяющей вход
f, задержанный список данных ``{x1,...,xn}`` преобразуется в параллельный. Далее, если
x1,...,xn являются допустимыми подграфами, следует получение их значений, после
чего осуществляется выполнение заданного оператора интерпретации.

Выражение (1.2) описывает аналогичное раскрытие задержанного списка функций при появлении разметки на входе, определяющем x. Если же оба аргумента оператора интерпретации являются
задержанными списками (1.3), то они в начале воспринимаются, как константные значения,
что определяет их немедленное преобразование в параллельные списки. После этого
каждый список вычисляется, что приводит к разметке входных дуг описанного оператора
интерпретации и его выполнению. 

Следует заметить, что вид операторов интерпретации, приведенный в выражениях 1.1-1.3, не является окончательным перед их вычислениями. Необходимо еще провести дополнительное приведение к элементарным вычислительным действиям в соответствии с правилами эквивалентных преобразований.

Эквивалентные преобразования
------------------------------

Правила эквивалентных преобразований операторов и связей допустимого графа
определяют алгебру модели и языка программирования. Они позволяют осуществить
трансформацию графа, обеспечивающую сведение сложных структурированных операций
к набору элементарных действий над предопределенными компонентами. Возможна также
обратная структуризация элементарных действий, полезная при адаптации полученной
функциональной параллельной программы к архитектуре конкретной ВС. Эквивалентные
преобразования определены на множестве программо-формирующих операций и отражают
общие алгебраические свойства модели.

Проведение этих преобразований может происходить как перед началом вычислений, когда они применяются к исходному информационному графу, так и непосредственно в ходе выполнения программы. В этом случае преобразования проходят на частично размеченном графе.

Для описания правил эквивалентных преобразований введем ряд обозначений.
Отдельные значения элементов (значения одноэлементных параллельных списков) будем
обозначать малыми латинскими буквами: ``a``, ``b``, ``c``, ``d``, ``e``, ``x``, ``y``, ``z`` для данных и ``f``,``g``, ``h`` для функций. Значения параллельных списков данных и функций обозначим
соответствующими заглавными латинскими буквами. Аналогично для еще не вычисленных
элементов будем использовать малые латинские буквы: ``q``, ``r``, ``s``, ``t``, ``v``, ``w``. Не
вычисленные выражения внутри параллельных списков обозначим через эти же, но
заглавные буквы. Для описания порядкового расположения элементов списков будем
использовать индексы, задаваемые натуральными числами и буквами ``i``, ``j``, ``k``, ``l``, ``m``, ``n``.

Например::

    X = x1, x2,...,xi,...,xn ;
    F = f1, f2, f3  ;
    W = w 1,...,wk .

Перед выполнением любой операции интерпретации выполняются (в случае
необходимости) следующие эквивалентные преобразования.





++++++++++

**Список используемых источников**

.. include:: References.rst
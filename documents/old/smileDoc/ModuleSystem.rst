.. |date| date:: %d.%m.%Y
.. |time| date:: %H:%M
.. |copy| unicode:: 0xA9 .. copyright sign

.. Текущая дата |date| и время |time|

.. meta::
   :description: Описание концепций, языковых и инструментальных средств функционально-потокового параллельного программирования.
   :keywords: парадигмы программирования, функционально-потоковое параллельное программирование

:Author:    Александр Легалов
:Email:     <legalov@mail.ru>
:Date:      |date|
:Version:   0.0

:Copyright: |copy| Драфт для внутреннего обсуждения

.. sectnum::
    :start: 1

.. contents:: Содержание
    :depth: 4


=================================================
Размышления по поводу модуля базовых артефактов
=================================================

В данном тексте я пытаюсь высказать соображения по поводу аксиоматического описания набора базовых артефактов (типов, операций, может быть и констант) в некотором системном модуле или модуле System.
В данном случае речь не идет о копировании идеи из Оберона, имеющего такой модуль. Под модулем понимается репозиторий. С таким же успехом его можно обозвать пакетом или сборкой. Но в любом случае мы имеем изолированную конструкцию, которая включает в себя набор артефактов, для доступа к которым используется интерфейсный артефакт, экспортирующий описания, или интерфейс экспорта. В настоящий момент он задается файлом ``export``.

Основной идеей модуля System является описание набора базовых типов, определяющих элементарную аксиоматику языка. Подразумевается, что за счет набора этих описаний можно ориентировать язык на различные наборы типов и базовых операций. То есть в результате мы будем иметь не конкретный язык программирования с заданными типами данных и операций над ними, а некоторую оболочку конструктивов, наполняемую в зависимости от того, в рамках какой предметной области мы собираемся использовать функционально-потоковую парадигму программирования.

Появляется некоторый аналог суперкласса, который не хотелось бы называть суперязыком (нужно придумать название, например, над-язык), но от которого как бы наследуют механизм конструирования алгоритмов различные дочерние языки (под языки). Это наследование или расширение проявляется в описании семантики базовых типов и операций над ними, которые фиксируются в различных описаниях экспорта экспорта.

На уровне компиляции, когда на выходе формируется реверсивный информационный граф (РИГ) семантика этих описаний особой роли не играет. Основной анализ корректности осуществляется на основе анализа корректного использования описанных базовых типов и базовых функций (операций над базовыми типами или простот операций). Реальная семантика конкретного подъязыка проявляется только в момент генерации кода объектной машины или в ходе интерпретации функции, задаваемой информационным графом, когда каждому базовому артефакту начинает сопоставляться конкретный набор структур данных и методов их обработки, непосредственно привязанный к соответствующему исполнителю.

Для чего это предполагается использовать? При обычном построении компилятора с языка Smile все базовые типы и операции их обработки нужно вводить в структуры данных, образующих списки базовых артефактов, непосредственным кодированием в программе. Расширение базовой семантики или ее модификация, а также изменение ведут к изменению соответствующего программного кода. Это в принципе не такая сложная задача. Вместе с тем, доступ ко всем этип артефактам в основном осуществляется по именам и знакам спецсимволов, что в принципе позволяет хранить сформированные программным путем описания базовых артефактов во внешнем формате, аналогичном форматам артефактов, создаваемых программистом. Поэтому можно вместо кода даже для моноязыка (еще один вариант названия для обычного языка) загружать соответствующие описания из описания базовых артфактов. Это описание можно увязать с модулем System, подгружаемым по умолчанию.

Развивая эту идею можно перейти к концепции полиязыка (еще один вариант названия для суперязыка), на основе которого можно создавать различные конечные языки - наследующие конструктив, но имеющие собственную семантику типов и операционную семантику, определяемую соответствующими аксиомами, корректность которой на базовом уровне можно обеспечить формальными методами.

Фрагмент модуля систем для подъязыка с традиционной семантикой
-----------------------------------------------------------------

В качестве примера можно рассмотреть, каким образом во внешних описаниях может быть представлены базовые типы и операции для традиционного языка программирования, реализуемого в настоящий момент.

Пусть в модуле System (в текущей версии это соответствующий каталог) хранится описание базовых артефактов (в данный момент это файл export) в соответствии с принятым форматом. 

Описания артефактов в списке экспорта
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Описания базовых типов данных.** Следует отметить, что значения для базовых типов не задается, так как их реальные параметры определяются в семантике интерпретатора или генератора кода. Однако для обозначения базового типа используется дополнительный признак в виде минуса. Например::

    type int -
    type bool -
    type char -
    type real -

На основе описаний базового типа формируются производные типы, используемые для описания операций. Например, типы, определяющие группировки в целочисленные и действительные пары::

    type intpair datalist 2 int int
    type realpair datalist 2 real real

На основе базовых и производных от них типов можно формировать различные операции, включая и операции, обозначаемые специальными символами::

    function + intpair int
    function + realpair real

Выше определяются базовые функции заданные спецсимволом + над парой целых с выдачей целого и над парой действительных с выдачей действительного. Следует отметить, что сама семантика операций, как и структура базовых типов в этом описании не задается (то есть, знак "+" может подразумевать что угодно). Она определяется на уровне формального описания семантики, например, с использованием методов формальной верификации, а впоследствии это формальное описание реализуется в виде интерпретатора или генератора кода.

Вариант ввода новых базовых описаний
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Заполнять список экспорта модуля System вручную - неблагодарное занятие. Поэтому в компилятор можно ввести режим, когда он обрабатывает артефакт из модуля System, на основании которого порождает новое описание также, как и для обычного модуля.
Тогда, например, ранее введенные примеры можно добавить в список экспорта, откомпилировав следующие артефакты в качестве отдельных единиц компиляции::

    int << typedef;
    bool << typedef;
    char << typedef;
    real << typedef;
    intpair << typedef @(2@int);
    realpair << typedef @(2@real);
    + << funcdef @intpair -> @int;
    + << funcdef @realpair -> @real;

Возражения
----------------

Несмотря на то, что данная концпция построения предметно-ориентированных языков на базе общего надъязыка выглядит привлекательной, существует ряд *очевидных* моментов, которые не позволяют ее реализовать без проблем. К ним можно отнести следующие.

#. **Что делать с константами?** Константы и константные выражения заточены на конкретные базовые типы и операции. Они обычно реализуются с использованием кода, встроенного в компилятор, что не позволяет осуществлять безболезненную замену для них как базовых типов, так и операций обработки. Другим моментом является то, что синтаксис констант также привязан к базовому типу и операциями над ним. Поэтому введение новых типов требует и переопределения константных выражений, трудно вынимаемое из уже написанного кода. Речь не идет о проблемах выделения модулей. Речь о том, что семантика констант сама по себе изменяется на другую достаточно болезненно, так как затрагивает изменения в синтаксисе языка и семантике, определяемой этим синтаксисом.
#. **Как задавать внутреннее представление для базовых типов данных?** В текущей реализации каждый базовый тип определяется своим классом (структурой). Для каждого из базовых типов используется свое обозначение в перечислимом типе данных. Необходимо будет унифицировать систему, введя для всех базовых типов единый класс и его признак в перечне типов. Сами же типы нужно будет идентифицировать, по всей видимости, по имени. В целом это не такая большая проблема, которая вместо сравнения и другим операци с перечислимыми типами приведет к сопоставлению строк символов.
#. **Вопросы написания кода, реализующие семантику расширений.** Необходимо продумать, каким образом добавлять в программу код, обеспечивающий реализацию новых проблемно-ориентированных расширений, а также как убирать код, который уже не нужен. Проблема для константных выражений. Для генератора кода и интерпретатора решения вроде бы проглядываются.

Резюме
-----------

В рамках текущего проекта остаюсь на прямой реализации, так как основной проблемой является работа с константными выражениями. О возможном более гибком решении буду думать позднее.
Для базовых операция можно добавить отдельный список со своими именами и спецсимволами, загружаемый на этапе инициализации.

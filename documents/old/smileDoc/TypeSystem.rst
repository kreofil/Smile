.. |date| date:: %d.%m.%Y
.. |time| date:: %H:%M
.. |copy| unicode:: 0xA9 .. copyright sign

.. Текущая дата |date| и время |time|

.. meta::
   :description: Описание концепций, языковых и инструментальных средств функционально-потокового параллельного программирования.
   :keywords: парадигмы программирования, функционально-потоковое параллельное программирование

:Author:    Александр Легалов
:Email:     <legalov@mail.ru>
:Date:      |date|
:Version:   0.0

:Copyright: |copy| Допускается свободное прочтение без использования в связи с непроработанностью решаемых задач.

.. sectnum::
    :start: 1

.. contents:: Содержание
    :depth: 4


=============================================
Заметки по поводу типов в Smile
=============================================

В документе представлены размышления по поводу представления типов данных в статически типизированном языке функционально-потокового параллельного программирования. В принципе, так как речь идет об организации данных, полученные результаты могут быть применены к различным языкам как функционального, так и императивного программирования. В целом используемые приемы больше затрагивают процедурный подход, в котором использование процедур, связанных с типом часто трактуется как разновидность объектно-ориентированного стиля.

Введение
-------------

Основной целью данного документа является описание системы типов, которую предполагается использовать в языке программирования Smile. Это описание опирается на анализ вариантов, затрагивающих различные аспекты реализации. К основным моментам, с которыми нужно определиться относятся:

- общее представление статических типов в языке Smile;
- представление базовых типов и их связь с константами и константными выражениями;
- описание типов в функциях и описание функциональных типов;
- анализ возможности и вариантов использования структурной и именованной эквивалентности типов
- преобразование типов, включая (если это так называется) возможное их разыменование;
- определение новых типов пользователем, затрагивающих как статическую, так и динамическую типизацию;
- организация обобщений и анализ вариантов реализации полиморфизма типов с выбором варианта (вариантов) для текущей реализации, включая реализацию общего для всех типа (any).

В основном этот документ пока трактуется как драфт. Он переродится в официальное сообщение (в составную часть официального сообщения) после реализации определенного варианта в языке программирования, получив при этом версию 1.0.

*На текущий момент пришел к следующему результату. Предполагается что для любых данных тип будет именованным, то есть, либо он будет базовым, либо будет сформированным в описании typedef.*

Представление статических типов
---------------------------------

В языке программирования Smile предполагается использование статической типизации для всех типов данных, обеспечивающих формирование агрегатов. Вместе с тем следует отметить, что использование обобщений и полиморфизма автоматически ведут к тому, что тип альтернатив формируется и может быть определен только на этапе выполнения программы. Эти вопросы рассматриваются после того, как будут описаны варианты, связанные с агрегированием данных без использования обобщений.

.. note::

    Можно отметить, что не существуют языков программирования, в которых теми или иными средствами нельзя было бы определять тип данных во время выполнения. Это объясняется тем, что практически во всех реальных задачах встречаются обобщения, задающие альтернативы, реальный тип специализаций в которых формируется только на этапе выполнения программы. Вопрос заключается только в том, каким образом осуществляется проверка типа во время выполнения. Используется полиморфизм или это происходит явным образом. Можно даже сказать, что статически типизированные языки в большей степени являются статико-динамически типизированными.

В любом языке можно выделить атомарные и составные (конструируемые) типы данных. К атомарным относятся неделимые типы, которые определяют базовую функциональность языка.
Составные типы состоят из атомарных и могут быть как строго определенными, так и задаваемыми без наложения ряда ограничений, например, их размерности, которая может формироваться динамически во время выполнения программы. Атомарным типом соответствуют константы, для которых задан как способ их записи, так и ряд семантических параметров, например, диапазон. Составные типы образуют разнообразные структурные конфигурации и состоят из констант атомарного типа, а также из других структурных конфигураций, соответствующих семантике языка.

Наряду с типами, описывающими организацию данных, существуют и описания функций, которые взаимодействуют с данными через описание типов аргументов и результатов. Функции также могут выступать в качестве данных. Поэтому для них характерен функциональный тип. Функции могут быть также атомарными и составными. Атомарные функции определяют базовый набор операций языка над заданными атомарными типами данных и определенными видами составных типов. Их набор фиксирован. Составные функции образуют именованные конструкции, состоящие из атомарных функций, а также из составных функции, включая рекурсивные определения. Каждой составной функции соответствует имя, задаваемое программистом или сигнатура, если допускается перегрузка имен фукнций.

Независимо от разновидности типа программа оперирует величинами, каждой из которых в текущий момент соответствует тип и значение. Это соответствие можно задать двойкой::

    Величина = <тип, значение> .

Атомарные типы
~~~~~~~~~~~~~~~~~

Атомарные типы задаются путем задания их имени с предшествующим (без разделителя) значком @.
Например::

    @int, @signal...

В языке имеются величины, обозначаемые идентификаторами. Для них в синтаксисе языка предусмотрено явное задание типа в виде::

    Обозначение@тип .

Например::

    X@int, b@bool, A@real...

Тип констант определяется их видом и текущим контекстом. При этом вид констант различного типа формируется за счет соответствующих синтаксических правил::

    Целое = {/ цифра /}.
    Действительное = ["+:|"-"]{/ цифра /}"."{/ цифра /} [Порядок] | {/ цифра /} Порядок.
    Порядок = ("E"|"e")["+:|"-"]{/ цифра /}.
    Булевское = "true" | "false".

Текущий контекст позволяет на этапе компиляции рассматривать ряд констант как константы другого типа, что бывает удобным для сокращения описания. В частности, если целочисленная константа участвует в операциях над действительными числами, она автоматически преобразуется в действительное число. С другой стороны целочисленные константы 0 и 1 могут быть также автоматически преобразованы в булевские true и false, если используются в булевском контексте. 
Во всех остальных случаях необходимо использовать явное приведение одного типа к другому в соответствии с аксиоматикой языка. Например::

    123.5:int, 45:real...

Основные атомарные типы
""""""""""""""""""""""""""""""

Состав атомарных типов определяется аксиоматикой языка программирования. В принципе этот состав для концепции функционально-потокового параллельного программирования может изменяться, определяя тем самым различные языки (подъязыки), построенные на основе единого каркасного языка (праязыка), основной функцией которого является формирование общего программоформирующего фундамента. Этот фундамент определяется программоформирующими операторами функционально-потоковой модели параллельных вычислений (ФПМПВ), а также составными типами данных, введенными для реализации статической системы типов.

В данном случае предполагается формирование базового универсального подъязыка, содержащего атомарные типы, присущие традиционным языкам программирования. Помимо этого ряд атомарных типов входят в состав каркасного языка и поэтому имеются во всех подъязыках (каркасные атомарные типы). Наличие каркасных типов обуславливается их использованием в базовых программоформирующих операторах, без которых ФПМПВ не может быть сформирована.

К каркасным атомарным типам относятся:

1) Сигнальный тип (@signal), для которого отсутствует значение. В языке программирования его наличие задается символом точки: ".". Описание в виде пары <тип, значение> выглядит следующим образом::

    <@signal, null>

где null означает отсутствие значения.

Рассматриваемый универсальный язык имеет следующий состав атомарных типов.

1) Целочисленный тип (@int). Предполагает в данном случае, что это 32 или 64 разрядные целые числа в зависимости от разрядности целых чисел в архитектуре компьютера (в соответствии с разрядностью типа int языка программирования C++). Данному типу соответствуют целочисленные константы.

2) Действительный тип (@real). Определяет 64-разрядные числа с плавающией точкой, аналогичные по представлению числам типа double языка программирования C++. Данному типу соответствуют действительные константы. Не относится к каркасному типу

3) Булевский тип (@bool). Определяет значения true и false. По представлению в памяти соответствуюет типу bool языка программирования C++.

4) Символьный тип (@char). Определяет отдельные символы в кодировке UTF-8. Данному типу соответствуют символьные константы языка.

Составные (конструируемые) типы
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Составные типы объединяют атомарные и ранее созданные составные типы в более сложные конструкции. Основным для них является способ конструирования нового типа, а не то, каким образом этот тип описывается на атомарном уровне. Каждый язык программирования имеет свой набор составных типов, обеспечивающих специфические для этого языка методы их формирования. Для языка программирования Smile можно выделить следующие составные типы:

- список данных;
- параллельный список;
- асинхронный список;
- задержанный список;
- обобщающий тип.

Помимо этого на базе общих основных типов можно создавать конкретные подтипы, ориентированные на поддержку конкретных конструкций.

Список данных
"""""""""""""""""""""

Списки данных описываются с использованием как скобок соответствующего вида, так и с возможностью представления через идентификаторы::

    ТипСписокДанных = "@"["datalist"]"(" ([Целое | ЦелочисленноеКонстантноеВыражение] Тип 
               {"," [Целое | ЦелочисленноеКонстантноеВыражение] Тип}] [".." Тип]) 
            | (".." Тип) ")".

Данное описание позволяет формировать разнообразные списки данных как постоянной, так и переменной длины, которые в процессе трансляции могут быть трансформированы в различные представления с учетом возможной оптимизации. На уровне описания можно привести следующие примеры.

Список данных, состоящий из двух целочисленных атомов::

    @(@int, @int) == @datalist(@int,@int) == @(2@int)

Вместо повторения одинаковых и следующих подряд описаний допускается использовать коэффициент повторений. Например, обозначение ``3@int`` является кратким обозначением цепочки однородных элементов эквивалетной из последовательности, не объединенной в структурную единицу.
То есть::

    2@int == @int, @int

В общем случае коэффициент повторения может быть задан не только целым числом на и целочисленным константным выражением, включающим и символические обозначения констант::

    N@int, (3,k):*@real, (N,K):-@char

*Пока в предварительной версии до такого глубокого погружения опускаться не планируется.*

Если список состоит из произвольного числа элементов, то вместо конкретного числа указывается многоточие из двух точек::

    @(4@int, 5@real, ..@bool)

При этом списки произвольной размерности необходимо указывать после перечисления всех списков фиксированной размерности. Допускается только одна такая последовательность в любом списке, включая и пустую. Использование множества последовательностей может привести к неоднозначности.
Если необходимо указать, что последовательность элементов одного типа состоит из одного и более элементов, то перед произвольной последовательностью достаточно просто указать один элемент такого же типа::

    @тип, ..@тип

Это же касается и случая, когда количество начальных элементов перед цепочкой переменной длины больше, чем один

Допускается именование полей списков с использованием локальных идентификаторов, спецификой которых является то, что они начинаются с точки.
Например::

    @(@int >>.a, .b << @real)

Не допускается именовать кратные элементы (линейные последовательности) как фиксированной, так и произвольной длины.

Описание функциональных типов
-------------------------------

Любой из функциональных типов на уровне постпредставления (то есть, после компиляции) будет задаваться двойкой типов: именованным типом аргумента и именованным типом результата::

    ОписаниеФункциональногоТипа = "@"ИмяТипа "->" "@"ИмяТипа.

Это же касается и аксиоматики типов базовых операций. 

.. note::

    Думаю, что можно будет допускать перегрузку имен функций, идентифицируя отличие по сигнатуре, которую предполагается определять по имени функции и типу аргумента. При этом, по всей видимости, необходимо, чтобы сигнатурные типы не перекрывались, то есть, чтобы обобщающий тип (такой вполне может появиться) не перекрывал входящий в него тип. В противном случае появится неоднозначность сигнатур. Использовать для идентификации тип результата считаю нецелесообразным. *Вместе с тем следует отметить, что пока вопрос об использовании перегрузки функций не проработан окончательно.*

Определение функции задается следующим образом::

    ОпределениеФункции = "funcdef" [[ИдентификаторАргумента]"@" ИмяТипаАргумента] "->" ИмяТипаРезультата ТелоФункции [";"]

Примеры::

    funcdef ArgName@Type1->@Type2

Для прототипов функций имена аргументов и тело не указываются::

    ПрототипФункции = "funcdef" ["@" ИмяТипаАргумента] "->" ИмяТипаРезультата [";"]

Примеры::

    funcdef @Type1->@Type2

.. note::

    В перспективе можно также подумать над различными вариантами сокращенных описаний, не нарушающих распознавание конструкций. Например, можно не указывать аргумент, если ввести имя по умолчанию в виде подчеркивания "_", что широко используется в различных языках программирования. Можно также опускать запятые и даже пробелы, а также знак ``->``, если это не приводит к неоднозначному толкованию. Но весь этот сахар на потом, когда будет реализован основной каркас.

Предполагается перегрузка функций по именам за счет разного типа аргумента.
Соответствующим образом это может идентифицироваться в именах файлов добавлением после имени функции обозначения типа аргумента ``@Type``. Например::

    abs@int
    abs@real

Аналогичным образом можно описывать и базовые функции, задавая их через различные именованные типы, которые и определяют отличие при одинаковом знаке операции. Например::

    func+ << funcdef @IntPair->@int
    func+ << funcdef @RealPair->@real
    func+ << funcdef @BoolPair->@bool

где предварительно определены имена типов, задающих аргументы, в описании типов::

    IntPair << typedef @(2@int)
    RealPair << typedef @(2real)
    BoolPair << typedef @(2@bool)


Возможно в будущем стоит подумать о заголовка функции без задания слова funcdef (то же можно подумать и для констант). 
Тогда описание заголовка функции может выглядеть следующим образом::

    FuncName<< X@ArgTypeName->@ResTypeName

или::

    FuncName<< @ArgTypeName->@ResTypeName

Все это нужно смотреть в ходе дальнейшей работы.

Размышления по поводу именованной и структурной эквивалентности типов
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

На текущий момент привлекательной выглядит именованная эквиалентность, когда при описании типов аргумента и результата используются имена типов, ранее описанных в typedef. В этом случае упрощается сравнение взаимосвязанных функций. Вместе с тем существуют определенные проблемы, которые при непосредственном решении могут затруднить программирование. Пусть существует описание функции сложения::

    func+ << funcdef @IntPair->@int

где::

    IntPair << typedef @(2@int)

Тогда при сложении двух целых чисел и использовании только именованной их эквивалентности придется вместо::

    (a,b):+

писать::

    (a,b):IntPair:+ ,

что весьма неудобно. При этом все равно семантическому анализатору придется делать проверку на структурную эквивалентность операции приведения типа вместо аналогичной проверки для функции сложения.
Возможны следующие варианты решения этой проблемы:

1. Отказ от именованной эквивалентности в описании типов аргумента и результата функции с переходом к структурной эквивалентности.
2. Допустить в аналогичных выражениях анализ именованных типов на структурную эквивалентность с формируемыми данными.

Пока предпочтительным выглядит второй вариант, обеспечивающий в целом более надежное приведение и преобразование типов. Помимо этого упрощается анализ эквивалентности сигнатур функций за счет сопоставления только на именованную эквивалентность.

К одному из возможных недостатков такого подхода можно отнести необходимость задания имен типов для всех базовых операций формируемого языка программирования, что ведет к резервированию дополнительного множества имен.


Расширение системы типов за счет использования методов поддержки полиморфизма
---------------------------------------------------------------------------------

Рассматриваемые варианты
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Обобщений, определяющие альтернативные типы данных, используются практически в любой реальной программе. Основной их спецификой является определение типа артефакта во время выполнения. В процедурных языках это обычно осуществляется за счет явной проверки типов или признаков типов, явно задаваемых программистом. Например, в языке программирования Pascal признаки задаются в вариантных записях. В языке программирования C альтернативы, задаваемые в объединениях образно связываются с признаками, фиксируемыми в специально выделенной переменной.

Современном программирование в большинстве ситуаций отказывается от явной проверки типов во время выполнения, заменяя ее на использование полиморфизма, что в целом повышает надежность программ и позволяет эволюционно расширять обобщения. 

Существует несколько интересных подходов, которым стоит уделить внимание. В данном случае проводится анализ отображения на ЯФППП следующих вариантов:

#. Использование наследования (или, в трактовке Вирта, расширения) данных (Объектно-ориентированный полиморфизм или ОО-полиморфизм).
#. Применение интерфейсов в стиле языка программирования Go (Go-полиморфизм).
#. Использование процедурно-параметрических обобщений (Процедурно-параметрический полиморфизм или ПП-полиморфизм).

Предполагается рассмотреть особенности отображения этих вариантов на синтаксис языка и на основе этого провести сравнительный анализ полученных вариантов по следующим критериям:

- естественность отображения вводимых конструкций на синтаксис языка;
- удобство и естественность использования рассматриваемых вариантов при программировании;
- особенности реализации и эффективность реализации сопоставляемых подходов.

Помимо этого предполагается проанализировать возможность совместного использования (или использования каких-то совместных комбинаций) с точки зрения их совместимости и перекрытия.

Возможность реализации в ЯФППП различных вариантов полиморфизма во многом определяются дуализмом представления функции интерпретации, которая имеет два аргумента, один из которых трактуется как значение, а другой в качестве функции. Исходя из этого как префиксная запись ``F^X``, так и и ее постфиксный аналог ``X:F`` могут толковаться двояко:

#. Функция ``F`` обрабатывает аргумент ``X``, что соответствует традиционной трактовке процедурного программирования.
#. Объект ``X`` вызывает свой метод ``F``, что в принципе соответствует объектной трактовке.

Такой дуализм подкрепляется еще и тем, что в реализации Smile в функциях предполагается использовать только именованные типы. Это должно повысить надежность программы за счет именованной эквивалентности. Помимо этого должны стать проще (?? то ли слово?) формальное доказательство корректности программ, а так же преобразование в параллельные программы написанные на традиционных (других?) языках программирования.

Наследование (расширение)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Само по себе наследование, особенно когда речь идет о структурах, содержащих только данные, не является ОО атрибутом. Оно прекрасно может использоваться и в процедурных языках. Примерами таких языков являются Оберон и C++. Вместе с тем, в сочетании с методами, использование наследования является основным приемом формирования программных объектов в ОО языках программирования. Размещение внутри формируемого артефакта размещаются как данных, так и методов не вполне соответствует концепции функционального программирования (особенно для ФПППП). Однако существуют языки, в которых механизм наследования реализован структур, содержащих только данные, а виртуализация обеспечивается посредством процедур (функций) связанных с типом. В качестве примера можно привести языки Оберон-2 и Ада. Аналогичный подход в принципе может быть использован и в ЯФППП.

Возможный вариант описания ОО-полиморфизма в ЯФППП
"""""""""""""""""""""""""""""""""""""""""""""""""""

Пуст ``T`` - базовый тип артефакта, определяемы при ссылке на значение как ``@T``::

    T << typedef ...

Определение артефакта ``U``, расширяющего ``T``, предполагается осуществлять следующим образом::

    U << typedef T+РасширениеТипа ,

Где расширение типа - это дополнительные поля характеризующие специализацию, задаваемые с учетом использования методов описания, представленных выше. 

*В связи с тем, что речь идет только об организации данных, возможно расширение типа за счет использования множественного наследования, хотя нужно внимательно посмотреть, насколько целесообразен и реализуем подобный вариант*::

    U << typedef T1,T2,Tn+РасширениеТипа

*Следует однако отметить, что при таком варианте возникают непредвиденные сложности, которые пока сложно проанализировать. Поэтому на данном этапе от дальнейшего анализа этого варианта отказываюсь.*

Так как каждый вновь формируемый тип имеет имеет свое имя, задаваемое в соответствии с синтаксисом и семантикой языка, достаточно просто описать функции - обработчики специализаций, связанные с типом, расширяющие базовую функцию (по аналогии с процедедурами, связанными с типом, языка программирования Оберон-2). 
Например, если имеется функция ``F`` над базовым типом типом ``T`` и аргументом-сообщением W, описываемая как::

    F(@T) << funcdef x@W->@Q ...,

то ее расширение будет отличаться указанием типа @U дочернего расширения::

    F(@U) << funcdef x@W->@Q ....

Таким образом, формируемое описание функции практически ничем не отличается от описание ее перегрузки, осуществляемой при статическом полиморфизме. И в том и другом случае идентификация осуществляется по сигнатуре, что отображается в разных именах, задаваемых при размещении в репозитории::

    F@T@W - для первой функции,
    F@U@W - для второй.

В том случае, если для расширения типа отсутствует функция, вызывается функция родительского типа. Родительская функция может быть абстрактной. В этом случае необходимо наличие всех обработчиков специализаций, каждый из которых обрабатывает свой расширяемый тип.

При вызове функции в программе подставляется функция, соответствующая своему расширению типа или родительскому типу, если свой обработчик специализации отсутствует.

В случае с множественным наследованием возможны варианты, когда для различных базовых типов будут свои функции. В этом случае обработчики специализаций могут быть прописаны в соответствии с функциями каждого базового типа. Пусть даны следующие обработчики обобщений::

    F1(@T1) << prefunc @W1->@Q
    F2(@T2) << prefunc @W2->@R

Тогда для расширения типа ``U`` можно будет (с учетом вышесказанного) написать следующие обработчики специализаций::

    F1 << prefunc @U->@Q
    F2 << prefunc @U->@R

Возможные проблемы использования наследования в ЯФППП
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

**Наложение ограничений на базовый тип**

Базовый тип интегрируется с расширением. Поэтому он должен четко идентифицироваться в различных случаях. Возможно, что в качестве базы могут выступать только ограниченные конструкции. Например, только списки с локально именованными полями, эквивалентные структурам традиционных языков.

Также нужно проанализировать возможные коллизии, возникающие при множественном наследовании, и определить целесообразность использования множественного наследования.

Go-полиморфизм
~~~~~~~~~~~~~~~~~

Особенностью реализации полиморфизма в языке программирования Go является применение интерфейсов для обобщения поведения отдельных структур данных, не связанных между собой. В отличие от наследования для обобщаемых структур отсутствует общий родитель, что напоминает объединение, используемое в процедурных языках программирования, не поддерживающих полиморфизм. Интерфейс собирает воедино функции, связанные с типом, без указания этого типа. Экземпляр интерфейса может объявляться в качестве переменной к которой может быть подсоединена любая структурная переменная. Это соединение осуществляется в том случае если структурная переменная является связанной для всех функций, указанных в интерфейсе. Так как при создании интерфейса и после этого нигде не оговаривается состав допустимых структур, разработчик может создавать любую новую структуру и создавать для ее обработки произвольные функции связанные с типом этой структуры. Тем самым обеспечивая в любой момент возможность привязки к любому интерфейсу.

По сути интерфейс является обобщением относительно разнообразных типов данных с указанием того, какие обработчики специализаций должны присутствовать у этого типа данных. Отсутствие родителя позволяет эволюционно подключать новую структуру в других пакетах, обеспечивая тем самым эволюционное расширение альтернатив. При добавлении новой функции, связанной с типом возможно формирование нового обобщения за счет создания соответствующего интерфейса. 

К достоинствам подхода можно отнести гибкое добавление новых несвязанных структур и обеспечение их разнообразного объединения вокруг общих функций обработки за счет создания множества соответствующих обобщающих интерфейсов на все случае жизни. Нет жесткой зависимости специализаций от обобщения, как это происходит при наследовании, когда все специализации выстраиваются от одного родителя. Следует правда отметить, что при необходимости в традиционных ОО языках можно отдельно формировать основы специализации, которые включаются в дальнейшеем в производные классы, формируемые от разных базовых классов. Однако это уже не прямое решение а моделирование интерфейсов Go.

Среди недостатков данного подхода можно отметить возможность автоматического включения тех процедур, которые нежелательно было бы иметь в общем списке, так как включение осуществляется по имени функции. 

Возможный вариант использования Go-полиморфизма в ЯФППП
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Синтаксически данный подход в ЯФППП реализовать достаточно просто. Пусть имеется множество типов ``T1, T2, ..., Tn``, которое и в дальнейшем может расширяться. Каждый из этих типов объявляется в качестве аргумента, связанного с функцией во множестве функций ``F1, F2, ..., Fk``. Этот аргумент, как и в случае ОО-полиморфизма можно связать с именем при описании функции. Остальные данные передаеются как параметры обычной функции. Описание функции, связанной с типом будет выглядеть следующим образом::

    F(@T) << funcdef x@W->@Q ...

Любое подмножество функций, связанных с типом можно завернуть в создаваемый интерфейс. Слово ``interface`` в случае ЯФППП получается не совсем к месту. Вместо него предлагается использовать нейтральное ключевое слово ``group``, которое показывает группировку воедино множество функци с со связанным аргументом одного типа в группу. Тогда формируемую группу для заданных типов и функций можно описать следующим образом::

    Gi << group { 
        Fj @Wj->@Qj, 
        Fl @Wl->@Ql, 
        ..., 
        Ft @Wt->@Qt
    }

То есть, собираем в группу требуемые функции для каждой из связанных структур, которые их имеют.

Сами функции (Fj...) являются функциями, связанными с конкретными типами данных. Связанный аргумент задаетс в описании функции (в круглых скобках после ее имени). Тип результата указывается для того, чтобы исключить те функции, которые формируют разный тип результата при одинаковой сигнатуре и, следовательно, не могут быть включены в группу.

Помимо этого, в отличие от Go, предлагается ввести ограничитель, который контролирует типы данных, допустимых для использования в группе, его можно задать путем перечисления допустимых альтернатив следующим образом::

    V << union { Ti, Tj, ..., Tk }

Тогда группа с ограничителем может выглядеть следующим образом::

    Gi << group { 
        Fj->Qj, 
        Fl->Ql, 
        ..., 
        Ft->Qt
    } V

или::

    Gi << group { 
        Fj->Qj, 
        Fl->Ql, 
        ..., 
        Ft->Qt
    } union { Ti, Tj, ..., Tk }

Применение данного механизма осуществляется следующим образом. В ходе вычислений формируется величина, имеющая тип специализации, входящей в группу, которая является связанным аргументом функции. В соответствии с типом этой величины, подключенной к группе, запускается требуемый обработчик специализации. Подключение к группе осуществляется путем использования имени группы в качестве функции над этой величиной. Повторное подключение осуществляется за счет вызова в другом месте или за счет рекурсивного вызова функции с другим аргументом.
Пример того, как это может выглядеть::

    IntPair << typedef @(2@int)
    RealPair << typedef @(2@real)
    lt(@IntPair)  << funcdef @signal->@bool { x:<:return }
    lt(@RealPair) << funcdef @signal->@bool { x:<:return }
    cmpGroup<< group {lt->@bool}

Где-то в далекой галактике::

    a@int<< ...
    b@int<< ...
    ...
    t<< (a,b):cmpGroup; // или t<< (a,b):IntPair:cmpGroup;
    b<< .:lt(t);
    ...

Вариант с пустой группой
""""""""""""""""""""""""""""

В Go допускается создавать интерфейсы без функций, связанных с типом. В этом случае они используются для привязки любой структуры в качестве альтернативы с динамической фиксацией типа этой альтернативы. В результате, как и в случае процедурного подхода (или в языках с динамической типизацией) можно явно проверить тип привязанного артефакта и выделить его для выполнения операций.
Чем-то это напоминает объединение языка программирования Ada, в котором тип хранимой альтернативы также формируется автоматически, что повышает надежность по сравнению, например с вариантными записями Паскаля или объединением в Си. 

Вместе с тем вряд ли имеет смысл создавать такие интерфейсы вручную, так как для любых данных достаточно одного такого интерфейса. В случае Smile предлагается создать встроенную группу с именем any, которая по умолчанию трактуется как следующее описание::

    any<< typedef group{}

Привязка любой величины к группе осуществляется также, как это было описано выше. Например::

    anyGroup<< (a,b):any...

Для выполнения операций можно проверить предварительно тип, используя традиционное действие и явное сравнение типов во время выполнения::

    b<< (anyGroup:type, IntGroup):=...

После чего, зная правильный тип можно выделить артефакт из группы, осуществляя явным образом корректное приведение, проверяемое компилятором, и вполнить допустимую операцию. Например::

    anyGroup:IntPair:+...

Подобный прием практически эквивалентен использованию обобщений в традиционных процедурных языках программирования.

.. note::
    Аналогичным образом имеет смысл рассмотреть тип any для ОО-полиморфизма и ПП-полиморфизма.

Возможные проблемы использования Go-полиморфизма в ЯФППП
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

В целом пока не видно никаких особых проблем с реализацией описанного механизма. По сравнению с наследованием все выглядит даже гораздо проще и логичней. Вместе с тем пока непонятно, во что выльется реализация ряда дополнительных фич. Также, в связи со слабой пока изученностью мною реализации этого механизма в Go, не ясно что из этих дополнительных возможностей и как реализовано. В частности можно отметить следующие варианты, которые возможно (для расширения кругозора) потребуют более тщательного изучения возможностей Go:

#. Проверка типа значения, включенного в группу.
#. Возможность неявного переноса значения из одной группы в другую.

Первое уже было изучено и работает достаточно просто. Помимо этого естественно имеется возможность выделения значения данного типа из группы для проведения над ним манипуляций с использованием обычных функций. Может оказаться полезным, когда требуемая функция не входит в соответствующую группу (или вообще не входит ни в какую группу). Реализация данной возможности (проверка типа и выделение значения) в общем-то не должно вызвать каких-либо проблем.

Возможность неявного переноса из группы в группу можно представить примерно так: ``X:G1:G2``.
Это довольно интересная вещь пока не изучена на примере Go. Нужно узнать, есть она или нет в этом языке программирования и в каком виде. Пока думается, что скорее всего нет. Идея заключается в том, чтобы, при наличии совместимости значения, находящегося в одной группе просто перенести его в другую группу без проведения дополнительных явных проверок. Проблема в том, что полиморфное хранение элементов в группе не позволяет знать на этапе компиляции тип значения, так как он формируется во время исполнения. Следовательно, возникновение некорректной систуации не позволяет просто реализовать данный механизм. Необходимо либо выбрасывать исключение, или каким-то другим образом сигнализировать о том, что операция корректно не выполнилась
Как дополнительный вариант: перед выполнением данной операции можно осуществить проверку эквивалентности групп или явную проверку типа хранимого аргумента, или выделение хранимого аргумента с явным занесением в другую группу, возможно, с предварительной явной проверкой типа. Последнее - это традиционное прямое решение, которе идет помимо полиморфизма и поэтому смотрится не очень хорошо. Но и выбрасывания исключения тоже как-то не хотелось бы.

Процедурно-параметрический полиморфизм
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Процедурно-параметрический полиморфизм, в отличие от представленных выше двух вариантов базируется на постоянстве типа обобщения, а специализации рассматриваются в качестве расширения обобщения. Поэтому речь идет не о построении нового типа данных, а о формировании дополнительных специализаций на основе уже существующего обобщающего типа.

Если говорить об особенностях данного подхода, то он изначально ориентирован на реализацию полиморфизма именно в процедурных языках с возможностью эволюционного расширения как процедурно-параметрических обобщений, так и обработчиков специализаций, добавляемых в обобщающую параметрическую процедуру. Данный метод хорошо ложится на традиционные императивные и (в какой-то степени) функциональные языки программирования, обеспечивая поддержку безболезненного расширения кода даже в случае множественного полиморфизма, что также отличает его от двух выше представленных подходов, напрямую поддерживающих только одиночный полиморфизм (от одного аргумента или объекта).

В целом подход достаточно хорошо описан в различных статьях, показана его гибкость по сравнению с ОО и процедурным подходами на примере простых ситуаций и в случае реализации аналогов патернров проектирования. Учитывая то, что он является нашим ноу-хау, более подробное описание особенностей буду добавлять по мере необходимости.

Возможный вариант использования процедурно-параметрического полиморфизма в ЯФППП
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Основная идея подхода - гибкое расширения в случае мультиметодов здесь не совсем подходит, так как каждая функция может обрабатывать только один полиморфный аргумент. Поэтому первоначально имеет смысл рассмотреть ситуацию только для одного аргумента, а дальше куда кривая выведет. В этой ситуации обобщенный тип, которые будет расширяться в дальнейшем специализациями можент объявляться следующим образом::

     U << typedef ОписаниеТипа+

В данном случае знак ``+`` показывает, что это не обычный тип, а тип, который впоследствии будет расширяться альтернативными специализациями. В качестве специализаций могут выступать ране определенные типы ``T1, T2, ...`` Следует отметить, что описание типа может отстутсвовать. Тогда вместо аналога обобщенной записи будет формироваться пустое процедурно-параметрическое обобщение::

     U << typedef +

Как вариант, и в первом и втором случае при его создании сразу могут быть включены одна или несколько специализаций. Например::

     U << typedef ОписаниеТипа+(T1, T2)

Возможна идентификация специализаций не по типам, а по признакам, которые можно вводить как обозначения:

     U << typedef ОписаниеТипа+union(a<<T2, b<<T2, c<<T2)

Предполагается что идентификация первоначального параметрического обобщения будет осуществляеться по его имени, как и для любого другого типа. Однако в ходе расширения программ обобщение может быть расширено, что требует введения специальных описателей и дополнительнго представления в репозитории. Или модификации в репозитории уже существующего обобщения, что в принципе тоже может оказаться допустимым, хоть и не поддерживает прямого эволюционного расширения обобщений. Нужно подумать...
Раcширение обобщения может выглядеть следующим образом::

    U + (T3, T4)

или::

    U + (d<<T3, e<<T2)

в зависимости от того, каким образом была сделана идентификация специализаций в исходном обобщении. 

**Возможная проблема: как идентифицировать специализации в репозитории?**

Для идентификации специализаций в репозитории возможны различные варианты:

#. При добавлении очередной группы специализаций в обобщение можно просто изменить в репозитории описание этого обобщения, сформировав его более общую структуру, учитывающую все введенные специализации. То есть организовать непосредственное связывание в процессе компиляции с изменением экспорта.
#. Другой вариант может быть связан с расщеплением на отдельные компоненты всех вводимых специализаций обобщения с сохранением для самого обобщения его вида без специализаций, даже если при первоначальном описании специализации были включены. В этом случае записи в репозитории идентифицируются по имени типа обобщения плюс имя признака. При идентификации специализаций по типу имя признака будет совпадать с именем типа. Например::

    U(T3), U(d)

При описании обобщающих функций обобщение задается в качестве связующего аргумента после имени функции. В отличие от ОО-полиморфизма и Go-полиморфизма вместо круглых скобок предполагается использовать квадратные. Например::

    F[@U] << funcdef x@W->@Q        // обобщающая функция
    F[@U(d)] << funcdef x@W>@Q      // обработчик специализации

Предполагается, что как и при процедурно-параметрическом программировании возможна пустая обобщающая функция или обобщающая функция описывающая обработчик по умолчанию (при отстутствии соответствующего обработчика специализации).

Отличительной чертой ПП-полиморфизма является поддержка множественного полиморфизма, допускающего использование нескольких обобщенных параметров::

    F[@U1, @U2] << funcdef x@W->@Q           // обобщающая функция
    F[@U1(d),@U2(T1)] << funcdef x@W>@Q      // обработчик специализации

Применение обработчиков обобщений осуществляется аналогично использованию ранее рассмотренных подходов. Конкретные специализации задаются в квадратных скобках после имени функции, обычные аргументы поступают на вход этой функции как аргументы оператора интерпретации. Пример::

    figure<< typedef +
    triangle<< @(a<<@int,b<<int,c<<int)
    rectangle<< @(x<<@int,y<<@int)
    figure+(t<<triangle,r<<rectangle)
    ...
    Area[@figure]<<funcdef @signal->@real 
    Area[t<<@triangle]<<funcdef @signal->@real {...}
    Area[r<<@rectangle]<<funcdef @signal->@real {...}
    ...
    T@figure<< ...
    s<< .:Area[T]
    ...
    
Специфической особенностью процедурно-параметрического подхода также является отсутствие полиморфного типа. То есть, типа any, объединяющего непонятно какие значения. Каждый тип, включая обобщение, всегда точно известен. Однако в обобщениях существуют специализации, тип которых можно определить явным образом. Поэтому операция type (м.б обозвать иначе?) применяется к определению типа специализации с возвращением признака. Дальнейший доступ к специализации с известным типом осуществляется по имени ее признака.

Пример::

    (T:type, triangle):=

... не закончено.

Сравнительный анализа рассмотренных подходов
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Восприятие и простота использования
""""""""""""""""""""""""""""""""""""""

Возможность реализации
""""""""""""""""""""""""""

Поддержка множественного полиморфизма
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

При традиционной интерпретации непосредственную поддержку множественного полиморфизма обеспечивает только процедурно-параметрический полиморфизм. Использование наследования и Go-подход с использованием полиморфизма позволяют формировать только монометоды, реализуя мультиметоды через диспетчерезацию (в данном случае прямую проверку типов не рассматриваем, так как речь идет о полиморфизме). Специфика ЯФППП заключается в том, что наличие у фунции только одного аргумента не позволяет напрямую задать мультиметод. Поэтому в данной ситуации процедурно-параметрическая парадигма по реализации мультиметодов становится аналогичной остальным рассмотренным подходам (то есть обеспечивает аналогичную реализацию за счет диспетчеризации), если не вносить дополнительных средств инструментальной поддержки.

В любом из представленных вариантов реализация мультиметода выливается в создание дополнительных типов, обеспечивающих группировку нескольких полиморфных аргументов. Для различных подходов это можно рассмотреть на общем примере для двух аргументов. Пусть это будет геометрические фигуры: круг и прямоугольник.

Реализация мультиметода в ЯФПП при использовании наследования
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Реализация мультиметода в ЯФПП при использовании Go-подхода
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Реализация мультиметода в ЯФПП при использовании процедурно-параметрического полиморфизма
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""


Целесообразность совместного использования различных подходов
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

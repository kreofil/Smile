.. |date| date:: %d.%m.%Y
.. |time| date:: %H:%M
.. |copy| unicode:: 0xA9 .. copyright sign

.. Текущая дата |date| и время |time|

.. meta::
   :description: Описание концепций, языковых и инструментальных средств функционально-потокового параллельного программирования.
   :keywords: парадигмы программирования, функционально-потоковое параллельное программирование

:Author:    Александр Легалов
:Email:     <legalov@mail.ru>
:Date:      |date|
:Version:   0.0

:Copyright: |copy| Пока это драфт для внутреннего обсуждения.

.. sectnum::
    :start: 1

.. contents:: Содержание
    :depth: 4


=============================================
Заметки по поводу функций в Smile
=============================================

В принципе в любом языке программирования сейчас можно говорить о функциях как отображении аргумента в результат::

    Y = F(X)

Дополнительные рассуждения могут касаться использования параметрического полиморфизма, связанного с перегрузкой имен функций за счет различия в сигнатурах. В Smile пока не планируется использовать этот полиморфизм. То есть, предполагается, что обычные функции будут отличаться по именам.

Вместе с тем большинство современных языков поддерживают динамический полиморфизм, который, как в объектно-ориентированных языках, может быть реализован на основе наследования и виртуализации. Помимо этого можно использовать Go-подход или процедурно-параметрический полиморфизм. Предполагается, что какой-то из вариантов будет внедрен после анализа каждого из перечисленных.

На текущий момент предполагается реализация обычных функций. После их отработки планируется перейти к последующим реализациям.

Синтаксис определения обычной функции
---------------------------------------

Обычная функция описывается следующим синтаксическим правилом::

    Функция = funcdef 
        [ [ИдАргумента]@ИмяТипаАргумента ] "->" @ИмяТипаРезультата
        (ТелоФункции | ";").
    ТелоФункции = "{" СписокОператоров "}".

Отсутствие тела функции предполагает, что на данном этапе мы имеем дело с предварительным ее объявлением, обеспечивающим формирование протототипа. Вместо тела в этом случае ставится ``";"``, которая завершает описание. Этом может оказаться полезным при рекурсивных вызовах, когда, в случае взаимной рекурсии одна из компилируемых функций еще не прошла компиляцию из-за отсутствия полного определения другой. То есть данный подход предполагает исключить из языка явные предварительные описания, такие как ``prefunc`` в Пифагоре.
Копиляция неполных определений обеспечивает создание экспортируемых описаний, которые заносятся в таблицу экспорта. Поэтому последующая компиляция функции, вызывающую неполно определенную функцию проходит без проблем.

Необязательность идентификатора аргумента предполагает использование вместо в него в теле специального зарезервированного имени аргумента, обозначаемого как ``"_"``. В принципе этот идентификатор может использоваться одновременно и с именем аргумента, заданным явно. То есть, идентификатор аргумента выступает в роли алиаса для заданного имени.

Если описание аргумента отсутствует, то это предполагает, что в его качестве выступает запускающий функцию сигнал (функции без параметров вообще в Smile, как и в Пифагоре отсутствуют). То есть, по сути данный вариант предполагает, что заголовок функции будет эквивалентен следующему::

    funcdef ->@T == funcdef @signal->@T


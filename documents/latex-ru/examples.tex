\chapter[Примеры функций]{Примеры функций на языке программирования Smile}
\label{examples}

В разделе представлены примеры функций. Они являются иллюстрацией различных возможностей языка. Помимо этого данные примеры также являются основой для тестирования компонент компилятора и системы программирования. Предполагается что эти примеры будут находиться в наиболее актуальном состоянии, изменяясь в первую очередь по ходу коррекции синтаксиса и семантики языка программирования. Примеры функций предполагается разделить по тематически подразделам, связанным с представлением различной функциональности.

Возможны также дополнительные комментарии, обеспечивающие привязку к различным публикациям.

\section{Примеры на использование динамически изменяемого асинхронного параллелизма}
\label{examples:stream}

Первоначально эти примеры были представлены в статье~\cite{dyn-ru, dyn}. С течением времени произошло изменение как синтаксиса, так и семантики для некоторых используемых там конструкций. Ниже примеры представлены с использованием актуальной трактовки.

\debate[Примечание]{На текущий момент модификация примеров связана с их подготовкой в рабочему семинару Хуавей в Сочи (19-20 октября 2023 г.).}

\subsection{Использование потоков}

Потоки являются экземплярами соответствующих абстракций. По своей сути экземпляры потоков являются активными объектами, которые могут асинхронно заполняться данными, поступающими из различных функций выполняемой программы. То есть, поток является некоторым общим ресурсом, который не подходит под концепцию функционального программирования. Однако, с другой стороны, нельзя говорить о каждом отдельном потоке как об ограниченном ресурсе, так как поступление в него данных не связано с ресурсными ограничениями. Каждый вновь поступающий элемент <<находит>> место для своего размещения в очереди элементов, формируемой в порядке поступления во времени.

Такая концепция потока, представляющего единый неограниченный ресурс, определяет свою специфику взаимодействия с ним различных функций программы. Они не могут напрямую модифицировать поток, за исключением только операций, связанных с добавлением в поток новых данных. Поэтому множественные взаимодействия осуществляются через ссылки на поток. Каждая такая ссылка обеспечивает определенные перемещения, осуществляя тем самым доступ к элементам потока. По сути операции с потоком во многом напоминают упрощенные операции с файлами, доступ к которым осуществляется через дескрипторы файлов или указатели на файлы.

\debate[Примечание]{Поэтому необходимо ввести описание потоков и описание ссылок на потоки. Использование ссылок, на мой взгляд, формирует более простую концепцию взаимодействия по сравнению с использованием порождения дочерних потоков и наследования в них вновь поступающих данных. Так как внутри потоков запрещена модификация данных (только добавление), то это позволяет достаточно просто организовать доступ, выделив добавление данных в поток как отдельную и общую для него операцию.}

Доступ к данным, расположенным в потоке, может осуществляться через ссылки с использованием как одиночной, так и массовой операции интерпретации. В первом случае применяются функции над потоком как активном объектом. Во втором случае используются эквивалентные преобразования массовой операции интерпретации в набор одиночных операций с использованием скрытой от программиста семантикой этих преобразований.

\subsubsection{Операции, выполняемые над потоком}

\debate[Примечание]{Скорее всего операции над потоком будут перенесены в описание семантики потоков. Куда --- нужно будет разобраться...}

Непосредственно на потоком, как объектом данных, выполняется только функция добавления в него нового элемента. При этом поток может быть определен через предварительное описание или непосредственно в программе через именование. Например, описание потока целых через предварительное задание как в функции, так и в глобальном пространстве может выглядеть следующим образом:
\begin{verbatim}
    S1@int<[]
\end{verbatim}

Для добавления данных в такие потоки используется специальна операция \verb|push|. Она осуществляет занесение элемента в поток с заданным именем. Эта же операция может использоваться для занесения в поток данных через связанную с ним ссылку. По сути ссылка на поток эквивалентна потоку. Однако над ней можно выполнять операции, связанные с перемещением по элементам потока и чтению данных. Операция \verb|push| может применяться над любым объявленном потоком, имеющим имя и не имеющим дополнительных точек входа. Поток должен находиться в области видимости выполняемой операции. Потоки подобного типа можно считать потоками с внешним доступом. Сигнатура функции, реализующей эту операцию имеет следующий вид:
\begin{verbatim}
    push << func (any, any<[]) -> bool
\end{verbatim}
Порождаемой функцией значение информирует о корректности выполнения операции, которая, в силу своей асинхронности, может осуществляться за неопределенное время. Это подтверждение имеет значение \verb|true| при успешной записи элемента в поток или \verb|false|, если запись не прошла или прошла с ошибками. Данный результат можно использовать для анализа выполнения функции или игнорировать.

\debate[Примечание]{Связь ссылки с потоком --- специальная операция над ссылками, которая должна быть описана ниже.}

Другой способ задания потоков связан с генераторами их данных, размещенных непосредственно внутри их описания. Размещение генераторов поступающих данных внутри потока локализует источники их доступа. Количество таких генераторов задается при описании потока. Примером такого потока с несколькими точками порождения данных, можно считать следующую конструкцию.
\begin{verbatim}
    S2@<[a, b, c]
\end{verbatim}
где \verb|a, b, c| должны порождать элементы одинакового типа. Эти потоки, в зависимости от типа элементов фиксируют их число (в данном случае три элемента). Однако порядок их поступления не фиксируется. Добавление новых значений в подобные потоки также не допускается. Также не допускается доступ из вне с использованием операции \verb|push|. Однако, если внутри подобных потоков определены генераторы данных, то число элементов в них также может меняться.

\debate[Примечание]{Возникает соблазн добавить \texttt{push} к потокам с внутренними генераторами. Но пока воздержусь. Окончательное решение возможно будет принято в ходе реализации потоков и возможностей каждого из механизмов. Может быть будет даже проще отказаться от одного из вариантов из-за дублирования. Какого --- пока не знаю...}

Ссылки используются для взаимодействия с потоками. Это взаимодействие выливается в чтение элементов в порядке их поступления, переключение на следующий поступивший элемент после обработки текущего. В связи с асинхронностью поступления элементов операции отката или произвольного доступа не реализованы. Но они могут быть реализованы с использованием роя. Связь ссылки с потоком осуществляется с по принципу единственного присваивания, а также с применением при этом разыменования. То есть, можно специально не указывать операцию связывания ссылки с конкретным потоком, осуществив только необходимую подстановку вместо ссылки потока при передаче параметров или указав связываемый поток через именование ссылки. Например:
\begin{verbatim}
    X@<[]
    refX@<[*] << X
    refY@<[*] << S2
\end{verbatim}

Через ссылки с потоками возможно выполнение следующих функций:
\begin{itemize}
    \item функция \verb|get|, осуществляет чтение элемента из потока;
    \item функция \verb|is|, предназначенная для проверки на завершение поступивших элементов и отсутствии (empty) поступления новых (конец данных в потоке);
    \item функция \verb|pop|, сдвигает ссылку на один элемент потока, имитируя при этом выталкивания головного элемента из потока.
\end{itemize}

\textbf{Чтение элемента из потока} производится функцией \verb|get|, которая имеет следующую сигнатуру:
\begin{verbatim}
    get << func any<[*] -> any
\end{verbatim}
где \texttt{any} - ключевое слово, обозначающее любой тип. В каждом конкретном случае тип элементов потока определяется его описанием. Функция возвращает значение элемента, первым поступившего в поток. Состояние самого потока при этом не изменяется. Если такой элемент еще не сформировался, функция \texttt{get} ожидает его поступления. При наличии в очереди потока нескольких элементов выбирается только один, поступивший в поток первым. При обращении к опустевшему потоку порождается ошибка \verb|EMPTY_ERROR|.

Возможность некорректного обращения к опустевшему потоку требует, перед доступом к нему, осуществить предварительную проверку на наличие в нем элементов (по аналогии с проверкой признака конца файла). Это также обуславливается тем, что количество элементов, которые порождает поток, может быть заранее неизвестно. Проверка потока на то, что данные в нем еще порождаются осуществляется функцией \texttt{is}, имеющей следующую сигнатуру:
\begin{verbatim}
    is << func any<[*] -> bool
\end{verbatim}
Функция возвращает булево значение \texttt{true}, если поток еще может формировать данные или уже содержит их. В противном случае возвращается \texttt{false}.

Перед тем как прочитать из потока следующий элемент необходимо убрать уже прочитанный. Для этого используется функция \texttt{pop}.
При попытке выполнить эту функцию для ссылки достигшей конца потока формируется ошибка  \verb|EMPTY_ERROR|. Функция имеет следующую сигнатуру:
\begin{verbatim}
    pop << func any<[*] -> any<[]
\end{verbatim}
То есть, функция возвращает модифицированную ссылку уже без обработанного элемента, что полностью соответствует принципу неизменности (immutable), свойственному языкам функционального программирования.

\subsubsection{Суммирование элементов, поступающих в поток}

В качестве примера использования функций работы с потоком можно рассмотреть нахождение суммы элементов:

\begin{verbatim}
    sum << func X@float<[*] -> float {
        isEmpty << X:is:not;
        isEmpty^({(X:get,X:pop:sum):+}, 0.0):return
    }
\end{verbatim}
Проверка \texttt{X:is} порождает булевское значение \texttt{true/false}, которое используется одиночным оператором интерпретации в качестве селектора. В связи с тем что булево значение \verb|true| соответствует 1, а \verb|false| эквивалентно 1, первым в селекторе вариантов продолжения вычислений должно располагаться ложное значения. Для придания общепринятого порядка в примере используется инверсия результата определения заполненности потока (функция \verb|not|). Поэтому при истинном значение выбирается первый (нулевой) элемент кортежа, запускающий левую рекурсию для функции sum. Значение \texttt{false} формируется, когда поток завершен. В этом случае возвращается значение \texttt{0.0}. При обратном ходе рекурсивного процесса осуществляется суммирование элементов.

\subsubsection{Занесение информации в поток из различных источников}

В представленном выше примере суммирования элементов потока по сути реализована левая последовательная рекурсия, так как накопление суммы осуществляется при обратном ходе путем сложения очередного элемента потока с накопленным промежуточным значением. В работе~\cite{aslist-2006} показано, что асинхронный список через последовательные рекурсивные вызовы позволяет реализовать суммирование, параллелизм которого изменяется в зависимости от временных соотношений между интенсивностью поступления данных и скоростью их обработки. Теоретически он может быть эквивалентным каскадной свертке. Использование потоков в языке программирования Smile позволяет написать аналогичную функцию. При этом наличие возможности создавать наполняемые хранилища обеспечивает компактное занесение в поток не только исходных данных, но и промежуточных результатов. Соответствующая функция суммирования значений, поступающих в поток, выглядит следующим образом:
\begin{verbatim}
  // Асинхронное суммирование элементов потока
  // с внесением в него результатов промежуточных вычислений
  sum << func X@float<[*] -> float {
    // Проверка, что данные в поток еще могут поступить
    isEmptyFirst << X:is:not;
    isEmptyFirst^(
      {block{ // Первый элемент есть
        a << X:get; // Элемент выбирается из потока
        Y << X:pop; // Убирается первый элемент создается новая ссылка
        isEmptySecond << Y:is:not; // Проверка наличия второго элемента
        notEmptySecond^(
          {block{
            // При наличии его можно сложить с первым,
            // который вытолкнуть из потока.
            // После чего втолкнуть в него результат сложения
            // и снова вызвать сумму
            ((a, Y:get):+, Y):push; // И переслать в тот же поток через Y
            // Также создать новую ссылку без второго элемента
            // и рекурсивно продолжить вычисления
            Y:pop:sum:break     // выход из блока
          }},
            // В противном случае в потоке только один элемент,
            // значение которого и является суммой
            a
        ):break
      }},
        // При отсутствии данных возвращается 0
        0.0
    ):return
  }
\end{verbatim}
В этой ситуации функция, при наличии хотя бы двух элементов в потоке, суммирует их. Полученная сумма через ссылку пересылается в этот же поток. Процесс рекурсивно повторяется для вновь поступающих элементов, чередующихся с промежуточными вычислениями сумм до момента, когда в потоке останется только одна величина, которая и является окончательной суммой.

\subsubsection{Недетерминированное поведение потока при выполнении асинхронных вычислений}

Использование потоков, позволяет организовывать асинхронные вычисления с динамически изменяемым параллелизмом, зависящим от временных соотношений между интервалами поступления данных в поток и скоростью их обработки функциями, взаимодействующими с потоком. Однако высокая вероятность того, что порядок поступления аргументов не будет совпадать с порядком получения результатов на выходе, не позволяет во многих случаях организовать детерминированные и предсказуемые вычисления. В качестве такого примера можно рассмотреть вычисление массива данных, поступающих из входного потока, а после обработки направляющихся в выходной поток. Пусть для вычислений используется формула:
\begin{verbatim}
    y[i] = sin(x[i])*sin(x[i])+cos(x[i])*cos(x[i])
\end{verbatim}
При использовании потоков в качестве промежуточных хранилищ результатов без особых сложностей организуются конвейерные вычисления (при соответствующих временных соотношениях). Однако, в связи с возможным отличием времени выполнения функций над элементами потоков, корректные последовательности значений в результирующем потоке могут быть не получены. Эта ситуация может быть описана следующим кодом:

\begin{verbatim}
  SumSin2Cos2Stream << func X@float<[*] -> float<[] {
    result@float<[];
    (X, result):GetStreamResult >> ok;
    result:ok:return
  }
\end{verbatim}
где:
\begin{verbatim}
  GetStreamResult << func (arg@float<[*], result@float<[*])->signal {
    // Проверка потока на возможное поступление данных
    isEmpty << arg:is:not;
    isEmpty^(
      // Занесение результата в выходной поток
      // после добавления в него данных
      {block {
        x << arg:get;    // Получение элемента из потока
        s << x:sin; Sin2 << (s,s):*; // Синус в квадрате
        c << x:cos; Cos2 << (c,c):*; // Косинус в квадрате
        // Вычисление текущего значения с передачей в выходной поток
        ((Sin2,Cos2):+, result):push;
        // Убирается обработанный элемент из потока
        // и переход к обработке следующего элемента
        (arg:pop, result):GetStreamResult}:break
      },
      // Сигнал без заполнения результата,
      // если данные в поток больше не поступают
      !
    ):return
  }
\end{verbatim}

Функция \texttt{SumSin2Cos2Stream}, получает данные из входного потока через ссылку \texttt{X}. Результат вычислений через ссылку на поток возвращается из функции. Сам поток реализован внутри функции через хранилище \texttt{result}, а накопление в нем результатов вычислений происходит в функции \texttt{GetStreamResult}, в которую он передается в качестве параметра. Передача потока в качестве результата по значению предполагает его копирование во внешнюю среду аналогично тому, как осуществляется передача по значению в современных языках программирования. Возможна также передача по ссылке, если требуется сделать выходной поток внешним хранилищем.

Функция \texttt{GetStreamResult} производит основные вычисления для первого текущего элемента, поступившего во входной поток. Полученное значение суммы передается в поток с использованием функции \texttt{push}). Одновременно с этим происходит рекурсивный вызов функции \texttt{GetStreamResult}, в которую ссылка на входной поток передается уже без учета первого аргумента. Блок \texttt{block} используется для локализации группы операторов, из которой только один возвращает результат посредством выполнения функции \texttt{break}. Данные в блок поступают через имена, описанные вне его.

При передачи результатов вычислений в новый поток порядок поступления элементов может изменяться относительно первоначального потока, что ведет к появлению недетерминированности вычислений и некорректному результату за счет изменения порядка элементов. Пример показывает, что необходимо расширить модель вычислений конструкциями, обеспечивающими сохранение порядка следования данных и при этом поддерживающие асинхронные взаимодействия.

\subsubsection{Применение массовой операции интерпретации с потоками}
При использовании массовой операции интерпретации осуществляется обработка всех элементов потока до тех пор, пока не сформируется признак завершения потока. Специальна проверка на завершение потока в данном случае не нужна. Результатом вычислений массовой операции интерпретации, в соответствии с ее семантикой, является выходной поток.

Например, вычисление функции \texttt{sin} над всеми элементами входного потока \texttt{X} с формированием на выходе потока \texttt{Y} на языке Smile можно записать следующим образом:
\begin{verbatim}
    X::sin >> Y ,
\end{verbatim}
где поток \texttt{X} предварительно описан следующим образом: \verb|X@float<[]|. Символ \texttt{@} отделяет имя используемой сущности от ее типа. Автоматически формируемый на выходе поток имеет такой же тип, что и тип результата функции \texttt{sin} которая определяется сигнатурой:
\begin{verbatim}
    sin << func float -> float
\end{verbatim}
При этом порядок формирования результатов в выходном потоке, обозначенном через \texttt{Y} может отличаться от порядка поступления аргументов в поток \texttt{X}.

Потоки могут передаваться в функции в качестве параметров. Функция вычисления синуса для всех элементов потока в Smile будет выглядеть следующим образом:
\begin{verbatim}
    sinStream << func X@float<[] -> float<[] {
        X::sin:return
    }
\end{verbatim}

\debate[Примечание]{\textbf{\textit{Кстати. Имеет смысл подумать о реализации простого текстового терминала на основе роя...}}}

\section{Использование роя для организации асинхронных вычислений}

\subsection{Организация упорядоченных данных с сохранением порядка следования}

Для сохранения порядка следования при обработке данных необходимо использовать контейнерные типы, обеспечивающие асинхронное формирование отдельных элементов. В ФПМПВ такой сущностью является параллельный список. Однако он поддерживает выполнение только массовых операций над его элементами и не допускает обработки самого списка как единого аргумента. В СТМФППВ вводятся расширения, обеспечивающие поддержку необходимой функциональности. Вместо параллельного списка используется рой, который, наряду с массовыми операциями, как и поток, допускает свое использование в качестве единственного аргумента % (рисунок~\ref{pic2}).

%\begin{figure}[h]
%    \centering \includegraphics[width=0.8\textwidth]{pic2.eps}
%    \caption[Обобщенная схема роя и ссылки на него]{General scheme of the swarm and its reference}
%    \label{pic2}
%\end{figure}

Спецификой предлагаемой СТМФППВ и разрабатываемой на ее основе статически типизированного языка ФПП программирования Smile является наличие информации о типах во время компиляции. Это ведет к изменению алгебры эквивалентных преобразований и семантики многих базовых операций, ориентированных не на интерпретацию исходной программы, а на генерацию кода для целевых архитектур. В частности запрещается непосредственная вложенность роев, что облегчает анализ аргументов оператора интерпретации во время компиляции и позволяет определить, является ли функция массовой над всеми элементами роя или это функция над всем роем. Ряд преобразований роя для использования в массовых операциях может происходить уже во время компиляции. Для представления роя используется список из элементов, заключенных в квадратные скобки.

Передача роев, являющихся активными объектам, в функции и возврат их из функций в основном осуществляется, как и для потоков, через ссылки. Синтаксис ссылки на рой в Smile имеет следующий вид:
\begin{verbatim}
    ссылка_на_рой = имя_типа_элементов "[*]".
\end{verbatim}
Используя эти ссылки можно написать следующий вариант функции одновременного упорядоченного вычисления синуса для всех элементов роя с использованием массового оператора интерпретации:
\begin{verbatim}
    sinSwarm << func X@float[]->float[] {
        X::sin:return
    }
\end{verbatim}
В этой ситуации непосредственное использование роевых функций позволяет избавиться от дополнительных преобразований и синхронизации данных как внутри создаваемых функций, так и при их использовании:
\begin{verbatim}
    [0.10, 2.1, 0.33, 1.43]:sinSwarm => [0.0998, 0.8632, 0.324, 0.9901]
\end{verbatim}
Компилятор, анализируя тип аргумента функции \texttt{sinSwarm}, без проблем может распознать, что она принимает весь рой, а не применяется к каждому из его элементов.

\subsection{Использование роя для упорядоченной асинхронной обработки потока}

В отличие от потоков каждый даже частично сформированный рой имеет предопределенный размер. Поэтому его можно вычислить в любой момент, используя функцию \texttt{size}, сигнатура которой описывается следующим образом:
\begin{verbatim}
    size << func any[*] -> int
\end{verbatim}
Например:
\begin{verbatim}
    [10,21,33,43]:size => 4
\end{verbatim}
Нумерация элементов роя, как и вектора, начинается с единицы. Сами элементы роя формируются асинхронно. При этом поступление каждого из них сопровождается выдачей в связанный с ним оператор интерпретации сигнала, информирующего о формировании очередного значения по определенному индексу. Эти индексы можно упорядочить в порядке поступления и, следовательно, осуществить последовательную выборку отдельных элементов по ним. То есть, можно организовать итератор, делающий обход элементов роя по мере их появления. В отличие от обхода элементов потока, в которых обращение идет непосредственно за созданными элементами, в рое ключевую роль играет получение значения индекса. Для его получения предлагается использовать функцию \texttt{get}, которая имеет для роя следующую сигнатуру:
\begin{verbatim}
    get << func any[*] -> int
\end{verbatim}
То есть, возвращается индекс элемента, поступившего в рой первым.

Для перехода к следующему индексу, используется функция \texttt{pop}. Она возвращает новую ссылку на тот же рой но уже без предшествующего индекса:
\begin{verbatim}
    pop << func any[*] -> any[*]
\end{verbatim}
Таким образом можно перебрать все элементы роя в порядке их формирования. В случае, когда через ссылку произойдет перебор всех элементов роя (в порядке их поступления), функция \texttt{get} возвращает \textbf{отрицательное значение индекса}, которое по сути и определяет завершение обхода.

Помимо этого рой, как и поток, может использоваться для последовательной обработки асинхронно поступающих данных с сохранением при этом порядка следования элементов на выходе. Это позволяет переписать функцию нахождения сумм квадратов синусов и косинусов роя таким образом, что она обеспечивает правильную последовательность результатов на выходе:
\begin{verbatim}
    SumSin2Cos2Swarm << func X@float[*]->float[] {
        l << X::size;
        result@float[l];
        (X, result):GetSwarmResult >> ok;
        result:ok:return
    }
\end{verbatim}
Для накопления данных функция использует дополнительное роевое хранилище \texttt{result}, которое заполняется с использованием принципа единственного присваивания. То есть формируется такой код, который позволяет записать данные по одному и тому же индексу не более одного раза. При нарушении этого правила происходит формирование ошибки \verb|SINGLE_ERROR| с прерыванием выполнения программы. Через ссылку хранилище передается в функцию \texttt{GetSwarmResult}, обеспечивающую его заполнение, после чего полученного значение возвращается из функции \texttt{SumSin2Cos2Swarm}. Само вычисление осуществляется в функции \texttt{GetSwarmResult}:
\begin{verbatim}
  GetSwarmResult << func (X@float[*],Y@float[*])->signal {
    i << X:get; // Получение индекса элемента из X
    if << (i,0)<=; // Проверка наличия элементов
    if^(
      {block {
        s << X:i:sin; Sin2 << (s,s):*; // Синус в квадрате
        c << X:i:cos; Cos2 << (c,c):*; // Косинус в квадрате
        // Вычисление текущего значения с передачей в выходной рой
        // по полученному индексу
        ((Sin2,Cos2):+, Y[i]):push;
        // Убирается обработанный индекс из ссылки на рой
        // и переход к обработке следующего элемента
        (X:{i:signal}:pop, Y):GetSwarmResult}:break
      },  // Занесение результата во второй рой
        // Сигнал, формируемый при завершении вычислений без заполнения,
        // если значение индекса = 0
        !
    ):return
  }
\end{verbatim}
Первоначально в данной функции вычисляется индекс первого поступившего в рой \texttt{X} элемента. Если значение не равно 0, то получен очередной индекс, который непосредственно используется для выборки из роя \texttt{i}-го элемента, после чего над ним производится вычисление суммы квадратов синуса и косинуса. Полученное значение заносится через ссылку \texttt{Y} на \texttt{i}-е место. Отличие от занесения элемента потока заключается в том, что для роя дополнительно указывается индекс в квадратных скобках. Вычисления рекурсивно повторяются до полного заполнения хранилища \texttt{result}, передаваемого в данную функцию через ссылку \texttt{Y}.

\debate[Примечание]{Наверное стоит для роя также описать отдельно операции занесения и перемещения, как это выше сделано для потока. Конечно все это нужно будет перенести в семантику языка и добавить простые примеры, демонстрирующие различные ситуации.}

\subsection{Прямое обращение к элементам роя}

Наряду с обработкой элементов роя в порядке их поступления возможен и непосредственный доступ по индексу. В этом случае, если элемент еще не поступил, происходит его ожидание. Во время ожидания можно инициировать выборку других элементов, используя для этого параллельно выполняемые рекурсивные вызовы. Недостатком такого подхода является возможность появления множества параллельных ветвей, ожидающих поступления данных. Однако при обработке данных, поступающих из нескольких роев, такой подход облегчает синхронизацию вычислений. Сигнатура функции доступа по индексу имеет следующий вид:
\begin{verbatim}
    base_function{целое} << func any[*] -> any
\end{verbatim}
В данном случае в качестве функции используется целое число в диапазоне от 1 до размера роя. Если число не попадает в этот диапазон, то возникает ошибка \verb|BOUND_ERROR|, вызывающая прерывание в работе программы.

В качестве примера рассмотрим скалярное перемножении данных, поступающих в два независимых роя. Функция \texttt{ScalMultSignal} осуществляет вычисления, принимая в качестве аргументов эти  два роя через ссылки \texttt{X} и \texttt{Y}. Помимо этого она получает ссылку \texttt{R} на рой, собирающий результаты, а также число, определяющее количество элементов в роях. Последнее используется в качестве индекса для обращения к элементам.
\begin{verbatim}
  //  функция, непосредственно выполняющая скалярное умножение роев
  ScalMultSignal <<
      func (X@float[*], Y@float[*], R@float[*], L@int)->signal {
    if << (L,0):<=;
    if^(
      {block{
        ((X:L, Y:L):*, R[L]):push;
        (X, Y, R, L:--):ScalMultSignal:break
      }},
        // Завершение перебора
        !
    ):return
  }
\end{verbatim}
Перемножение элементов с одинаковыми индексами осуществляется пока передаваемое значение индекса не изменится до нуля операцией <<\verb|--|>>, формирующей значение на единицу меньше предыдущего. Рекурсивный вызов осуществляется сразу же после раскрытия задержки, охватывающей блок, независимо от того, будет или нет выполнена операция умножения.

Окончательная функция предоставляет интерфейс для взаимодействия с другими функциями:
\begin{verbatim}
    // Функция, используемая для перемножения роев.
    // Предполагается, что размер роев одинаков
    ScalMult << func (X@float[*], Y@float[*]) -> float[] {
        L << X:size;
        result@float[L]; // Хранилище результатов
        ok << (X, Y, R, L):ScalMultSignal;
        result:ok:return
    }
\end{verbatim}

\subsection{Конвейеризация асинхронных потоковых вычислений}

Организация взаимодействия функций на основе передачи между ними потоков и роев позволяет организовать вычисления, обеспечивающие одновременное выполнение функций, взаимосвязанных между собой. В качестве примера можно рассмотреть функцию векторного произведения с использованием функций скалярного произведения двух векторов \texttt{ScalMult} и нахождения суммы элементов потока \texttt{sum}:
\begin{verbatim}
  VecMult << func (X@float[*], Y@float[*]) -> float {
    (X, Y):ScalMult:stream:sum:return
  }
\end{verbatim}
Функция принимает два роя, над которыми осуществляется выполнение скалярного произведения. По мере того, как на выходе функции \texttt{ScalMult} формируются результаты перемножения отдельных пар элементов, они поступают в поток, связанный со входом функции \texttt{sum}. Конвейеризация в данном случае формируется автоматически в зависимости от темпа поступления исходных данных и скорости выполнения операций внутри функции \texttt{VecMult}.

\subsection{Асинхронное вычисление факториала}

Представлено конвейерное зацепление при вычислении факториала. Пример для доклада на семинаре Хуавей в Сочи.

Для порождения чисел от 2 до N используется функция \verb|Generator|, порождающая на выходе асинхронно заполняемый поток:

\begin{verbatim}
  Generator << func (first@int, last@int) -> @int<[] {
    data@int<[];
    numbers << (last,first):-; // осталось чисел
    selector << (numbers,0):(<,=,>):?   // (номера истинных значений)
    // Только одно истинное значение из трех вариантов: 0, 1, 2
    (
      true,      // Нет значений - подтверждение успеха
      {
        (first:RndDelay,data):push  // Совпали. Любое в поток.
      },
      {
        // Уменьшение интервала и расчет по новой
        (
          ((first:RndDelay,data), (last:RndDelay,data))::push:and,
          (fist:++, last--, data):Generator
         ):and;
      }

    ) >> ok
    data:return; // Возрат потока, формируемого в ходе вычислений
  }
\end{verbatim}
Для имитации разной скорости передачи данных в поток используется функция \verb|RndDelay| обеспечивающая некоторую задержку во времени с передачей своего аргумента (она не показана). Можно отметить, что выходной параметр данной функции не нужен. То есть, она завершает работу по заполнению потока. Момент завершения ее самой роли не играет. То есть, она похожа на зомби по своему поведению. Отследить ее завершение может ОС по выполнению функции \verb|return|.

Перемножение элементов потока осуществляет до тех пор, пока не будут обработаны все поступившие в него данные.
В результате формируется произведение всех элементов, поступивших поток, включая промежуточные произведения
\begin{verbatim}
  // Асинхронное перемножение элементов потока
  // с внесением в него результатов промежуточных вычислений
  Product << func data@int<[*] -> int {
    // Проверка, что данные еще могут поступить
    isEmptyFirst << data:is:not;
    isEmptyFirst^(
    {block{ // Первый элемент есть
      i << data:get; // Элемент выбирается из потока
      next_data << data:pop; // Следующий элемент стал первым
      isEmptySecond << next_data:is:not; // Есть ли 2-й элемент
      isEmptySecond^(
        {block{
          // Перемножение первого и второго
          // И в тот же поток после имитации задержки
          ((i, next_data:get):*, data):RndDelay:push;
          // Сдвиг и перемножение до получения результата
          next_data:pop:Product:break
        }},
        // В противном случае в потоке только один элемент,
        // значение которого и является результатом
        i
      ):break
    }},
      // При отсутствии данных возвращается 1
      1
    ):return
  }
\end{verbatim}

Окончательная функция собирает вместе два независимых процесса, объединенных между собой потоком, обеспечивающим пересылку между ними асинхронно формируемых данных.
Предполагается, что поток, формируемый генератором передается в поток описанный в данной функции по значению. В принципе возможна реализация, когда эта передача может осуществляться в асинхронном режиме и и по сути являться наложением одного потока на другой.
\begin{verbatim}
    Factorial << func N@int -> int {
        data@<[int];
        (2, N, data):Generator >> ok
        0 >> fall
        data:Product >> result
        (fall, result):ok:return
    }
\end{verbatim}
Формируемое в ходе генерации потока значение об успешности записи в поток используется для дополнительной проверки, что все данные, порождаемые генератором дошли успешно. При успешной генерации на выходе функции формируется результат. В противном случае на ее выходе формируется нулевое значение.
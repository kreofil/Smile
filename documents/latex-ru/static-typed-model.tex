% \part{Использование статической типизации в архитектурно-независимом параллельном программировании}

\chapter[СТМФППВ]{Статически типизированная модель модель функционально-потоковых параллельных вычислений}

\debate[Примечание]{Описывается модель параллельных вычислений, ориентированная на представление динамики поведения при статической типизации. То есть речь идет о статически типизированной модели функционально-потоковых параллельных вычислений (СТМФППВ). Ее отличительной чертой является более эффективная поддержка процесса трансформации программ во время компиляции.
	
\textit{Предполагается, что в данном тексте замечания могут касаться и изменений, вносимых в модель и язык. В ходе дальнейших версий эти замечания будут удаляться.}
}
\section{Базовые принципы}
Статически типизированная модель модель функционально-потоковых параллельных вычислений (СТМФППВ) определяет базовую семантику и динамику поведения статически типизированного языка функционально-потокового параллельного программирования (СТЯФППП) Smile. В отличие от ранее предложенной функционально-потоковой модели параллельных вычислений (ФПМПВ) данная модель ориентирована на применение статической системы типов и фиксированные размерности контейнерных данных, используемых в массовых операциях. Это, в свою очередь, ведет к изменению семантики программо-формирующих операторов. Изменяются также аксиомы модели и ее алгебра преобразований за счет ориентации на период компиляции. Вместе с тем основные характеристики модели, определяющие концепцию архитектурно-независимого параллельного программирования остаются практически неизменными:
\begin{itemize}
	\item вычисления протекают внутри неограниченных ресурсов, что позволяет неявно описывать параллелизм без возникновения ресурсных конфликтов;
	\item управление вычислениями осуществляется по готовности данных;
	\item выбор операций и аксиом, определяющих базовый набор функций, ориентирован на наглядное текстовое представление информационного графа программы при его описании на языке программирования;
	\item модель вычислений определяет общую структуру функционально-потоковой параллельной программы без привязки к операционной семантике, которая может определяться дополнительно, определяя тем самым специфику конкретного языка (подъязыка) функционально-потокового параллельного программирования.
\end{itemize}

Первое требование обеспечивает ресурсную независимость предлагаемой модели, что позволяет описать параллелизм, ограниченный только информационными отношениями между функциями и данными, присущими решаемой задаче. Это сводит перенос разработанной и отлаженной функционально-потоковой параллельной программы на любую вычислительную систему к распределению ресурсов в соответствии с целевой архитектурой. Подобный подход используется также в ряде известных схем потока данных (СПД) [Алгоритмы1982], ориентированных на рекурсивное описание программ, обрабатывающих только один входной поток данных и не поддерживающих их конвейерное продвижение. В связи с отсутствием циклических конструкций граф данной модели является ациклическим.

Использование текстового представления параллельных программ связано с трудностями непосредственного описания информационного графа, что привело к синтаксису языка, несколько отличающемуся от общепринятого. Кроме того, в языке отсутствуют вентили, обеспечивающие условную передачу данных в традиционных СПД [Деннис1972, Arvind1975]. Эти вентили трудно структурировать при текстовом описании программ без использования дополнительной синхронизации информационных потоков.

Отличительной особенностью СТМФППВ является ориентация программо-формирующих операторов на использование статически типизированных вычислений. Это ведет к уменьшению динамических свойств операторов, что облегчает трансформацию в структуры данных, типичные практически для всех современных статически типизированных языков программирования (как императивных, так и функциональных). Подобные модификации, в свою очередь, достаточно сильно изменяет семантику как модели вычислений, так и формируемого на ее основе СТЯФППП Smile.

\debate[Примечание]{Следует отметить, что понятие СТМФППВ не связано только со статической типизацией данных. Как и основная ФПМПВ новая модель предназначена для описания семантики вычислений и организации параллельных процессов. Вместе с тем следует отметить, что использование статической типизации накладывает определенную специфику на операторы модели, что, в свою очередь, ведет к изменению их семантики функционирования. В связи с этим поведение операторов модели и, как следствие, программы, написанной на соответствующем языке, тоже будет иным. Изменяются аксиомы модели и алгебра эквивалентных преобразований.}

\section{Общие принципы организации модели}

Модель задается тройкой:

\begin{center}
	%	\Large$\mathbf{M = ( G, P, S_0 )}$\normalsize,
	\large$\mathbf{M = ( G, P, S_0 )}$\normalsize,
\end{center}
где $\mathbf{G}$ --- ациклический ориентированный граф, определяющий информационную структуру программы (ее информационный граф), $\mathbf{P}$ --- набор правил, определяющих динамику функционирования модели (механизм формирования разметки), $\mathbf{S_0}$ --- начальная разметка дуг графа, на которых уже сформированы данные, определяющие динамику выполнения.

Информационный граф:

\begin{center}
	%	\Large$\mathbf{G = ( V, A )}$\normalsize,
	\large$\mathbf{G = ( V, A )}$\normalsize,
	%	$\mathbf{G = ( V, A )}$,
\end{center}
где $\mathbf{V}$~--- множество вершин определяющих программоформирующие операторы, а $\mathbf{A}$~--- множество дуг, задающих пути передачи информации между ними.

Вершины графа, соответствующие программоформирующим операторам и хранилищам, обеспечивают информационные преобразования данных, их структуризацию и размножение. Существуют следующие типы вершин:
\begin{itemize}
	\item операторы интерпретации;
	\item константные операторы (константы);
	\item оператор копирования (обозначение);
	\item операторы группировки в списки (составные структуры);
	\item оператор задержки (задержка).
\end{itemize}
Использование в СТМФППВ статической типизации вместо динамической накладывает, с одной стороны, свои ограничения, но, с другой стороны, предоставляет дополнительные возможности по трансформации функционально--потоковых параллельных программ в программы для реальных архитектур.

\subsection{Операторы интерпретации}

\textbf{Операторы интерпретации} предназначены для описания функциональных преобразования аргументов. Каждый такой оператор имеет два входа, на один из которых поступает значение, интерпретируемое как функция $\mathbf{F}$ (функциональный вход), а на другой величина, являющаяся аргументом (вход данных) $\mathbf{X}$, обрабатываемым данной функцией. Использование статической типизации, а также изменение семантики списков в новой модели привели к разделению оператора интерпретации на два разных вида: одиночный (одноаргументный) и групповой (массовый, поэлементный). 

Одиночный оператор интерпретации, обозначаемый в текстовом представлении, как и в ФПМПВ~\cite{legalov2005}, через <<\texttt{:}>> (постфиксная форма) или <<\texttt{\textasciicircum}>> (префиксная форма), предназначен для задания обычных функций, воспринимающих аргумент в качестве единого целого.

Массовый оператор интерпретации используется для задания вычислений над каждым элементом списка, порождая на выходе контейнер с элементами тип которых  соответствует типу результата выполняемой функции. Обозначается двойным значком <<\texttt{::}>> для постфиксной или <<\texttt{\textasciicircum\textasciicircum}>>  для префиксной форм соответственно. В дальнейшем для иллюстрации в примерах используются только постфиксные формы операторов интерпретации.

Использование разных обозначений позволяет однозначно применять функцию с одним и тем же именем в разных контекстах. Например функция вычитания <<\texttt{-}>> над аргументом \texttt{(10, -3)}, воспринимаемом как вектор, состоящий из двух целых чисел, порождает следующие значения:
\begin{itemize}
	\item $\mathbf{(10, -3):- \Rightarrow 13}$ --- двухместная функция вычитания над одним аргументом;
	\item $\mathbf{(10, -3)::- \Rightarrow (-10, 3)}$ --- групповая функция смены знака.
\end{itemize}

Разделение оператора интерпретации на одиночный и групповой позволяет ввести гибкий набор дополнительных функций для списков различной структуры, обеспечивая при этом более разнообразную обработку асинхронно поступающих данных.

\subsection{Константный оператор}

\textbf{Константный оператор} или \textbf{константа} определяет вершину информационного графа, хранящую постоянную величину и всегда готовую к выполнению. Данный оператор не имеет входа. На выходе изначально устанавливается разметка, определяющая предписанное значение. Множество константных операторов информационного графа формируют внутреннюю начальную разметку модели вычислений. В языковом представлении константный оператор задается значением соответствующего типа. Тип константы должен быть известен во время компиляции функции. К константам относятся данные различных типов, например: целые, булевские, сигналы, атомарные функции и функции, определенные программистом. Отнесение к константам функций обуславливается тем, что после их описания они зафиксированы и предоставляют данные непосредственно готовые к выполнению. Примеры констант:
\begin{itemize}
	\item \textbf{10}	--- целочисленная константа;
	\item \textbf{true}  --- булевская константа;
	\item \textbf{!}     --- сигнальная константа;
	\item \textbf{+}     --- атомарная функция плюс;
	\item \textbf{min}   --- имя разработанной функции нахождения минимума двух элементов.
\end{itemize}

\subsection{Оператор копирования}

Оператор копирования представляет собой узел, осуществляющий передачу данных, поступающих на его единственный вход, на множество выходов. По сути это источник данных к которому осуществляется доступ из связанных с ним узлов. Поэтому представленное отдельное графическое обозначение не означает реально выделенного отдельного оператора. В общем случае оператор копирования может объединяться с предшествующим оператором, из которого выходит его выходная дуга. Также возможна цепочка операторов копирования, которая может восприниматься как один оператор. В текстовой форме он определяется через именование передаваемой величины и дальнейшее использование введенного обозначения в требуемых точках функции. Используются как постфиксное именование размножаемого объекта в форме: \verb|величина >> имя|, так и его префиксный эквивалент, имеющий вид: \verb|имя << величина|. Например:
\begin{verbatim}
	y << F^x;
	(x,y):+ >> c;
\end{verbatim}
Тип обозначения совпадает с типом результата предшествующих вычислений и определяется во время компиляции.

\subsection{Операторы группировки в списки}

Операторы группировки в списки (или списки) предназначены для структурирования и формирования поведения поступающих в них данных различными способами, что и определяет разнообразие описываемых вариантов параллелизма, задаваемого моделью вычислений. По формируемому поведению можно выделить следующие группы списков:
\begin{itemize}
	\item синхронный список или соединитель (join), обеспечивающий сбор всех поступающих данных воедино до последующей их выдачи на выход;
	\item параллельный список или рой (swarm), осуществляющий упорядочивание по номеру входа, но не синхронизирующий данные поступающие на различные входы;
	\item асинхронный список или поток (stream), осуществляющий упорядочение данных в соответствии с временем их поступления и выдающий эти данные последовательно в порядке поступления.
\end{itemize}
Каждый вид списка характеризуется как своим типом, так и типом или типами его элементов, а также числом элементов размещаемых в списке. Следует при этом отметить, что эти параметры для каждого вида списков могут отличаться по допустимым значениям.

\subsubsection{Соединитель}

\textbf{Соединитель (join)} имеет несколько входов и один выход. Он обеспечивает структуризацию, упорядочение и синхронизацию данных, поступающих по входным дугам из различных источников. Типы поступающих элементов должны быть известны на этапе компиляции. Порядок элементов определяется номерами входов, каждому из которых соответствует натуральное число в диапазоне от $\mathbf{0}$ до $\mathbf{N-1}$, где $\mathbf{N}$ --- длина формируемого списка. Соединитель готов к последующей обработке, когда в него поступят все входные данные. В текстовом виде оператор задается ограничением элементов списка круглыми скобками <<$\mathbf{(}$>> и <<$\mathbf{)}$>>. Например:

\begin{center}
	$\mathbf{(x1, x2, x3, x4)}$
\end{center}
Нумерация элементов списка начинается с нуля и задается неявно в соответствии с порядком их следования слева направо. Тип элементов списка должен быть известен во время компиляции и определяет одну из возможных вариантов его интерпретации: вектор или кортеж.

Соединители, имеющие тип вектор ($\mathbf{vector}$) предназначены для группировки элементов одного типа. Это позволяет обращаться к ним по имени, а также задавать над ними массовые операции, обеспечивающие параллелизм.

Списки, образующие кортеж ($\mathbf{tuple}$), также имеет несколько входов и один выход. Он обеспечивает структуризацию, упорядочение и синхронизацию разнотипных данных, поступающих по дугам из различных источников. Типы поступающих данных должны быть известны во время компиляции. Доступ к элементам осуществляется по порядковому номеру (индексу). В текстовом виде задается ограничением элементов списка круглыми скобками <<$\mathbf{(}$>> и <<$\mathbf{)}$>> аналогично вектору.


\subsubsection{Рой}

\textbf{Рой (swarm)}, в отличие от соединителя, группирует независимые друг от друга данные. Поступление в рой каждого элемента сопровождается выдачей сигнала готовности, информирующих об этом событии, узлы информационного графа, принимающие от него информацию. Это позволяет оперативно и асинхронно реагировать на изменение состояния роя.

В текстовом виде группировка в рой задается ограничением его элементов квадратными скобками <<$\mathbf{[}$>> и <<$\mathbf{]}$>>. Например:
\begin{center}
	$\mathbf{[x1, x2, x3, x4]}$
\end{center}
Каждый элемент роя формируется независимо и по его появлению готов к выполнению. Как и у соединителя элементы роя могут быть однотипными, образуя вектор, или разнотипными, образуя кортеж.

\subsubsection{Поток}

Понятие потока ($\mathbf{stream}$) расширяет концепцию ранее предложенного асинхронного списка~\cite{asynch}. Основная идея, связанная с асинхронным поступлением данных, сохраняется. Однако предполагается, что все элементы имеют один и тот же тип, который, в свою очередь, не может являться потоком или роем. Это вполне соответствует концепциям универсальных статически типизированных языков. Поток можно рассматривать как сущность к основным характеристикам которой относятся:
\begin{itemize}
	\item при появлении в потоке хотя бы одного готового элемента данных, он порождает сигнал, информирующий об его готовности;
	\item готовый элемент может быть прочитан из потока для обработки;
	\item если во время обработки элемента, выбранного из потока в него поступают новые элементы данных, они также могут асинхронно выбираться из потока в порядке поступления и обрабатываться параллельно;
	\item параллельно обрабатываемые элементы потока могут поступать после обработки в другой поток, тип которого определяется типом результата функции, при этом порядок их поступления	может отличаться от первоначального в зависимости от времени обработки;
	\item поток можно проверить на отсутствие дальнейшего поступления данных, что позволяет завершить работу с ним.
\end{itemize}


\subsection{Задержка}

\textbf{Оператор задержки или задержка} задается вершиной, содержащей допустимый информационный подграф, в который входят несколько входных дуг и выходит одна выходная дуга. Входные дуги определяют поступление аргументов, а выход задает выдаваемый из подграфа результат. Специфической особенностью такой группировки является то, что ограниченные оператором задержки вершины, представляющие другие программоформирующие операторы, не могут выполняться, даже при наличии на входах всех аргументов. Их активизация возможна только при снятии задержки (раскрытии контура), когда ограниченный подграф становится частью всего вычисляемого графа.

Первоначально задержанный подграф создает на своем единственном выходе константную разметку, которая является образом (иконкой) данного подграфа. Эта разметка распространяется по дугам графа от одного программоформирующего оператора к другому, размножаясь, входя в различные списки и выделяясь из них до тех пор, пока не поступит на один из входов оператора интерпретации. Как только оператор задержки становится одним из аргументов оператора интерпретации, вместо иконки происходит подстановка ранее определенного задержанного подграфа с сохранением входных связей. Опоясывающий подграф контур оператора задержки при этом «убирается», и происходит выполнение активированных операторов. В результате на выходной дуге раскрытого подграфа вновь формируется результирующая разметка, которая и является одним из аргументов оператора интерпретации, раскрывшего задержанный подграф. Данная процедура называется раскрытием задержанного подграфа.

В текстовом виде оператор задержки задается охватом других операторов фигурными скобками <<$\mathbf{\{}$>> и <<$\mathbf{\}}$>>. Например:
\begin{center}
	$\mathbf{\{(a,b):+\}}$
\end{center}
Если внутри задержки необходимо сформировать несколько независимых аргументов, то они группируются в рой, который инициируется при раскрытии:
\begin{center}
	$\mathbf{\{[x1, x2, x3, x4]\}}$
\end{center}
Наличие этой конструкции позволяет откладывать момент начала некоторых вычислений или вообще не начинать их, что необходимо при организации выборочной обработки данных. Помимо этого данный оператор, при необходимости, может использоваться в качестве скобок, меняющих приоритет выполнения операторов. Для этого он может быть непосредственно представлен как один из аргументов оператора интерпретации.

\section{Отношения между операторами группировки \\и интерпретации}

Вычисления формируются при поступлении данных на операторы интерпретации, каждый из которых принимает два операнда, один из которых является функцией, а другой аргументом. В ходе интерпретации формируется результат вычислений тип которого зависит как от типов аргумента и функции, так и от типа операции интерпретации. Разнообразные комбинации этих трех составляющих образуют операционную семантику модели вычислений, а также определяют варианты эквивалентных трансформаций в соответствии с алгеброй модели.

\subsection{Использование одиночного оператора интерпретации}

Одиночные оператор интерпретации в большинстве случаев определяет традиционные функциональные преобразования своих аргументов в результат. При этом допустимы следующие комбинации отношений между аргументами одиночного оператора интерпретации:
\begin{itemize}
	\item скаляр --- скаляр;
	\item соединитель --- скаляр;
	\item рой --- скаляр;
	\item поток --- скаляр;
	\item скаляр --- соединитель;
	\item соединитель --- соединитель;
	\item рой --- соединитель;
	\item поток --- соединитель;
	\item скаляр --- рой;
	\item соединитель --- рой;
	\item рой --- рой;
	\item поток --- рой;
\end{itemize}
В представленных отношениях первый аргумент выступает в роли обрабатываемых данных, а второй определяет функцию, осуществляющую обработку этих данных. Следует отметить, что поток не может непосредственно выступать в роли функции. Аргумент является скаляром, если он имеет предопределенный базовый (атомарный) тип или является константой одного из базовых типов.

\subsubsection{Отношение <<скаляр --- скаляр>>}

Данное отношение воспринимается одиночным оператором интерпретации как традиционная функция от одного аргумента. То есть, обрабатываемые данные с константам или вычисляемым значениям базового типа. Формируемый результат определяется семантикой данных, интерпретируемых как функция. Функция может быт как предопределенной, так и разработанной программистом. Например:
\begin{center}
	$\mathbf{x:- \equiv -x}$
	
	$\mathbf{x:sin \equiv sin(x)}$
\end{center}

\subsubsection{Отношение <<соединитель --- скаляр>>}

Отношение практически аналогично выполнению функции от нескольких аргументов, значения который определяются как элементы соединителя:
\begin{center}
	$\mathbf{(x, y):+ \equiv +(x, y) \equiv x + y}$
	
	$\mathbf{(x, y):min \equiv min(x, y)}$
\end{center}

\subsubsection{Отношение <<рой --- скаляр>>}

Данное отношение позволяет формировать асинхронное поступление аргументов в функцию, осуществляющую их отображение. Предполагается, что при появлении любого элемента в рое оператор интерпретации запустит функцию, осуществляющую обработку роя, которая осуществит частичное вычисление. То есть в данном случае отсутствует предварительная синхронизация аргументов перед вызовом функции. Ситуация во многом аналогична использованию вместо функции \textbf{inline}--подстановки. Предполагается что такие вычисления возможны, если при описании разрабатываемой функции ее входной параметр описан как рой. Пример:
\begin{center}
	$\mathbf{[x, y]:min}$
\end{center}

\subsubsection{Отношение <<поток --- скаляр>>}

Данное отношение передает на вход функции, запускаемой оператором интерпретации поток, готовность которого определяется появлением первого элемента. Определение готовности данных для последующих элементов поступившего потока формируется уже внутри функции осуществляющей его обработку.

\subsubsection{Отношения <<данные --- соединитель>}

Соединитель в качестве аргумента--функции оператора интерпретации задает одновременное выполнение всех указанных в нем функций над обрабатываемым аргументом. То есть, в данном случае реализуется параллелизм с множеством независимых потоков команд над одним набором данных. Для любых входных данных $\mathbf{X}$ и списка функций $\mathbf{F=(F_0,F_1,..., F_{n-1})}$ в ходе интерпретации осуществляется эквивалентное преобразование в набор параллельно исполняемых операторов:
\begin{center}
	$\mathbf{X:(F_0,F_1,..., F_{n-1}) \equiv (X:F_0,X:F_1,..., X:F_{n-1})}$
\end{center}
На выходе формируется результат--соединитель.

\subsubsection{Отношения <<данные --- рой>}

Варианты с использованием в качестве набора функций роя  во многом схожи с применением в этой роли соединителя. Отличие проявляется в том, что его аргументы могут вычисляться и в последующем обрабатывать входной аргумент без общей синхронизации. Поэтому появление результатов на отдельных выходах оператора интерпретации, реализующего данное отношение, может быть произвольным с формированием нового роя. Для входных данных $\mathbf{X}$ и списка функций $\mathbf{F=[F_0,F_1,..., F_{n-1}]}$ в ходе интерпретации осуществляется эквивалентное преобразование в набор параллельно исполняемых операторов:
\begin{center}
	$\mathbf{X:[F_0,F_1,..., F_{n-1}] \equiv [X:F_0,X:F_1,..., X:F_{n-1}]}$
\end{center}
На выходе формируется результат--рой.

\subsection{Использование группового оператора интерпретации}

Групповой оператор интерпретации ориентирован на массовую обработку множества структурированных наборов данных одной командой. Основной его задачей является задание поэлементной обработки различных списков. При этом окончательные вычисления формируются через одиночные операторы интерпретации, сведение к которым осуществляется за счет алгебры эквивалентных преобразований. Для группового оператора интерпретации допустимы следующие комбинации отношений:
\begin{itemize}
	\item соединитель --- скаляр;
	\item рой --- скаляр;
	\item поток --- скаляр;
\end{itemize}
В отличие от одиночного оператора интерпретации в групповом операторе ведется выполнение функции над элементами группы. Более сложные варианты функций, образующие различные списки, ведут к формированию многомерных конструкций и на уровне модели вычислений пока не рассматриваются.

\subsubsection{Отношение <<соединитель --- скаляр>>}

В рамках этого отношения соединитель рассматривается как вектор, состоящий из однотипных элементов, к каждому из которых применяется одна и та же функция, выступающая в роли скаляра. 

Пусть $\mathbf{X \equiv (x_0, x_1, ..., x_{n-1})}$ --- соединитель, задающий вектор обрабатываемых данных, $\mathbf{f}$ --- функция. Тогда, с учетом последующих эквивалентных преобразований, групповой оператор интерпретации для данного отношения можно представить следующим образом:
\begin{center}
	$\mathbf{X::f \equiv (x_0, x_1, ..., x_{n-1})::f \equiv}$\\
	$\mathbf{\equiv (x_0:f, x_1:f, ..., x_{n-1}:f)}$
\end{center}

\subsubsection{Отношение <<рой --- скаляр>>}

Это отношение во многом аналогично предыдущему. Отличие заключается в том, что выполнение функций над отдельными элементами начинается сразу же по поступлении этих элементов. Также асинхронно формируется рой в результате выполнения функций.

Рой задается следующим образом: $\mathbf{X \equiv [x_0, x_1, ..., x_{n-1}]}$. Групповая операция над роем с использованием функции  $\mathbf{f}$ определяется следующим эквивалентным преобразованием:
\begin{center}
	$\mathbf{X::f \equiv [x_0, x_1, ..., x_{n-1}]::f \equiv}$\\
	$\mathbf{\equiv [x_0:f, x_1:f, ..., x_{n-1}:f]}$
\end{center}

\subsubsection{Отношение <<поток --- скаляр>>}

Групповая интерпретация отношения осуществляется по аналогии с предшествующими. То есть, функция выполняется над каждым элементом потока до тех пор, пока в поток из различных источников поступают элементы. В результате на выходе формируется новый поток. Следует отметить, что порядок следования результатов в новом потоке может не совпадать с порядком следования исходных данных. Это объясняется тем, что даже при выполнении одной и той же функции время вычислений может отличаться по разным причинам. Спецификой потока является также то, что количество обрабатываемых элементов может быть неизвестным заранее, а завершение поступления элементов определяется по считыванию маркера конца потока.

